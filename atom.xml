<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端学习笔记</title>
  
  
  <link href="https://yuanmingjian.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuanmingjian.github.io/"/>
  <updated>2024-12-01T06:34:57.856Z</updated>
  <id>https://yuanmingjian.github.io/</id>
  
  <author>
    <name>来一份棉花糖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>axios和featch的写法</title>
    <link href="https://yuanmingjian.github.io/2024/11/12/%E6%9D%82/axios%E5%92%8Cfeatch/"/>
    <id>https://yuanmingjian.github.io/2024/11/12/%E6%9D%82/axios%E5%92%8Cfeatch/</id>
    <published>2024-11-12T11:43:25.052Z</published>
    <updated>2024-12-01T06:34:57.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fetch和-axios的书写"><a href="#fetch和-axios的书写" class="headerlink" title="fetch和 axios的书写"></a>fetch和 axios的书写</h3><p><img src="/../../images/image-20241112194707752.png" alt="image-20241112194707752"></p><p><img src="/../../images/image-20241112200756387.png" alt="image-20241112200756387"></p><p>1axios中默认的请求头会给我们将Content-type自动设置成 application&#x2F;json  fetch就需要我们手动书写 不然就会导致传到后端的数据有误</p><p>2 请求体的数据在body中需要使用 JSON.stringify（） 将我们的js对象序列化  而在axios我们不需要关心这一点 axios也为我们做好了封装</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;fetch和-axios的书写&quot;&gt;&lt;a href=&quot;#fetch和-axios的书写&quot; class=&quot;headerlink&quot; title=&quot;fetch和 axios的书写&quot;&gt;&lt;/a&gt;fetch和 axios的书写&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../../i</summary>
      
    
    
    
    <category term="杂" scheme="https://yuanmingjian.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="网络的一些杂" scheme="https://yuanmingjian.github.io/tags/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yuanmingjian.github.io/2024/11/11/%E5%B7%A5%E5%85%B7/nvm/"/>
    <id>https://yuanmingjian.github.io/2024/11/11/%E5%B7%A5%E5%85%B7/nvm/</id>
    <published>2024-11-11T09:56:21.388Z</published>
    <updated>2024-11-11T09:57:02.535Z</updated>
    
    <content type="html"><![CDATA[<p>接入nvm</p><p>参考文章</p><p><a href="https://juejin.cn/post/7369027991442030643?searchId=20241111174855313D411D14D37EC1E9E8">https://juejin.cn/post/7369027991442030643?searchId=20241111174855313D411D14D37EC1E9E8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接入nvm&lt;/p&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7369027991442030643?searchId=20241111174855313D411D14D37EC1E9E8&quot;&gt;https://juejin.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TS装饰器与元数据</title>
    <link href="https://yuanmingjian.github.io/2024/11/11/nest/Ts%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE/"/>
    <id>https://yuanmingjian.github.io/2024/11/11/nest/Ts%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE/</id>
    <published>2024-11-11T07:30:46.226Z</published>
    <updated>2024-11-19T09:37:07.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰器的含义"><a href="#装饰器的含义" class="headerlink" title="装饰器的含义"></a>装饰器的含义</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。装饰器使用 @expression这种形式，expression求值后必须为一个函数，该函数会在运行时被调用（不管类是否实例化都会第一时间调用），被装饰者的信息（根据被装饰着不同而略有不同）将做为参数传入expression求值后的函数中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;装饰器的含义&quot;&gt;&lt;a href=&quot;#装饰器的含义&quot; class=&quot;headerlink&quot; title=&quot;装饰器的含义&quot;&gt;&lt;/a&gt;装饰器的含义&lt;/h3&gt;&lt;p&gt;装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。装饰器使用 @express</summary>
      
    
    
    
    <category term="nest框架" scheme="https://yuanmingjian.github.io/categories/nest%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="nest入门" scheme="https://yuanmingjian.github.io/tags/nest%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>ioc依赖注入</title>
    <link href="https://yuanmingjian.github.io/2024/11/09/nest/ioc%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>https://yuanmingjian.github.io/2024/11/09/nest/ioc%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2024-11-09T08:39:09.680Z</published>
    <updated>2024-11-12T12:49:14.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ioc-控制反转"><a href="#ioc-控制反转" class="headerlink" title="ioc 控制反转"></a>ioc 控制反转</h3><p><strong>什么是控制反转（Inversion Of Control）</strong></p><p>控制反转是一种设计原则。顾名思义，它用于在面向对象设计中反转不同种类的控制以实现松耦合。在这里，控制是指一个类中除了完成其主要工作流程之外的其他所有流程，包括对应用程序流程的控制，以及对依赖对象创建和绑定流程的控制。</p><p><strong>什么是依赖注入（Dependency Injection）</strong></p><p>控制反转只告诉了我们需要怎么去做，但并没有告诉我们应该怎么做。所以实现控制反转的手段多种多样，其中比较流行的也是Nest、Spring等主流框架所使用的手段就是依赖注入。</p><p>依赖注入允许在类之外创建依赖对象，并通过<em><strong>不同的方式</strong></em>将这些对象提供给类。使用依赖注入的手段，我们能够将类所依赖对象的创建和绑定移动到类自身的实现之外。</p><p><em><strong>不同的方式</strong></em>包括：构造函数注入、属性注入、Setter方法注入、接口注入。</p><p><strong>我不想看概念了，能简单的说一下它们到底做了什么吗？</strong></p><p>通俗的说通过控制反转和依赖注入实现了以下功能：</p><p>如果类A需要类B，类A中并不直接控制创建类B的实例。与之相反，我们从类A外部控制类B实例的创建，类A之中只负责使用类B的实例，完全无需关心类B实例是如何创建的。</p><p><strong>参考文章</strong>：  <a href="https://juejin.cn/post/7085614364396355598">https://juejin.cn/post/7085614364396355598</a>  </p><p>最后，我们将Nest中的元素与我们自己编写的工厂进行一个类比：</p><ol><li><p>Provider &amp; Worker&#x2F;Machine：真正提供具体功能实现的低层类。</p></li><li><p>Controller &amp; ScrewWorkshop：调用低层类来为用户提供服务的高层类。</p></li><li><p>Nest框架本身 &amp; Factory：控制反转容器，对高层类和低层类统一管理，控制相关类的新建与注入，解藕了类之间的依赖。</p></li></ol><p><img src="/Yuanmingjian/../../images/image-20241112204839697.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ioc-控制反转&quot;&gt;&lt;a href=&quot;#ioc-控制反转&quot; class=&quot;headerlink&quot; title=&quot;ioc 控制反转&quot;&gt;&lt;/a&gt;ioc 控制反转&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什么是控制反转（Inversion Of Control）&lt;/strong&gt;</summary>
      
    
    
    
    <category term="nest框架" scheme="https://yuanmingjian.github.io/categories/nest%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="nest入门" scheme="https://yuanmingjian.github.io/tags/nest%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学前端</title>
    <link href="https://yuanmingjian.github.io/2024/11/09/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/"/>
    <id>https://yuanmingjian.github.io/2024/11/09/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/</id>
    <published>2024-11-09T07:12:12.990Z</published>
    <updated>2024-11-11T06:49:36.732Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/Yuanmingjian/../images/image-20241109153545163.png" alt="image-20241109153545163"></p><p>js 按照文法、语义、运行时来拆分 </p><p>这符合编程语言的一般规律：<strong>用一定的词法和语法，表达一定语义，从而操作运行时。</strong></p><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。</p><p>下面我们来看一看，为什么给对象添加的方法能用在基本类型上？</p><p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><h2 id="装箱机制"><a href="#装箱机制" class="headerlink" title="装箱机制"></a>装箱机制</h2><p>3和new Number（3） 一个是基础类型 一个是对象类型</p><p>我给new Number（3）的原型对象加一个方法  3这个玩意可以直接调用 这是因为调用函数的时候 自动装箱转换成对象类型（new  Number（3））并调用该原型的方法 </p><p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</p><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&quot;a&quot;));</span><br><span class="line"> </span><br><span class="line">console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]</span><br></pre></td></tr></table></figure><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p><p>但需要注意的是，<strong>call 本身会产生装箱操作</strong>，所以需要配合 typeof 来区分基本类型还是对象类型。</p><p>注意：&#x3D;&#x3D;运算符会自动拆箱 将对象转换为基本类型   object函数也会自动将对象转换为基本类型</p><h2 id="JavaScript对象：面向对象还是基于对象？"><a href="#JavaScript对象：面向对象还是基于对象？" class="headerlink" title="JavaScript对象：面向对象还是基于对象？"></a>JavaScript对象：面向对象还是基于对象？</h2><p>对象有如下几个特点。</p><ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。‘</li></ul><p>js对象独有的特点具有高度动态性的属性集合</p><p>在 JavaScript 中，对象的状态和行为其实都被抽象为了属性  一个值一个方法都是对象的属性</p><p><strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong></p><p>我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p><p>下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 1 &#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">console.log(o.a, o.b); //1 2</span><br></pre></td></tr></table></figure><p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter&#x2F;setter）两类。</p><h4 id="JavaScript-对象的两类属性"><a href="#JavaScript-对象的两类属性" class="headerlink" title="JavaScript 对象的两类属性"></a>JavaScript 对象的两类属性</h4><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p><p>先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。</p><ul><li>value：就是属性的值。</li><li>writable：决定属性能否被赋值。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><p>在大多数情况下，我们只关心数据属性的值即可。</p><p>第二类属性是访问器（getter&#x2F;setter）属性，它也有四个特征。</p><ul><li>getter：函数或 undefined，在取属性值时被调用。</li><li>setter：函数或 undefined，在设置属性值时被调用。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 1 &#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">//a 和 b 皆为数据属性</span><br><span class="line">Object.getOwnPropertyDescriptor(o,&quot;a&quot;) // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">Object.getOwnPropertyDescriptor(o,&quot;b&quot;) // &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure><p>我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/Yuanmingjian/../images/image-20241109153545163.png&quot; alt=&quot;image-20241109153545163&quot;&gt;&lt;/p&gt;
&lt;p&gt;js 按照文法、语义、运行时来拆分 &lt;/p&gt;
&lt;p&gt;这符合编程语言的一般</summary>
      
    
    
    
    <category term="基础知识" scheme="https://yuanmingjian.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础知识" scheme="https://yuanmingjian.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>nest简介</title>
    <link href="https://yuanmingjian.github.io/2024/11/08/nest/%E5%88%9D%E5%85%A5/"/>
    <id>https://yuanmingjian.github.io/2024/11/08/nest/%E5%88%9D%E5%85%A5/</id>
    <published>2024-11-08T12:47:24.630Z</published>
    <updated>2024-11-14T10:03:26.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://nodejs.org/">Nest 是一个用于构建高效、可扩展的Node.js</a>服务器端应用程序的框架。它使用现代 JavaScript，以<a href="https://www.typescriptlang.org/">TypeScript</a>构建（保留与纯 JavaScript 的兼容性），并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式响应式编程）的元素。</p><p>在底层，Nest 使用了<a href="https://expressjs.com/">Express ，但也提供了与</a><a href="https://github.com/fastify/fastify">Fastify</a>等多种其他库的兼容性，从而可以轻松使用大量可用的第三方插件。</p><h3 id="q1：oop、fp、frp的解释"><a href="#q1：oop、fp、frp的解释" class="headerlink" title="q1：oop、fp、frp的解释"></a>q1：oop、fp、frp的解释</h3><h3 id="OOP（面向对象编程）"><a href="#OOP（面向对象编程）" class="headerlink" title="OOP（面向对象编程）"></a>OOP（面向对象编程）</h3><p><strong>面向对象</strong>编程是一种编程范式，它将数据和处理数据的方法组织成对象。对象是类的实例，类是对象的模板。</p><p><strong>特点</strong>:</p><ul><li>抽象：通过类和对象来模拟现实世界的事物。</li><li>封装：将数据和行为打包在一起。</li><li>继承：允许新的类继承一个或多个现有类的属性和方法。</li><li>多态：允许不同类的对象通过继承同一接口使用相同的代码。</li></ul><h3 id="FP（函数式编程）"><a href="#FP（函数式编程）" class="headerlink" title="FP（函数式编程）"></a>FP（函数式编程）</h3><p><strong>函数式编程</strong>是一种编程范式，它将计算视为函数的评估，并避免使用状态和可变数据。</p><p><strong>特点</strong>:</p><ul><li>纯函数：输出只依赖于输入的函数，没有副作用。</li><li>不可变性：数据一旦创建就不会被修改。</li><li>高阶函数：可以接收其他函数作为参数或将函数作为返回值的函数。</li><li>递归：函数通过自身调用以解决复杂问题。</li></ul><p>解决以下</p><ul><li>可扩展性–我是否需要不断地重构代码来支持额外的功能？</li><li>易模块化–如果我更改了一个文件，另一个文件是否会受到影响？</li><li>可重用性–是否有很多重复的代码？</li><li>可测性–给这些函数添加单元测试是否让我纠结？</li><li>易推理性–我写的代码是否非结构化严重并难以推理？</li></ul><p>函数式编程的目的是使用函数来<strong>抽象作用在数据之上的控制流和操作</strong>，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong></p><h3 id="FRP（函数式响应式编程）"><a href="#FRP（函数式响应式编程）" class="headerlink" title="FRP（函数式响应式编程）"></a>FRP（函数式响应式编程）</h3><p>函数式响应式编程是函数式编程的一个分支，它强调对事件或数据流的响应。</p><p><strong>特点</strong>:</p><ul><li><p>响应式：程序可以自动响应数据流的变化。</p></li><li><p>声明式：描述应该做什么，而不是如何做。</p></li><li><p>数据流：将数据变化视为流，并可以对这些流进行操作。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 – Michacel Feathers（Twitter）</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面编程）是一种编程范式，它允许开发者通过定义切面（Aspects）来对应用程序的各个部分添加横切关注点（Cross-Cutting Concerns）。横切关注点是那些不属于应用程序核心业务逻辑，但在整个应用程序中多处重复出现的功能或行为。AOP 允许开发者在不侵入业务逻辑的情况下来加入一些通用逻辑，如日志记录、事务管理、安全控制等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Nest 是一个用于构建高效、可扩展的Node.js&lt;/a&gt;服务器端应用程序的框</summary>
      
    
    
    
    <category term="nest框架" scheme="https://yuanmingjian.github.io/categories/nest%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="nest学习" scheme="https://yuanmingjian.github.io/tags/nest%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>react的hook之useReducer</title>
    <link href="https://yuanmingjian.github.io/2024/10/18/react/useReducer/"/>
    <id>https://yuanmingjian.github.io/2024/10/18/react/useReducer/</id>
    <published>2024-10-18T08:27:18.199Z</published>
    <updated>2024-11-11T06:50:39.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>上边我们提到过基础的状态管理钩子 useState ，在 React Hook 中额外提供了一个关于状态管理的 useReducer。</p><h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a>useReducer 用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p>useReducer 接受三个参数分别是 reducer 函数、初始值 initialArg 以及一个可选的惰性初始化的 init 函数。</p><p>它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p><p>让我们通过一个简单的计数器例子来了解一下它的基础用法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAction</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span>;</span><br><span class="line">  <span class="attr">payload</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">IState</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state: IState, action: IAction</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;subtract&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Illegal operation in reducer.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello , My name is 19Qingfeng.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Counter: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;add&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          add 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;subtract&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          subtract 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个简单的 Counter 计数器组件，内部通过 useReducer 管理 couter 的状态。</p><blockquote><p>你可以在<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/elastic-kilby-x3kco">这里</a>来体验这个计数器小例子。</p></blockquote><h3 id="useState-amp-useReducer"><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h3><p>上边的计数器小例子我们其实通过 setState 完全也可以实现，大部分同学在写 component 时应该有存在这样一个疑问:</p><p>「什么时候使用 useState 又什么时候使用 useReducer ，useReducer 相比 useState 存在什么优势&#x2F;不足呢？」</p><p>其实在日常大多数情况下使用 useState 完全可以满足日常开发的作用，毕竟如果对于一个简单的操作如果使用 action -&gt; reducer -&gt; store 这种方式去管理状态实在是有点大材小用。</p><p>关于状态管理究竟是使用 useState 还是 useReducer 绝大多数文章会告诉你 useReducer 适用于复杂的状态逻辑。</p><p>没错，日常应用中我我也是这样使用的，存在多种复杂状态管理时利用 reducer 函数根据不同 action 去派发状态更新。</p><p>但是话又说回来如果某个 state 下存在很多操作状态，每个操作都有很多逻辑，对于这样复杂的状态，使用 useState 拥有单独的功能管理相比 reducer 中单个函数中的多个不同动作也许会更加清晰一些。</p><p>关于「什么时候使用 useState 又什么时候使用 useReducer」，在我个人看来这两种方式的使用更像是一种取舍<strong>总而言之尽量使用你觉得舒服的方法，对你和同事来说更容易理解就可以了。</strong></p><h3 id="深更新的组件做性能优化"><a href="#深更新的组件做性能优化" class="headerlink" title="深更新的组件做性能优化"></a>深更新的组件做性能优化</h3><p>在 useReducer 的官方文档中存在这样一句介绍:</p><blockquote><p>并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数</p></blockquote><p>在某些场景下我们通常会将函数作为 props 传递到 child component 中去，这样的话，每次父组件 re-render 时即使我们并没有修改当作 props 的函数，子组件也会重新渲染。</p><p>我们来一起看一下这个例子:  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Hello This is Parent Component!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ParentCount: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ParentComponent</span>;</span><br><span class="line">ts 代码解读复制代码<span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="variable constant_">FC</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  callback?: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">&#123; callback &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;child re-render&#x27;</span>);</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello This is Child Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;callback &amp;&amp; callback()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure><p>这里我们在父组件中传递给子组件一个 callback 函数作为 props ，当我们点击页面上的按钮来看看会发生什么:</p><p><img src="/Yuanmingjian/../../images/c88d9f17814249c692014fcf0e34142etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.gif" alt="QQ20211219-144858-HD.gif"></p><p>每次点击父组件的 button 时，子组件中的 effect 中被执行了。</p><p>此时其实我们传入子组件的 callback 并没有做什么改变，我们自然期望子组件中的 Effect 不会执行。</p><blockquote><p>产生这个原因的机制是 React 每次渲染都会重新执行组件函数，当重新执行父组件时会重新生成一个 callback 函数。因为 React 内部使用 Object.is 判断，所以 React 会认为子组件的 props 发生了变化。</p></blockquote><blockquote><p>你可以点击这里查看<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/blue-wave-r5qs5"> CodeSanBox 例子</a></p></blockquote><p><strong>而在 useReduce 中返回的 dispatch 正是一个函数，但是 useReducer 的好处之一便是， dispatch 不会随着 re-render 而重新分配记忆位置，比方上述我们将 dispatch 作为 props 传入 child component 中时子组件中的 Effect 也并不会被执行。</strong></p><p>有兴趣的同学可以私下自己去尝试下，当然使用 useCallback 包括我们上述 Demo 中父组件的函数也是可以达到相同的效果，但是如此也就意味着說我们有非常多的 callback 需要绑在 useCallback 里边，这也许并不是一件好事</p><p>作者：19组清风<br>链接：<a href="https://juejin.cn/post/7043772161596588046">https://juejin.cn/post/7043772161596588046</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;上边我们提到过基础的状态管理钩子 useState ，在 React Hoo</summary>
      
    
    
    
    <category term="react" scheme="https://yuanmingjian.github.io/categories/react/"/>
    
    
    <category term="react的hook函数" scheme="https://yuanmingjian.github.io/tags/react%E7%9A%84hook%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>react的一些小记</title>
    <link href="https://yuanmingjian.github.io/2024/10/11/react/react%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/"/>
    <id>https://yuanmingjian.github.io/2024/10/11/react/react%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</id>
    <published>2024-10-11T09:56:31.020Z</published>
    <updated>2024-11-11T06:51:01.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="副作用的理解"><a href="#副作用的理解" class="headerlink" title="副作用的理解"></a>副作用的理解</h3><p> <img src="/Yuanmingjian/../../images/image-20241011175717835.png" alt="image-20241011175717835"></p><p><img src="/Yuanmingjian/../../images/image-20241011180049973.png" alt="image-20241011180049973"></p><p>由渲染本身引起的对接组件外部的操作  —— 副作用 如 发送网络请求、定时器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;副作用的理解&quot;&gt;&lt;a href=&quot;#副作用的理解&quot; class=&quot;headerlink&quot; title=&quot;副作用的理解&quot;&gt;&lt;/a&gt;副作用的理解&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;/Yuanmingjian/../../images/image-2024101117</summary>
      
    
    
    
    <category term="react" scheme="https://yuanmingjian.github.io/categories/react/"/>
    
    
    <category term="react的一些小记（知识点）" scheme="https://yuanmingjian.github.io/tags/react%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E8%AE%B0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>一行代码实现响应式</title>
    <link href="https://yuanmingjian.github.io/2024/09/25/css/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <id>https://yuanmingjian.github.io/2024/09/25/css/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%93%8D%E5%BA%94%E5%BC%8F/</id>
    <published>2024-09-25T02:58:32.507Z</published>
    <updated>2024-11-11T07:04:12.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="columo-count-新特性"><a href="#columo-count-新特性" class="headerlink" title="columo count  新特性"></a>columo count  新特性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">### </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">column-count</span>: <span class="number">3</span>;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 在较宽屏幕下分为三列 */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">column-gap</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">         <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">column-count</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 中等宽度屏幕下分为两列 */</span></span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">​    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span></span><br><span class="line"><span class="language-css">​     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">​        <span class="attribute">column-count</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">​        <span class="comment">/* 窄屏幕下为一列 */</span></span></span><br><span class="line"><span class="language-css">​      &#125;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">​    <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">​    *&#123;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;columo-count-新特性&quot;&gt;&lt;a href=&quot;#columo-count-新特性&quot; class=&quot;headerlink&quot; title=&quot;columo count  新特性&quot;&gt;&lt;/a&gt;columo count  新特性&lt;/h3&gt;&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="css" scheme="https://yuanmingjian.github.io/categories/css/"/>
    
    
    <category term="css的一些知识点" scheme="https://yuanmingjian.github.io/tags/css%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yuanmingjian.github.io/2024/05/17/%E6%96%87%E7%AB%A0/"/>
    <id>https://yuanmingjian.github.io/2024/05/17/%E6%96%87%E7%AB%A0/</id>
    <published>2024-05-17T11:26:41.539Z</published>
    <updated>2024-05-30T12:54:56.673Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-微信公众号文章"><a href="#title-微信公众号文章" class="headerlink" title="title :微信公众号文章"></a>title :微信公众号文章</h2><p><a href="https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg">https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg</a> 在Vue中动态引入图片，为什么要用require</p><p><a href="https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw">https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw</a>  JS 分片任务的高阶函数封装</p><p><a href="https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw">https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw</a>  2024 Vue 联邦大会，全明星阵容！探讨 Vue 的未来和问题</p><p><a href="https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg">https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg</a> CSS3实现无缝滚动scroll，实用&#x3D;很丝滑+很漂亮+源码</p><p><a href="https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw">https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw</a> 美化你的Github，变身专业大佬</p><p> <a href="https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ">https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ</a>  前端如何防止接口重复提交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-微信公众号文章&quot;&gt;&lt;a href=&quot;#title-微信公众号文章&quot; class=&quot;headerlink&quot; title=&quot;title :微信公众号文章&quot;&gt;&lt;/a&gt;title :微信公众号文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue组件和vuex数据绑定</title>
    <link href="https://yuanmingjian.github.io/2024/05/09/bug/vue%E7%BB%84%E4%BB%B6%E5%92%8Cvuex%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>https://yuanmingjian.github.io/2024/05/09/bug/vue%E7%BB%84%E4%BB%B6%E5%92%8Cvuex%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</id>
    <published>2024-05-09T09:27:57.107Z</published>
    <updated>2024-11-12T12:16:14.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用computed作为桥梁"><a href="#用computed作为桥梁" class="headerlink" title="用computed作为桥梁"></a>用computed作为桥梁</h3><h5 id="之前放在data里面"><a href="#之前放在data里面" class="headerlink" title="之前放在data里面"></a>之前放在data里面</h5><p><img src="/Yuanmingjian/../../images/image-20240509172934274.png" alt="image-20240509172934274"></p><p>问题： 通过其他方式改变vuex里面这个state的数据后 该组件不会响应</p><p>原因：</p><ol><li><strong>Vue的响应式系统是基于getter和setter的</strong>：当Vue实例被创建时，它会遍历<code>data</code>对象中的所有属性，并使用<code>Object.defineProperty</code>将它们转化为getter&#x2F;setter，从而使这些属性变得“响应式”。<strong>但是，当你之后直接将Vuex的<code>state</code>中的数据赋值给<code>data</code>属性时，这些属性已经不再是Vue在初始化时定义的那些了，因此它们没有getter&#x2F;setter，也就不会触发视图更新。</strong></li></ol><p>解决方法</p><p><img src="/Yuanmingjian/../../images/image-20240509173132692.png" alt="image-20240509173132692"></p><p>把变量来放在computed里面</p><p>在Vue中，<code>computed</code>属性是基于它们的依赖进行缓存的。只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>computed</code>属性依赖的数据发生变化，它就会触发重新计算，并且如果计算的结果与之前的值不同，那么它还会触发视图更新。</p><p>Vuex的<code>state</code>是存储应用程序状态（也就是数据和状态信息）的地方。Vuex的状态管理模式是集中式的，也就是说我们有一个“单一状态树”，它包含了所有的应用状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用computed作为桥梁&quot;&gt;&lt;a href=&quot;#用computed作为桥梁&quot; class=&quot;headerlink&quot; title=&quot;用computed作为桥梁&quot;&gt;&lt;/a&gt;用computed作为桥梁&lt;/h3&gt;&lt;h5 id=&quot;之前放在data里面&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="bug" scheme="https://yuanmingjian.github.io/categories/bug/"/>
    
    
    <category term="vue的一些遇到的bug/问题" scheme="https://yuanmingjian.github.io/tags/vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%81%87%E5%88%B0%E7%9A%84bug-%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>axios请求拦截</title>
    <link href="https://yuanmingjian.github.io/2024/04/11/axios%E6%8B%A6%E6%88%AA/"/>
    <id>https://yuanmingjian.github.io/2024/04/11/axios%E6%8B%A6%E6%88%AA/</id>
    <published>2024-04-11T08:35:57.424Z</published>
    <updated>2024-04-11T08:36:26.514Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/image-20240411163605097.png" alt="image-20240411163605097"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/image-20240411163605097.png&quot; alt=&quot;image-20240411163605097&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pnpm	与 npm</title>
    <link href="https://yuanmingjian.github.io/2024/04/10/pnpm/"/>
    <id>https://yuanmingjian.github.io/2024/04/10/pnpm/</id>
    <published>2024-04-10T13:44:11.869Z</published>
    <updated>2024-04-10T13:58:27.949Z</updated>
    
    <content type="html"><![CDATA[<p> 为什么浏览器可以访问nodemodules下的资源文件  因为vite或者webpack帮我们在一个端口假如是5173启动了一台静态服务器</p><p>文件访问能力是nodejs提供的 npm依旧是nodejs环境的 </p><h4 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h4><p>1利用操作系统的软连接技术提升性能</p><p>   a下载安装快</p><p>   b 节省磁盘空间</p><p>2 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 为什么浏览器可以访问nodemodules下的资源文件  因为vite或者webpack帮我们在一个端口假如是5173启动了一台静态服务器&lt;/p&gt;
&lt;p&gt;文件访问能力是nodejs提供的 npm依旧是nodejs环境的 &lt;/p&gt;
&lt;h4 id=&quot;pnpm&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yuanmingjian.github.io/2024/04/09/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://yuanmingjian.github.io/2024/04/09/%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2024-04-09T09:59:06.721Z</published>
    <updated>2024-04-09T10:04:08.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="setTimeout-与-setlnvertal-的区别"><a href="#setTimeout-与-setlnvertal-的区别" class="headerlink" title="setTimeout 与 setlnvertal 的区别"></a>setTimeout 与 setlnvertal 的区别</h3><ul><li><p>setTimeout 是递归循环，它基本上可以保证代码的执行顺序，每次的至少延迟时长大于等于设置的时间。</p></li><li><p>setlnvertal 每次定时触发执行回调函数，它的执行时间间隔可能会比期待的要小，而且不关心前一个回调函数是否执行，不会重复注册回调。</p><p> 定时放setinvertal进去 不管是否执行完 当执行时间大于间隔 会出现定时器代码间隔会比预期要小</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;setTimeout-与-setlnvertal-的区别&quot;&gt;&lt;a href=&quot;#setTimeout-与-setlnvertal-的区别&quot; class=&quot;headerlink&quot; title=&quot;setTimeout 与 setlnvertal 的区别&quot;&gt;&lt;/a&gt;se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理总结</title>
    <link href="https://yuanmingjian.github.io/2024/04/09/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://yuanmingjian.github.io/2024/04/09/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-09T07:21:10.334Z</published>
    <updated>2024-11-04T13:19:48.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-vue数据双向绑定的原理是什么？"><a href="#6-vue数据双向绑定的原理是什么？" class="headerlink" title="6.vue数据双向绑定的原理是什么？"></a>6.vue数据双向绑定的原理是什么？</h2><p><img src="/../../../images/image-20240125145019146.png" alt="image-20240125145019146"></p><h5 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h5><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给 订阅者，触发相应的监听回调。 </p><p>第一步:需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter<br>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据 变化 </p><p>第二步:compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图<br>第三步:Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情 是: </p><p>1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 </p><p>3、<strong>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</strong><br>第四步:MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher </p><p><strong>三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>Vue 的数据双向绑定是通过 Object.defineProperty() 方法实现的。在 Vue 中，每个组件实例都有一个对应的 Watcher 实例，Watcher 实例负责监听组件实例对象中所有用到的数据变化。</p><p>当数据发生变化时，Watcher 会通知订阅它的视图进行更新，从而实现了数据的响应式渲染。</p><p>具体来说，Vue 通过 Object.defineProperty() 方法实现了数据代理和数据劫持：</p><ul><li>数据代理：通过 Object.defineProperty() 方法将组件实例对象中的 data 对象中的属性代理到组件实例对象本身中，这样就可以通过 <a href="http://this.xxx/">this.xxx</a> 的方式直接访问 data 中的属性。</li><li>数据劫持：在代理过程中，由于使用了 Object.defineProperty() 方法，因此可以在读取或设置 data 属性值时，触发相应的 getter 和 setter 方法。在 getter 和 setter 方法中，通过收集 Watcher 实例的依赖关系，实现了数据发生变化时视图的响应式更新。</li></ul><p>总的来说，Vue 的数据双向绑定原理就是通过数据代理和数据劫持，以及 Watcher 实例的依赖收集和更新机制，实现了组件实例对象和视图之间的动态响应式绑定。这种机制避免了手动操作 DOM 元素的繁琐工作，提高了代码的可维护性和复用性。</p><p><img src="/../../../images/image-20240125144710461.png" alt="image-20240125144710461"></p><p><img src="/../../../images/image-20240125144948370.png" alt="image-20240125144948370"></p><h3 id="Dep补充"><a href="#Dep补充" class="headerlink" title="Dep补充"></a>Dep补充</h3><p><img src="/../../../images/image-20240125151254002.png" alt="image-20240125151254002"></p><h3 id="watcher补充"><a href="#watcher补充" class="headerlink" title="watcher补充"></a>watcher补充</h3><p><img src="/../../../images/image-20240202101644551.png" alt="image-20240202101644551"></p><p><img src="/../../../images/image-20240125153018052.png" alt="image-20240125153018052"></p><p><img src="/../../../images/image-20240125153538474.png" alt="image-20240125153538474"></p><p>在 Vue 中，<code>Dep</code>（依赖）和 <code>Watcher</code>（观察者）是实现响应式系统的重要组件。<code>Dep</code> 用来收集依赖（即 <code>Watcher</code>），当数据发生变化时，会通知所有依赖进行更新。<code>Watcher</code> 则用来观察数据的变化，当数据发生变化时，执行相应的回调函数。</p><p><code>Dep.target</code> 是一个全局变量，用来在收集依赖的过程中，将当前的 <code>Watcher</code> 与 <code>Dep</code> 进行绑定。</p><p>以下是 <code>Dep</code> 和 <code>Watcher</code> 如何互相绑定的简要过程：</p><ol><li><strong>初始化 Watcher</strong>：<br>当 Vue 组件需要观察某个数据时（例如，在模板中使用了数据属性），Vue 会为这个数据创建一个 <code>Watcher</code>。在创建 <code>Watcher</code> 的过程中，Vue 会将 <code>Dep.target</code> 设置为当前的 <code>Watcher</code>。</li><li><strong>访问数据</strong>：<br>当组件渲染或重新渲染时，会访问数据。如果数据是响应式的（即被 <code>Vue.observable</code> 或 <code>new Vue(&#123; data: ... &#125;)</code> 包裹过），那么这个数据会有一个与之关联的 <code>Dep</code> 实例。</li><li><strong>收集依赖</strong>：<br>在访问数据的过程中，<code>Dep</code> 会检查 <code>Dep.target</code> 是否存在。如果存在（即当前有 <code>Watcher</code> 正在观察数据），那么 <code>Dep</code> 会将 <code>Dep.target</code>（即当前的 <code>Watcher</code>）添加到其依赖列表中。</li><li><strong>重置 Dep.target</strong>：<br>收集完依赖后，Vue 会将 <code>Dep.target</code> 重置为 <code>null</code>，以确保下一个 <code>Watcher</code> 创建时不会错误地将之前的 <code>Watcher</code> 添加到新的依赖中。</li><li><strong>数据变化通知</strong>：<br>当数据发生变化时（例如，通过 <code>this.someData = newValue</code> 修改），<code>Dep</code> 会通知其依赖列表中的所有 <code>Watcher</code>。<code>Watcher</code> 接收到通知后，会执行其回调函数（通常是重新渲染组件）。</li></ol><p><code>defineReactive</code>、<code>observe</code>和<code>observer</code>在Vue的数据响应式原理中扮演着不同的角色。<code>defineReactive</code>负责定义对象的响应属性，<code>observe</code>负责递归地使对象的所有属性都具有响应性，而<code>observer</code>则是一个监听对象变化的机制或组件。它们共同工作，使得当数据发生变化时，视图可以自动更新，实现了数据的双向绑定。</p><p>observe—为新对象创建一个 observer对象</p><p>  observer对象遍历对象&#x2F;数组 </p><p>  依次为里面每一个item加一个dep  </p><p>  observer.walk()里面就是definereactive（）</p><p>这个函数就是dep 和 watcher的操作</p><p>dep 里面 关键点  subs数组存所有的watcher对象  addsub（这个是在watcher那边调用）</p><p>​                               nodify() 遍历subs数组去 执行watcher的一个notice 方法</p><p>​                              depend get数据的时候触发   执行watcher的adddep方法</p><p>watcher里面  关键点</p><h4 id="dep的depend-方法"><a href="#dep的depend-方法" class="headerlink" title="dep的depend 方法"></a>dep的depend 方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">   if (Dep.target) &#123;</span><br><span class="line">     Dep.target.addDep(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="watcher的adddep"><a href="#watcher的adddep" class="headerlink" title="watcher的adddep"></a>watcher的adddep</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1、添加 dep 给自己（watcher） </span><br><span class="line">// 2、添加自己（watcher）到 dep</span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  const id = dep.id</span><br><span class="line">  if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">    this.newDepIds.add(id)</span><br><span class="line">    this.newDeps.push(dep)</span><br><span class="line">    if (!this.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过程大体"><a href="#过程大体" class="headerlink" title="过程大体"></a>过程大体</h4><p><strong>dep 和 watcher 建立联系的过程</strong></p><ul><li><p>执行watcher.get函数 做以下这几件事</p><p>1pushTarget(watcher)：将Dep.target设置为当前watche</p><p> 2 执行watcher.getter，watcher.getter执行期间，只要有读取到属性（已经做过响应式处理的属性），就会建立属性与watcher依赖收集（我们知道此时 的getter函数是通过遍历一个对象来一步步访问path的属性值，每一步都会触发数据的get拦截函数。）</p></li><li><p>依赖收集过程：</p></li><li><ul><li>watcher.getter方法会触发 属性的get函数 会执行dep.depend()</li><li>dep.depend() 会将执行当前Dep.target即watcher的addDep(dep)函数，并传入当前dep</li><li>watcher.addDep：会将dep存入newDeps实例属性上，并调用dep.addSub(watcher)，并传入watcher</li><li>dep.addSub：会将传入的watcher存入当前dep的subs实例属性上，然后dep和watcher就互相建立好联系</li></ul></li><li><p>watcher.getter执行结束后，会调用popTarget，将Dep.target设置为空</p></li></ul><h4 id="与diff时机-流程对比响应式思考"><a href="#与diff时机-流程对比响应式思考" class="headerlink" title="与diff时机 流程对比响应式思考"></a>与diff时机 流程对比响应式思考</h4><p>vue构造函数的时候当数据或者依赖改变的时候  运行一个函数  做两件事情     </p><p><img src="/../../../images/image-20240409140656037.png" alt="image-20240409140656037"></p><h4 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h4><p>在Vue.js的响应式系统中，<code>Observer</code>和<code>Watcher</code>之间的依赖收集过程是紧密相关的，但它们的执行顺序和职责有所不同。</p><p>首先，<code>Observer</code>类的主要职责是将一个对象转换为响应式的，即遍历对象的每个属性，并使用<code>defineReactive</code>函数将每个属性转换为getter&#x2F;setter的形式，同时为每个属性创建一个<code>Dep</code>实例来管理依赖。</p><p><strong>当组件实例化或渲染时，Vue.js会创建<code>Watcher</code>实例来观察数据的变化。<code>Watcher</code>在创建时会执行其<code>getter</code>函数，这通常是组件的渲染函数或计算属性的函数。</strong></p><p>在执行<code>watcher.getter</code>期间，当getter函数读取到已经做过响应式处理的属性时，会触发属性的getter方法。在getter方法中，如果该属性对应的<code>Dep</code>实例中没有这个<code>Watcher</code>的记录，那么就会将这个<code>Watcher</code>添加到该属性的<code>Dep</code>实例中，从而建立起属性与<code>Watcher</code>之间的依赖关系。</p><p>所以，简单来说，<strong>Observer在前，Watcher在后</strong>。先是通过Observer将对象转换为响应式的，并初始化每个属性的Dep实例。然后，当Watcher执行其getter函数时，会读取属性并触发依赖收集过程，将Watcher添加到属性的Dep实例中。</p><p>这个过程确保了当属性的值发生变化时，能够通知到所有依赖这个属性的Watcher，从而触发相应的更新操作，如重新渲染组件或重新计算属性等。</p><h3 id="watcher分类"><a href="#watcher分类" class="headerlink" title="watcher分类"></a>watcher分类</h3><p>在Vue中存在三种Watcher：</p><ul><li>负责视图变化的渲染Watcher</li><li>负责执行计算属性更新的的computed Watcher</li><li>用户通过watcher api自定义的user Watcher</li></ul><p>vue2中对属性进行遍历 让每一个对象变成响应式  是在creat之前完成得到的</p><p>vue3 中对对象进行代理  不用一开始就对对象的每一个属性变成响应式  只需要创建代理  这里相比vue2 就是如果有深入的递归对象   vue3就在之前会省去很多工作</p><p><img src="/../../../images/image-20240409160029495.png" alt="image-20240409160029495"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;6-vue数据双向绑定的原理是什么？&quot;&gt;&lt;a href=&quot;#6-vue数据双向绑定的原理是什么？&quot; class=&quot;headerlink&quot; title=&quot;6.vue数据双向绑定的原理是什么？&quot;&gt;&lt;/a&gt;6.vue数据双向绑定的原理是什么？&lt;/h2&gt;&lt;p&gt;&lt;img s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue插件</title>
    <link href="https://yuanmingjian.github.io/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E6%8F%92%E4%BB%B6/"/>
    <id>https://yuanmingjian.github.io/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E6%8F%92%E4%BB%B6/</id>
    <published>2024-04-08T13:05:17.799Z</published>
    <updated>2024-04-08T13:07:14.324Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果插件是一个对象，必须提供 install 方法。</span><br><span class="line">如果插件是一个函数，它会被作为 install 方法。</span><br><span class="line">install 方法调用时，会将 Vue 作为参数传入。</span><br><span class="line"></span><br><span class="line">该方法需要在调用 new Vue() 之前被调用。</span><br><span class="line"></span><br><span class="line">当 install 方法被同一个插件多次调用，插件将只会被安装一次。</span><br></pre></td></tr></table></figure><p><img src="/../../../images/640-17125815901893.webp" alt="图片"></p><ul><li>创建一个插件(组件)</li><li>给该插件添加一个<strong>install</strong>方法，install方法里编写相关的注册逻辑，比如：把该插件注册为全局组件，这样就可以在整个项目中使用了。</li><li>在实例化Vue前，使用Vue.use(插件) 注册你的插件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vuex pinia</title>
    <link href="https://yuanmingjian.github.io/2024/04/08/vue/vuex%E5%92%8Cpinina/"/>
    <id>https://yuanmingjian.github.io/2024/04/08/vue/vuex%E5%92%8Cpinina/</id>
    <published>2024-04-08T08:05:28.230Z</published>
    <updated>2024-04-08T13:28:17.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pinia-的优点："><a href="#Pinia-的优点：" class="headerlink" title="Pinia 的优点："></a>Pinia 的优点：</h3><ol><li>更加轻量级：相比 Vuex，Pinia 更加轻量级，因为它不需要使用 Vuex 的一些复杂的概念，如模块和 getter。</li><li>更加简单易用：Pinia 的 API 设计更加简单易用，因为它使用了 Vue.js 3 的新特性，如 Composition API。</li><li>更加灵活：Pinia 提供了更加灵活的状态管理方式，因为它支持多个 store 实例，而 Vuex 只支持一个 store 实例。</li></ol><h3 id="Vuex-的优点"><a href="#Vuex-的优点" class="headerlink" title="Vuex 的优点"></a>Vuex 的优点</h3><ol><li>更加成熟：Vuex 是一个比较成熟的状态管理库，它已经被广泛使用和测试。</li><li>更加稳定：Vuex 的稳定性也比 Pinia 更高，因为它已经经过了多个版本的迭代和改进。</li><li>更加强大：Vuex 提供了一些高级功能，如中间件和插件，使得它可以处理更加复杂的状态管理需求。</li></ol><p>Pinia采用了类似于React Hooks的方式来管理状态，这使得它更加直观和易于使用。Vuex则采用了一种基于mutations和actions的方式来管理状态，这可能需要更多的代码来实现相同的功能</p><h4 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h4><p><a href="https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1">https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1</a></p><p>Vuex本质是一个对象</p><p>Vuex对象有两个属性，一个是install方法，一个是Store这个类</p><p>install方法的作用是将store这个实例挂载到所有的组件上，注意是同一个store实例。</p><p>Store这个类拥有commit，dispatch这些方法，Store类里将用户传入的state包装成data，作为new Vue的参数，从而实现了state 值的响应式。</p><h2 id="六、实现Vuex的state"><a href="#六、实现Vuex的state" class="headerlink" title="六、实现Vuex的state"></a>六、实现Vuex的state</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码    &lt;p&gt;&#123;&#123;this.<span class="variable">$store</span>.state.num&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>我们都知道，可以通过这个 语句获得 state的值 但是我们在Store类里还没实现，显然，现在就这样取得话肯定报错。</p><p>前面讲过，我们是这样使用Store的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说，我们把这个对象</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css复制代码&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当作参数了。</p><p>那我们可以直接在Class Store里，获取这个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = options.<span class="property">state</span> || &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这样是不是可以直接使用了呢？</p><p>试一下呗！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">//App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    123</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;this.$store.state.num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../../images/format,png.png" alt="img"></p><p>太赞了吧，怎么会这么简单。。。不敢相信。</p><p>哦不，当然没有这么简单，我们忽略了一点，state里的值也是响应式的哦，我们这样可没有实现响应式。</p><blockquote><p>曾经面试官问我Vuex和全局变量比有什么区别。这一点就是注意区别吧</p></blockquote><p>那要怎么实现响应式呢？ 我们知道，我们new Vue（）的时候，传入的data是响应式的，那我们是不是可以new 一个Vue，然后把state当作data传入呢？ 没有错，就是这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是实现响应式了，但是我们怎么获得state呢？好像只能通过<code>this.$store.vm.state</code>了？但是跟我们平时用的时候不一样，所以，是需要转化下的。</p><p>我们可以给Store类添加一个state属性。这个属性自动触发get接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增代码</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">state</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ES6，的语法，有点类似于Object.defineProperty的get接口</p><p><img src="/../../images/format,png-17125828824606.png" alt="img"> 成功实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Pinia-的优点：&quot;&gt;&lt;a href=&quot;#Pinia-的优点：&quot; class=&quot;headerlink&quot; title=&quot;Pinia 的优点：&quot;&gt;&lt;/a&gt;Pinia 的优点：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;更加轻量级：相比 Vuex，Pinia 更加轻量级，因为它不需要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://yuanmingjian.github.io/2024/04/08/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://yuanmingjian.github.io/2024/04/08/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2024-04-08T05:11:15.698Z</published>
    <updated>2024-04-08T05:32:49.909Z</updated>
    
    <content type="html"><![CDATA[<p>c 消除二义性</p><p>箭头函数 —》指令序列  和 对象没关系   不能new  也没有原型</p><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p>3.51 <a href="mailto:&#88;&#64;&#x4d;&#x2e;&#87;&#109;">&#88;&#64;&#x4d;&#x2e;&#87;&#109;</a> 06&#x2F;20 ica:&#x2F; 箭头函数的意义 # JavaScript # 前端开发工程师 # 编程 # 程序员 # web前端  <a href="https://v.douyin.com/iYBp6x4f/">https://v.douyin.com/iYBp6x4f/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p><h4 id="与普通函数区别"><a href="#与普通函数区别" class="headerlink" title="与普通函数区别"></a>与普通函数区别</h4><p>1 箭头函数 不能new</p><p>2 没有argument对象</p><p>3 没有this  没有原型 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;c 消除二义性&lt;/p&gt;
&lt;p&gt;箭头函数 —》指令序列  和 对象没关系   不能new  也没有原型&lt;/p&gt;
&lt;h5 id=&quot;视频&quot;&gt;&lt;a href=&quot;#视频&quot; class=&quot;headerlink&quot; title=&quot;视频&quot;&gt;&lt;/a&gt;视频&lt;/h5&gt;&lt;p&gt;3.51 &lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Suspense</title>
    <link href="https://yuanmingjian.github.io/2024/04/07/vue/Suspense/"/>
    <id>https://yuanmingjian.github.io/2024/04/07/vue/Suspense/</id>
    <published>2024-04-07T05:17:17.609Z</published>
    <updated>2024-04-07T05:16:32.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../images/image-20240121162043161.png" alt="image-20240121162043161"></p><p>在 Vue 3 中，结合 Vue Router 使用 <code>Suspense</code> 可以帮助你更好地管理路由级别的加载状态。Vue Router 允许你定义路由时指定异步组件，而 <code>Suspense</code> 则可以在这些异步组件加载期间提供备用的内容或加载指示器。</p><p>以下是一个示例，展示了如何结合 Vue Router 和 <code>Suspense</code> 来管理路由级别的加载状态：</p><p>首先，确保你已经安装了 Vue Router 并设置了基本的路由配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js  </span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AsyncComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> routes = [  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/async&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>) &#125;,  </span><br><span class="line">];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;  </span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(process.<span class="property">env</span>.<span class="property">BASE_URL</span>),  </span><br><span class="line">  routes,  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>/async</code> 路由对应一个异步加载的组件 <code>AsyncComponent</code>。现在，我们可以在 App 组件中使用 <code>Suspense</code> 来处理这个路由的加载状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;  </span><br><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;  </span><br><span class="line">    &lt;Suspense&gt;  </span><br><span class="line">      &lt;template #default&gt;  </span><br><span class="line">        &lt;component :is=&quot;Component&quot; /&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #fallback&gt;  </span><br><span class="line">        &lt;div&gt;Loading...&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #error&gt;  </span><br><span class="line">        &lt;div&gt;An error occurred while loading the component.&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">    &lt;/Suspense&gt;  </span><br><span class="line">  &lt;/router-view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">import &#123; Suspense &#125; from &#x27;vue&#x27;;  </span><br><span class="line">import router from &#x27;./router&#x27;;  </span><br><span class="line">  </span><br><span class="line">export default &#123;  </span><br><span class="line">  components: &#123;  </span><br><span class="line">    Suspense,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  setup() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      // 你可以在这里添加其他的响应式状态或方法  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了 <code>router-view</code> 组件的插槽功能来包裹 <code>Suspense</code>。这样，每当路由改变时，<code>Component</code> 变量就会更新为当前路由对应的组件。<code>Suspense</code> 会根据这个组件是同步加载还是异步加载来显示不同的内容。</p><p>当访问 <code>/async</code> 路由时，由于 <code>AsyncComponent</code> 是异步加载的，<code>Suspense</code> 会显示 <code>fallback</code> 插槽的内容（即 “Loading…” 文本）。一旦 <code>AsyncComponent</code> 加载完成，<code>Suspense</code> 就会切换到 <code>default</code> 插槽的内容，即显示该组件。</p><p>如果在加载 <code>AsyncComponent</code> 的过程中发生错误，<code>Suspense</code> 将会显示 <code>error</code> 插槽的内容，提示用户发生了错误。</p><p>通过结合 Vue Router 和 <code>Suspense</code>，你可以实现更精细的路由级别加载状态管理，为用户提供更好的体验。这尤其适用于大型应用程序，其中许多组件可能是按需异步加载的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../images/image-20240121162043161.png&quot; alt=&quot;image-20240121162043161&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 Vue 3 中，结合 Vue Router 使用 &lt;code&gt;Suspense&lt;/cod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单点登陆下-无感刷新</title>
    <link href="https://yuanmingjian.github.io/2024/03/25/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"/>
    <id>https://yuanmingjian.github.io/2024/03/25/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/</id>
    <published>2024-03-25T05:45:58.179Z</published>
    <updated>2024-04-09T08:19:42.981Z</updated>
    
    <content type="html"><![CDATA[<p>使用WebSocket加心跳检测实现token无感刷新与传统的客户端存在两个token（例如访问token和刷新token）来实现无感刷新的方式相比，各有其优劣。以下是它们之间的主要差异：</p><p><strong>使用WebSocket加心跳检测的优势：</strong></p><ol><li><strong>实时性</strong>：WebSocket提供了全双工的通信通道，使得服务器和客户端可以实时交换数据。这使得token的刷新过程更加及时，减少了因token过期导致的请求失败的可能性。</li><li><strong>减少请求次数</strong>：通过心跳检测，服务器可以在token过期前主动发送新的token给客户端，避免了客户端因token过期而需要重新请求token的情况，从而减少了不必要的网络请求。</li><li><strong>用户体验更好</strong>：由于token的刷新过程对用户来说是透明的，用户无需感知到任何操作或等待时间，从而提升了用户体验。</li></ol><p><strong>使用WebSocket加心跳检测的劣势：</strong></p><ol><li><strong>依赖稳定的网络连接</strong>：WebSocket需要稳定的网络连接才能保持通信。在网络不稳定或断开的情况下，可能会导致心跳检测失败或token刷新不及时。</li><li><strong>实现复杂度较高</strong>：WebSocket和心跳检测的实现相比传统的token刷新方式更为复杂，需要前端和后端都进行相应的开发和配置。</li></ol><p><strong>使用两个token（访问token和刷新token）的优势：</strong></p><ol><li><strong>更好的安全性</strong>：通过将访问token和刷新token分离，可以减少安全风险。即使访问token被泄露，攻击者也无法直接获取到刷新token，从而无法持续获取新的访问token。</li><li><strong>更好的灵活性</strong>：刷新token通常具有更长的有效期，这使得客户端在访问token过期后仍然有机会使用刷新token来获取新的访问token，而无需用户重新登录。</li></ol><p><strong>使用两个token的劣势：</strong></p><ol><li><strong>额外的存储和管理开销</strong>：客户端需要同时存储和管理访问token和刷新token，这增加了存储和管理的复杂度。</li><li><strong>可能的延迟</strong>：当访问token过期时，客户端需要发送请求使用刷新token来获取新的访问token，这可能会导致一定的延迟，影响用户体验。</li></ol><p>综上所述，两种方式各有其优劣。在选择时，需要根据具体的应用场景和需求进行权衡。例如，对于实时性要求较高且网络条件稳定的应用，使用WebSocket加心跳检测可能更为合适；而对于安全性要求较高或对网络延迟较敏感的应用，使用两个token的方式可能更为合适。</p><h1 id="浏览器端心跳检测的必要性"><a href="#浏览器端心跳检测的必要性" class="headerlink" title="浏览器端心跳检测的必要性"></a>浏览器端心跳检测的必要性</h1><p>首先我们先了解一下，目前的浏览器端的WebSocket何时会自动关闭WebSocket，并触发close事件呢？</p><ul><li>握手时的WebSocket地址不可用。</li><li>其它未知错误。</li><li>正常连接状态下，接收到服务器端的关闭帧就会触发关闭回调。</li></ul><p>也就是说建立正常连接后，中途浏览器端断网了，或者服务器没有发送关闭帧就关了连接，总之就是在连接无法再使用的情况下，浏览器没有接收到关闭帧，浏览器则会长时间保持连接状态。此时业务代码不去主动探测的话，是无法感知的。</p><p>另外通讯双方保持连接意味着需要长时间占用对方的资源。对于服务器端来说资源是非常宝贵的。长时间不活跃的连接，可能会被服务器应用层框架”优化”释放掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用WebSocket加心跳检测实现token无感刷新与传统的客户端存在两个token（例如访问token和刷新token）来实现无感刷新的方式相比，各有其优劣。以下是它们之间的主要差异：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用WebSocket加心跳检测的优势：&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
</feed>
