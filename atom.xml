<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端学习笔记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-08T09:15:04.997Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>来一份棉花糖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react的一些钩子</title>
    <link href="http://example.com/2024/10/18/react/useReducer/"/>
    <id>http://example.com/2024/10/18/react/useReducer/</id>
    <published>2024-10-18T08:27:18.199Z</published>
    <updated>2024-11-08T09:15:04.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>上边我们提到过基础的状态管理钩子 useState ，在 React Hook 中额外提供了一个关于状态管理的 useReducer。</p><h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a>useReducer 用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p>useReducer 接受三个参数分别是 reducer 函数、初始值 initialArg 以及一个可选的惰性初始化的 init 函数。</p><p>它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p><p>让我们通过一个简单的计数器例子来了解一下它的基础用法:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAction</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span>;</span><br><span class="line">  <span class="attr">payload</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">IState</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state: IState, action: IAction</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;subtract&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Illegal operation in reducer.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello , My name is 19Qingfeng.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Counter: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;add&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          add 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;subtract&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          subtract 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个简单的 Counter 计数器组件，内部通过 useReducer 管理 couter 的状态。</p><blockquote><p>你可以在<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/elastic-kilby-x3kco">这里</a>来体验这个计数器小例子。</p></blockquote><h3 id="useState-amp-useReducer"><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h3><p>上边的计数器小例子我们其实通过 setState 完全也可以实现，大部分同学在写 component 时应该有存在这样一个疑问:</p><p>「什么时候使用 useState 又什么时候使用 useReducer ，useReducer 相比 useState 存在什么优势&#x2F;不足呢？」</p><p>其实在日常大多数情况下使用 useState 完全可以满足日常开发的作用，毕竟如果对于一个简单的操作如果使用 action -&gt; reducer -&gt; store 这种方式去管理状态实在是有点大材小用。</p><p>关于状态管理究竟是使用 useState 还是 useReducer 绝大多数文章会告诉你 useReducer 适用于复杂的状态逻辑。</p><p>没错，日常应用中我我也是这样使用的，存在多种复杂状态管理时利用 reducer 函数根据不同 action 去派发状态更新。</p><p>但是话又说回来如果某个 state 下存在很多操作状态，每个操作都有很多逻辑，对于这样复杂的状态，使用 useState 拥有单独的功能管理相比 reducer 中单个函数中的多个不同动作也许会更加清晰一些。</p><p>关于「什么时候使用 useState 又什么时候使用 useReducer」，在我个人看来这两种方式的使用更像是一种取舍<strong>总而言之尽量使用你觉得舒服的方法，对你和同事来说更容易理解就可以了。</strong></p><h3 id="深更新的组件做性能优化"><a href="#深更新的组件做性能优化" class="headerlink" title="深更新的组件做性能优化"></a>深更新的组件做性能优化</h3><p>在 useReducer 的官方文档中存在这样一句介绍:</p><blockquote><p>并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数</p></blockquote><p>在某些场景下我们通常会将函数作为 props 传递到 child component 中去，这样的话，每次父组件 re-render 时即使我们并没有修改当作 props 的函数，子组件也会重新渲染。</p><p>我们来一起看一下这个例子:  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Hello This is Parent Component!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ParentCount: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ParentComponent</span>;</span><br><span class="line">ts 代码解读复制代码<span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="variable constant_">FC</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  callback?: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">&#123; callback &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;child re-render&#x27;</span>);</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello This is Child Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;callback &amp;&amp; callback()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure><p>这里我们在父组件中传递给子组件一个 callback 函数作为 props ，当我们点击页面上的按钮来看看会发生什么:</p><p><img src="/../../images/c88d9f17814249c692014fcf0e34142etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.gif" alt="QQ20211219-144858-HD.gif"></p><p>每次点击父组件的 button 时，子组件中的 effect 中被执行了。</p><p>此时其实我们传入子组件的 callback 并没有做什么改变，我们自然期望子组件中的 Effect 不会执行。</p><blockquote><p>产生这个原因的机制是 React 每次渲染都会重新执行组件函数，当重新执行父组件时会重新生成一个 callback 函数。因为 React 内部使用 Object.is 判断，所以 React 会认为子组件的 props 发生了变化。</p></blockquote><blockquote><p>你可以点击这里查看<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/blue-wave-r5qs5"> CodeSanBox 例子</a></p></blockquote><p><strong>而在 useReduce 中返回的 dispatch 正是一个函数，但是 useReducer 的好处之一便是， dispatch 不会随着 re-render 而重新分配记忆位置，比方上述我们将 dispatch 作为 props 传入 child component 中时子组件中的 Effect 也并不会被执行。</strong></p><p>有兴趣的同学可以私下自己去尝试下，当然使用 useCallback 包括我们上述 Demo 中父组件的函数也是可以达到相同的效果，但是如此也就意味着說我们有非常多的 callback 需要绑在 useCallback 里边，这也许并不是一件好事</p><p>作者：19组清风<br>链接：<a href="https://juejin.cn/post/7043772161596588046">https://juejin.cn/post/7043772161596588046</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;上边我们提到过基础的状态管理钩子 useState ，在 React Hoo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>react的一些小记</title>
    <link href="http://example.com/2024/10/11/react/react%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2024/10/11/react/react%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</id>
    <published>2024-10-11T09:56:31.020Z</published>
    <updated>2024-11-08T09:16:15.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="副作用的理解"><a href="#副作用的理解" class="headerlink" title="副作用的理解"></a>副作用的理解</h3><p> <img src="/../../images/image-20241011175717835.png" alt="image-20241011175717835"></p><p><img src="/../../images/image-20241011180049973.png" alt="image-20241011180049973"></p><p>由渲染本身引起的对接组件外部的操作  —— 副作用 如 发送网络请求、定时器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;副作用的理解&quot;&gt;&lt;a href=&quot;#副作用的理解&quot; class=&quot;headerlink&quot; title=&quot;副作用的理解&quot;&gt;&lt;/a&gt;副作用的理解&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;/../../images/image-20241011175717835.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一行代码响应式</title>
    <link href="http://example.com/2024/09/25/css/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <id>http://example.com/2024/09/25/css/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%93%8D%E5%BA%94%E5%BC%8F/</id>
    <published>2024-09-25T02:58:32.507Z</published>
    <updated>2024-09-27T07:52:36.611Z</updated>
    
    <content type="html"><![CDATA[<p>columo count</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;columo count&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/09/25/Untitled/"/>
    <id>http://example.com/2024/09/25/Untitled/</id>
    <published>2024-09-25T02:58:25.176Z</published>
    <updated>2024-09-25T02:58:25.176Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/07/14/07-12/"/>
    <id>http://example.com/2024/07/14/07-12/</id>
    <published>2024-07-14T14:07:25.103Z</published>
    <updated>2024-07-14T15:15:15.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><p>1 梳理邻里圈的逻辑</p><p>2 学习webpack构建工具 去了解各种构建工具的分类、对比</p><p>3 浏览优选事业部构建工具的优化过程，一步步如何优化编译构建速度，打包体积大小等 整个过程的方案设计和思想值得我慢慢品味学习</p><p>4 刷ts练习题</p><h2 id="遇到问题及解决"><a href="#遇到问题及解决" class="headerlink" title="遇到问题及解决"></a>遇到问题及解决</h2><p>1 阅读优选构建工具的优化过程时，对于一些专业性名词和概念不清晰，对一些优化方案随曾经有过耳闻但却从未实践过，导致一些内容看起来较为困难</p><h2 id="明日安排"><a href="#明日安排" class="headerlink" title="明日安排"></a>明日安排</h2><p>1 继续刷ts练习题 熟悉ts语法</p><p>2 学习微信小程序性能优化方式</p><h2 id="感悟总结"><a href="#感悟总结" class="headerlink" title="感悟总结"></a>感悟总结</h2><p>对于构建工程化这一块是我后续要慢慢去了解学习的，目前市面上各种新鲜框架，组件库层出不穷，是不可能学得完的， 但在工程化这一块，其思想却是可以受益终生，从分析问题到调研到给出解决方案到实践落地，每一步都是一名合格的前端程序员需要去掌握的，而这些需要不断积累经验不断学习，多多接触一个项目的底层搭建过程，总结其一步步的优化过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h2&gt;&lt;p&gt;1 梳理邻里圈的逻辑&lt;/p&gt;
&lt;p&gt;2 学习webpack构建工具 去了解各种构建工具的分类、对比&lt;/p&gt;
&lt;p&gt;3 浏览优</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/05/17/%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2024/05/17/%E6%96%87%E7%AB%A0/</id>
    <published>2024-05-17T11:26:41.539Z</published>
    <updated>2024-05-30T12:54:56.673Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-微信公众号文章"><a href="#title-微信公众号文章" class="headerlink" title="title :微信公众号文章"></a>title :微信公众号文章</h2><p><a href="https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg">https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg</a> 在Vue中动态引入图片，为什么要用require</p><p><a href="https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw">https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw</a>  JS 分片任务的高阶函数封装</p><p><a href="https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw">https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw</a>  2024 Vue 联邦大会，全明星阵容！探讨 Vue 的未来和问题</p><p><a href="https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg">https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg</a> CSS3实现无缝滚动scroll，实用&#x3D;很丝滑+很漂亮+源码</p><p><a href="https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw">https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw</a> 美化你的Github，变身专业大佬</p><p> <a href="https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ">https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ</a>  前端如何防止接口重复提交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-微信公众号文章&quot;&gt;&lt;a href=&quot;#title-微信公众号文章&quot; class=&quot;headerlink&quot; title=&quot;title :微信公众号文章&quot;&gt;&lt;/a&gt;title :微信公众号文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue组件和vuex数据绑定</title>
    <link href="http://example.com/2024/05/09/bug/vue%E7%BB%84%E4%BB%B6%E5%92%8Cvuex%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://example.com/2024/05/09/bug/vue%E7%BB%84%E4%BB%B6%E5%92%8Cvuex%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</id>
    <published>2024-05-09T09:27:57.107Z</published>
    <updated>2024-05-09T09:32:05.770Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用computed作为桥梁"><a href="#用computed作为桥梁" class="headerlink" title="用computed作为桥梁"></a>用computed作为桥梁</h3><h5 id="之前放在data里面"><a href="#之前放在data里面" class="headerlink" title="之前放在data里面"></a>之前放在data里面</h5><p><img src="/../../images/image-20240509172934274.png" alt="image-20240509172934274"></p><p>问题： 通过其他方式改变vuex里面这个state的数据后 该组件不会响应</p><p>原因：</p><ol><li><strong>Vue的响应式系统是基于getter和setter的</strong>：当Vue实例被创建时，它会遍历<code>data</code>对象中的所有属性，并使用<code>Object.defineProperty</code>将它们转化为getter&#x2F;setter，从而使这些属性变得“响应式”。<strong>但是，当你之后直接将Vuex的<code>state</code>中的数据赋值给<code>data</code>属性时，这些属性已经不再是Vue在初始化时定义的那些了，因此它们没有getter&#x2F;setter，也就不会触发视图更新。</strong></li></ol><p>解决方法</p><p><img src="/../../images/image-20240509173132692.png" alt="image-20240509173132692"></p><p>把变量来放在computed里面</p><p>在Vue中，<code>computed</code>属性是基于它们的依赖进行缓存的。只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>computed</code>属性依赖的数据发生变化，它就会触发重新计算，并且如果计算的结果与之前的值不同，那么它还会触发视图更新。</p><p>Vuex的<code>state</code>是存储应用程序状态（也就是数据和状态信息）的地方。Vuex的状态管理模式是集中式的，也就是说我们有一个“单一状态树”，它包含了所有的应用状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用computed作为桥梁&quot;&gt;&lt;a href=&quot;#用computed作为桥梁&quot; class=&quot;headerlink&quot; title=&quot;用computed作为桥梁&quot;&gt;&lt;/a&gt;用computed作为桥梁&lt;/h3&gt;&lt;h5 id=&quot;之前放在data里面&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>axios请求拦截</title>
    <link href="http://example.com/2024/04/11/axios%E6%8B%A6%E6%88%AA/"/>
    <id>http://example.com/2024/04/11/axios%E6%8B%A6%E6%88%AA/</id>
    <published>2024-04-11T08:35:57.424Z</published>
    <updated>2024-04-11T08:36:26.514Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/image-20240411163605097.png" alt="image-20240411163605097"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/image-20240411163605097.png&quot; alt=&quot;image-20240411163605097&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pnpm	与 npm</title>
    <link href="http://example.com/2024/04/10/pnpm/"/>
    <id>http://example.com/2024/04/10/pnpm/</id>
    <published>2024-04-10T13:44:11.869Z</published>
    <updated>2024-04-10T13:58:27.949Z</updated>
    
    <content type="html"><![CDATA[<p> 为什么浏览器可以访问nodemodules下的资源文件  因为vite或者webpack帮我们在一个端口假如是5173启动了一台静态服务器</p><p>文件访问能力是nodejs提供的 npm依旧是nodejs环境的 </p><h4 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h4><p>1利用操作系统的软连接技术提升性能</p><p>   a下载安装快</p><p>   b 节省磁盘空间</p><p>2 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 为什么浏览器可以访问nodemodules下的资源文件  因为vite或者webpack帮我们在一个端口假如是5173启动了一台静态服务器&lt;/p&gt;
&lt;p&gt;文件访问能力是nodejs提供的 npm依旧是nodejs环境的 &lt;/p&gt;
&lt;h4 id=&quot;pnpm&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/04/09/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://example.com/2024/04/09/%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2024-04-09T09:59:06.721Z</published>
    <updated>2024-04-09T10:04:08.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="setTimeout-与-setlnvertal-的区别"><a href="#setTimeout-与-setlnvertal-的区别" class="headerlink" title="setTimeout 与 setlnvertal 的区别"></a>setTimeout 与 setlnvertal 的区别</h3><ul><li><p>setTimeout 是递归循环，它基本上可以保证代码的执行顺序，每次的至少延迟时长大于等于设置的时间。</p></li><li><p>setlnvertal 每次定时触发执行回调函数，它的执行时间间隔可能会比期待的要小，而且不关心前一个回调函数是否执行，不会重复注册回调。</p><p> 定时放setinvertal进去 不管是否执行完 当执行时间大于间隔 会出现定时器代码间隔会比预期要小</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;setTimeout-与-setlnvertal-的区别&quot;&gt;&lt;a href=&quot;#setTimeout-与-setlnvertal-的区别&quot; class=&quot;headerlink&quot; title=&quot;setTimeout 与 setlnvertal 的区别&quot;&gt;&lt;/a&gt;se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理总结</title>
    <link href="http://example.com/2024/04/09/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/04/09/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-09T07:21:10.334Z</published>
    <updated>2024-11-04T13:19:48.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-vue数据双向绑定的原理是什么？"><a href="#6-vue数据双向绑定的原理是什么？" class="headerlink" title="6.vue数据双向绑定的原理是什么？"></a>6.vue数据双向绑定的原理是什么？</h2><p><img src="/../../../images/image-20240125145019146.png" alt="image-20240125145019146"></p><h5 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h5><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给 订阅者，触发相应的监听回调。 </p><p>第一步:需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter<br>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据 变化 </p><p>第二步:compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图<br>第三步:Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情 是: </p><p>1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 </p><p>3、<strong>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</strong><br>第四步:MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher </p><p><strong>三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>Vue 的数据双向绑定是通过 Object.defineProperty() 方法实现的。在 Vue 中，每个组件实例都有一个对应的 Watcher 实例，Watcher 实例负责监听组件实例对象中所有用到的数据变化。</p><p>当数据发生变化时，Watcher 会通知订阅它的视图进行更新，从而实现了数据的响应式渲染。</p><p>具体来说，Vue 通过 Object.defineProperty() 方法实现了数据代理和数据劫持：</p><ul><li>数据代理：通过 Object.defineProperty() 方法将组件实例对象中的 data 对象中的属性代理到组件实例对象本身中，这样就可以通过 <a href="http://this.xxx/">this.xxx</a> 的方式直接访问 data 中的属性。</li><li>数据劫持：在代理过程中，由于使用了 Object.defineProperty() 方法，因此可以在读取或设置 data 属性值时，触发相应的 getter 和 setter 方法。在 getter 和 setter 方法中，通过收集 Watcher 实例的依赖关系，实现了数据发生变化时视图的响应式更新。</li></ul><p>总的来说，Vue 的数据双向绑定原理就是通过数据代理和数据劫持，以及 Watcher 实例的依赖收集和更新机制，实现了组件实例对象和视图之间的动态响应式绑定。这种机制避免了手动操作 DOM 元素的繁琐工作，提高了代码的可维护性和复用性。</p><p><img src="/../../../images/image-20240125144710461.png" alt="image-20240125144710461"></p><p><img src="/../../../images/image-20240125144948370.png" alt="image-20240125144948370"></p><h3 id="Dep补充"><a href="#Dep补充" class="headerlink" title="Dep补充"></a>Dep补充</h3><p><img src="/../../../images/image-20240125151254002.png" alt="image-20240125151254002"></p><h3 id="watcher补充"><a href="#watcher补充" class="headerlink" title="watcher补充"></a>watcher补充</h3><p><img src="/../../../images/image-20240202101644551.png" alt="image-20240202101644551"></p><p><img src="/../../../images/image-20240125153018052.png" alt="image-20240125153018052"></p><p><img src="/../../../images/image-20240125153538474.png" alt="image-20240125153538474"></p><p>在 Vue 中，<code>Dep</code>（依赖）和 <code>Watcher</code>（观察者）是实现响应式系统的重要组件。<code>Dep</code> 用来收集依赖（即 <code>Watcher</code>），当数据发生变化时，会通知所有依赖进行更新。<code>Watcher</code> 则用来观察数据的变化，当数据发生变化时，执行相应的回调函数。</p><p><code>Dep.target</code> 是一个全局变量，用来在收集依赖的过程中，将当前的 <code>Watcher</code> 与 <code>Dep</code> 进行绑定。</p><p>以下是 <code>Dep</code> 和 <code>Watcher</code> 如何互相绑定的简要过程：</p><ol><li><strong>初始化 Watcher</strong>：<br>当 Vue 组件需要观察某个数据时（例如，在模板中使用了数据属性），Vue 会为这个数据创建一个 <code>Watcher</code>。在创建 <code>Watcher</code> 的过程中，Vue 会将 <code>Dep.target</code> 设置为当前的 <code>Watcher</code>。</li><li><strong>访问数据</strong>：<br>当组件渲染或重新渲染时，会访问数据。如果数据是响应式的（即被 <code>Vue.observable</code> 或 <code>new Vue(&#123; data: ... &#125;)</code> 包裹过），那么这个数据会有一个与之关联的 <code>Dep</code> 实例。</li><li><strong>收集依赖</strong>：<br>在访问数据的过程中，<code>Dep</code> 会检查 <code>Dep.target</code> 是否存在。如果存在（即当前有 <code>Watcher</code> 正在观察数据），那么 <code>Dep</code> 会将 <code>Dep.target</code>（即当前的 <code>Watcher</code>）添加到其依赖列表中。</li><li><strong>重置 Dep.target</strong>：<br>收集完依赖后，Vue 会将 <code>Dep.target</code> 重置为 <code>null</code>，以确保下一个 <code>Watcher</code> 创建时不会错误地将之前的 <code>Watcher</code> 添加到新的依赖中。</li><li><strong>数据变化通知</strong>：<br>当数据发生变化时（例如，通过 <code>this.someData = newValue</code> 修改），<code>Dep</code> 会通知其依赖列表中的所有 <code>Watcher</code>。<code>Watcher</code> 接收到通知后，会执行其回调函数（通常是重新渲染组件）。</li></ol><p><code>defineReactive</code>、<code>observe</code>和<code>observer</code>在Vue的数据响应式原理中扮演着不同的角色。<code>defineReactive</code>负责定义对象的响应属性，<code>observe</code>负责递归地使对象的所有属性都具有响应性，而<code>observer</code>则是一个监听对象变化的机制或组件。它们共同工作，使得当数据发生变化时，视图可以自动更新，实现了数据的双向绑定。</p><p>observe—为新对象创建一个 observer对象</p><p>  observer对象遍历对象&#x2F;数组 </p><p>  依次为里面每一个item加一个dep  </p><p>  observer.walk()里面就是definereactive（）</p><p>这个函数就是dep 和 watcher的操作</p><p>dep 里面 关键点  subs数组存所有的watcher对象  addsub（这个是在watcher那边调用）</p><p>​                               nodify() 遍历subs数组去 执行watcher的一个notice 方法</p><p>​                              depend get数据的时候触发   执行watcher的adddep方法</p><p>watcher里面  关键点</p><h4 id="dep的depend-方法"><a href="#dep的depend-方法" class="headerlink" title="dep的depend 方法"></a>dep的depend 方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">   if (Dep.target) &#123;</span><br><span class="line">     Dep.target.addDep(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="watcher的adddep"><a href="#watcher的adddep" class="headerlink" title="watcher的adddep"></a>watcher的adddep</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1、添加 dep 给自己（watcher） </span><br><span class="line">// 2、添加自己（watcher）到 dep</span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  const id = dep.id</span><br><span class="line">  if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">    this.newDepIds.add(id)</span><br><span class="line">    this.newDeps.push(dep)</span><br><span class="line">    if (!this.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过程大体"><a href="#过程大体" class="headerlink" title="过程大体"></a>过程大体</h4><p><strong>dep 和 watcher 建立联系的过程</strong></p><ul><li><p>执行watcher.get函数 做以下这几件事</p><p>1pushTarget(watcher)：将Dep.target设置为当前watche</p><p> 2 执行watcher.getter，watcher.getter执行期间，只要有读取到属性（已经做过响应式处理的属性），就会建立属性与watcher依赖收集（我们知道此时 的getter函数是通过遍历一个对象来一步步访问path的属性值，每一步都会触发数据的get拦截函数。）</p></li><li><p>依赖收集过程：</p></li><li><ul><li>watcher.getter方法会触发 属性的get函数 会执行dep.depend()</li><li>dep.depend() 会将执行当前Dep.target即watcher的addDep(dep)函数，并传入当前dep</li><li>watcher.addDep：会将dep存入newDeps实例属性上，并调用dep.addSub(watcher)，并传入watcher</li><li>dep.addSub：会将传入的watcher存入当前dep的subs实例属性上，然后dep和watcher就互相建立好联系</li></ul></li><li><p>watcher.getter执行结束后，会调用popTarget，将Dep.target设置为空</p></li></ul><h4 id="与diff时机-流程对比响应式思考"><a href="#与diff时机-流程对比响应式思考" class="headerlink" title="与diff时机 流程对比响应式思考"></a>与diff时机 流程对比响应式思考</h4><p>vue构造函数的时候当数据或者依赖改变的时候  运行一个函数  做两件事情     </p><p><img src="/../../../images/image-20240409140656037.png" alt="image-20240409140656037"></p><h4 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h4><p>在Vue.js的响应式系统中，<code>Observer</code>和<code>Watcher</code>之间的依赖收集过程是紧密相关的，但它们的执行顺序和职责有所不同。</p><p>首先，<code>Observer</code>类的主要职责是将一个对象转换为响应式的，即遍历对象的每个属性，并使用<code>defineReactive</code>函数将每个属性转换为getter&#x2F;setter的形式，同时为每个属性创建一个<code>Dep</code>实例来管理依赖。</p><p><strong>当组件实例化或渲染时，Vue.js会创建<code>Watcher</code>实例来观察数据的变化。<code>Watcher</code>在创建时会执行其<code>getter</code>函数，这通常是组件的渲染函数或计算属性的函数。</strong></p><p>在执行<code>watcher.getter</code>期间，当getter函数读取到已经做过响应式处理的属性时，会触发属性的getter方法。在getter方法中，如果该属性对应的<code>Dep</code>实例中没有这个<code>Watcher</code>的记录，那么就会将这个<code>Watcher</code>添加到该属性的<code>Dep</code>实例中，从而建立起属性与<code>Watcher</code>之间的依赖关系。</p><p>所以，简单来说，<strong>Observer在前，Watcher在后</strong>。先是通过Observer将对象转换为响应式的，并初始化每个属性的Dep实例。然后，当Watcher执行其getter函数时，会读取属性并触发依赖收集过程，将Watcher添加到属性的Dep实例中。</p><p>这个过程确保了当属性的值发生变化时，能够通知到所有依赖这个属性的Watcher，从而触发相应的更新操作，如重新渲染组件或重新计算属性等。</p><h3 id="watcher分类"><a href="#watcher分类" class="headerlink" title="watcher分类"></a>watcher分类</h3><p>在Vue中存在三种Watcher：</p><ul><li>负责视图变化的渲染Watcher</li><li>负责执行计算属性更新的的computed Watcher</li><li>用户通过watcher api自定义的user Watcher</li></ul><p>vue2中对属性进行遍历 让每一个对象变成响应式  是在creat之前完成得到的</p><p>vue3 中对对象进行代理  不用一开始就对对象的每一个属性变成响应式  只需要创建代理  这里相比vue2 就是如果有深入的递归对象   vue3就在之前会省去很多工作</p><p><img src="/../../../images/image-20240409160029495.png" alt="image-20240409160029495"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;6-vue数据双向绑定的原理是什么？&quot;&gt;&lt;a href=&quot;#6-vue数据双向绑定的原理是什么？&quot; class=&quot;headerlink&quot; title=&quot;6.vue数据双向绑定的原理是什么？&quot;&gt;&lt;/a&gt;6.vue数据双向绑定的原理是什么？&lt;/h2&gt;&lt;p&gt;&lt;img s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue插件</title>
    <link href="http://example.com/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E6%8F%92%E4%BB%B6/</id>
    <published>2024-04-08T13:05:17.799Z</published>
    <updated>2024-04-08T13:07:14.324Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果插件是一个对象，必须提供 install 方法。</span><br><span class="line">如果插件是一个函数，它会被作为 install 方法。</span><br><span class="line">install 方法调用时，会将 Vue 作为参数传入。</span><br><span class="line"></span><br><span class="line">该方法需要在调用 new Vue() 之前被调用。</span><br><span class="line"></span><br><span class="line">当 install 方法被同一个插件多次调用，插件将只会被安装一次。</span><br></pre></td></tr></table></figure><p><img src="/../../../images/640-17125815901893.webp" alt="图片"></p><ul><li>创建一个插件(组件)</li><li>给该插件添加一个<strong>install</strong>方法，install方法里编写相关的注册逻辑，比如：把该插件注册为全局组件，这样就可以在整个项目中使用了。</li><li>在实例化Vue前，使用Vue.use(插件) 注册你的插件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/Untitled/"/>
    <id>http://example.com/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/Untitled/</id>
    <published>2024-04-08T13:05:11.864Z</published>
    <updated>2024-04-08T13:05:11.864Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>vuex pinia</title>
    <link href="http://example.com/2024/04/08/vue/vuex%E5%92%8Cpinina/"/>
    <id>http://example.com/2024/04/08/vue/vuex%E5%92%8Cpinina/</id>
    <published>2024-04-08T08:05:28.230Z</published>
    <updated>2024-04-08T13:28:17.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pinia-的优点："><a href="#Pinia-的优点：" class="headerlink" title="Pinia 的优点："></a>Pinia 的优点：</h3><ol><li>更加轻量级：相比 Vuex，Pinia 更加轻量级，因为它不需要使用 Vuex 的一些复杂的概念，如模块和 getter。</li><li>更加简单易用：Pinia 的 API 设计更加简单易用，因为它使用了 Vue.js 3 的新特性，如 Composition API。</li><li>更加灵活：Pinia 提供了更加灵活的状态管理方式，因为它支持多个 store 实例，而 Vuex 只支持一个 store 实例。</li></ol><h3 id="Vuex-的优点"><a href="#Vuex-的优点" class="headerlink" title="Vuex 的优点"></a>Vuex 的优点</h3><ol><li>更加成熟：Vuex 是一个比较成熟的状态管理库，它已经被广泛使用和测试。</li><li>更加稳定：Vuex 的稳定性也比 Pinia 更高，因为它已经经过了多个版本的迭代和改进。</li><li>更加强大：Vuex 提供了一些高级功能，如中间件和插件，使得它可以处理更加复杂的状态管理需求。</li></ol><p>Pinia采用了类似于React Hooks的方式来管理状态，这使得它更加直观和易于使用。Vuex则采用了一种基于mutations和actions的方式来管理状态，这可能需要更多的代码来实现相同的功能</p><h4 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h4><p><a href="https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1">https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1</a></p><p>Vuex本质是一个对象</p><p>Vuex对象有两个属性，一个是install方法，一个是Store这个类</p><p>install方法的作用是将store这个实例挂载到所有的组件上，注意是同一个store实例。</p><p>Store这个类拥有commit，dispatch这些方法，Store类里将用户传入的state包装成data，作为new Vue的参数，从而实现了state 值的响应式。</p><h2 id="六、实现Vuex的state"><a href="#六、实现Vuex的state" class="headerlink" title="六、实现Vuex的state"></a>六、实现Vuex的state</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码    &lt;p&gt;&#123;&#123;this.<span class="variable">$store</span>.state.num&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>我们都知道，可以通过这个 语句获得 state的值 但是我们在Store类里还没实现，显然，现在就这样取得话肯定报错。</p><p>前面讲过，我们是这样使用Store的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说，我们把这个对象</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css复制代码&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当作参数了。</p><p>那我们可以直接在Class Store里，获取这个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = options.<span class="property">state</span> || &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这样是不是可以直接使用了呢？</p><p>试一下呗！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">//App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    123</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;this.$store.state.num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../../images/format,png.png" alt="img"></p><p>太赞了吧，怎么会这么简单。。。不敢相信。</p><p>哦不，当然没有这么简单，我们忽略了一点，state里的值也是响应式的哦，我们这样可没有实现响应式。</p><blockquote><p>曾经面试官问我Vuex和全局变量比有什么区别。这一点就是注意区别吧</p></blockquote><p>那要怎么实现响应式呢？ 我们知道，我们new Vue（）的时候，传入的data是响应式的，那我们是不是可以new 一个Vue，然后把state当作data传入呢？ 没有错，就是这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是实现响应式了，但是我们怎么获得state呢？好像只能通过<code>this.$store.vm.state</code>了？但是跟我们平时用的时候不一样，所以，是需要转化下的。</p><p>我们可以给Store类添加一个state属性。这个属性自动触发get接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增代码</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">state</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ES6，的语法，有点类似于Object.defineProperty的get接口</p><p><img src="/../../images/format,png-17125828824606.png" alt="img"> 成功实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Pinia-的优点：&quot;&gt;&lt;a href=&quot;#Pinia-的优点：&quot; class=&quot;headerlink&quot; title=&quot;Pinia 的优点：&quot;&gt;&lt;/a&gt;Pinia 的优点：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;更加轻量级：相比 Vuex，Pinia 更加轻量级，因为它不需要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="http://example.com/2024/04/08/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/04/08/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2024-04-08T05:11:15.698Z</published>
    <updated>2024-04-08T05:32:49.909Z</updated>
    
    <content type="html"><![CDATA[<p>c 消除二义性</p><p>箭头函数 —》指令序列  和 对象没关系   不能new  也没有原型</p><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p>3.51 <a href="mailto:&#88;&#64;&#x4d;&#x2e;&#87;&#109;">&#88;&#64;&#x4d;&#x2e;&#87;&#109;</a> 06&#x2F;20 ica:&#x2F; 箭头函数的意义 # JavaScript # 前端开发工程师 # 编程 # 程序员 # web前端  <a href="https://v.douyin.com/iYBp6x4f/">https://v.douyin.com/iYBp6x4f/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p><h4 id="与普通函数区别"><a href="#与普通函数区别" class="headerlink" title="与普通函数区别"></a>与普通函数区别</h4><p>1 箭头函数 不能new</p><p>2 没有argument对象</p><p>3 没有this  没有原型 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;c 消除二义性&lt;/p&gt;
&lt;p&gt;箭头函数 —》指令序列  和 对象没关系   不能new  也没有原型&lt;/p&gt;
&lt;h5 id=&quot;视频&quot;&gt;&lt;a href=&quot;#视频&quot; class=&quot;headerlink&quot; title=&quot;视频&quot;&gt;&lt;/a&gt;视频&lt;/h5&gt;&lt;p&gt;3.51 &lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Suspense</title>
    <link href="http://example.com/2024/04/07/vue/Suspense/"/>
    <id>http://example.com/2024/04/07/vue/Suspense/</id>
    <published>2024-04-07T05:17:17.609Z</published>
    <updated>2024-04-07T05:16:32.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../images/image-20240121162043161.png" alt="image-20240121162043161"></p><p>在 Vue 3 中，结合 Vue Router 使用 <code>Suspense</code> 可以帮助你更好地管理路由级别的加载状态。Vue Router 允许你定义路由时指定异步组件，而 <code>Suspense</code> 则可以在这些异步组件加载期间提供备用的内容或加载指示器。</p><p>以下是一个示例，展示了如何结合 Vue Router 和 <code>Suspense</code> 来管理路由级别的加载状态：</p><p>首先，确保你已经安装了 Vue Router 并设置了基本的路由配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js  </span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AsyncComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> routes = [  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/async&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>) &#125;,  </span><br><span class="line">];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;  </span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(process.<span class="property">env</span>.<span class="property">BASE_URL</span>),  </span><br><span class="line">  routes,  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>/async</code> 路由对应一个异步加载的组件 <code>AsyncComponent</code>。现在，我们可以在 App 组件中使用 <code>Suspense</code> 来处理这个路由的加载状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;  </span><br><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;  </span><br><span class="line">    &lt;Suspense&gt;  </span><br><span class="line">      &lt;template #default&gt;  </span><br><span class="line">        &lt;component :is=&quot;Component&quot; /&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #fallback&gt;  </span><br><span class="line">        &lt;div&gt;Loading...&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #error&gt;  </span><br><span class="line">        &lt;div&gt;An error occurred while loading the component.&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">    &lt;/Suspense&gt;  </span><br><span class="line">  &lt;/router-view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">import &#123; Suspense &#125; from &#x27;vue&#x27;;  </span><br><span class="line">import router from &#x27;./router&#x27;;  </span><br><span class="line">  </span><br><span class="line">export default &#123;  </span><br><span class="line">  components: &#123;  </span><br><span class="line">    Suspense,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  setup() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      // 你可以在这里添加其他的响应式状态或方法  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了 <code>router-view</code> 组件的插槽功能来包裹 <code>Suspense</code>。这样，每当路由改变时，<code>Component</code> 变量就会更新为当前路由对应的组件。<code>Suspense</code> 会根据这个组件是同步加载还是异步加载来显示不同的内容。</p><p>当访问 <code>/async</code> 路由时，由于 <code>AsyncComponent</code> 是异步加载的，<code>Suspense</code> 会显示 <code>fallback</code> 插槽的内容（即 “Loading…” 文本）。一旦 <code>AsyncComponent</code> 加载完成，<code>Suspense</code> 就会切换到 <code>default</code> 插槽的内容，即显示该组件。</p><p>如果在加载 <code>AsyncComponent</code> 的过程中发生错误，<code>Suspense</code> 将会显示 <code>error</code> 插槽的内容，提示用户发生了错误。</p><p>通过结合 Vue Router 和 <code>Suspense</code>，你可以实现更精细的路由级别加载状态管理，为用户提供更好的体验。这尤其适用于大型应用程序，其中许多组件可能是按需异步加载的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../images/image-20240121162043161.png&quot; alt=&quot;image-20240121162043161&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 Vue 3 中，结合 Vue Router 使用 &lt;code&gt;Suspense&lt;/cod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单点登陆下-无感刷新</title>
    <link href="http://example.com/2024/03/25/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"/>
    <id>http://example.com/2024/03/25/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/</id>
    <published>2024-03-25T05:45:58.179Z</published>
    <updated>2024-04-09T08:19:42.981Z</updated>
    
    <content type="html"><![CDATA[<p>使用WebSocket加心跳检测实现token无感刷新与传统的客户端存在两个token（例如访问token和刷新token）来实现无感刷新的方式相比，各有其优劣。以下是它们之间的主要差异：</p><p><strong>使用WebSocket加心跳检测的优势：</strong></p><ol><li><strong>实时性</strong>：WebSocket提供了全双工的通信通道，使得服务器和客户端可以实时交换数据。这使得token的刷新过程更加及时，减少了因token过期导致的请求失败的可能性。</li><li><strong>减少请求次数</strong>：通过心跳检测，服务器可以在token过期前主动发送新的token给客户端，避免了客户端因token过期而需要重新请求token的情况，从而减少了不必要的网络请求。</li><li><strong>用户体验更好</strong>：由于token的刷新过程对用户来说是透明的，用户无需感知到任何操作或等待时间，从而提升了用户体验。</li></ol><p><strong>使用WebSocket加心跳检测的劣势：</strong></p><ol><li><strong>依赖稳定的网络连接</strong>：WebSocket需要稳定的网络连接才能保持通信。在网络不稳定或断开的情况下，可能会导致心跳检测失败或token刷新不及时。</li><li><strong>实现复杂度较高</strong>：WebSocket和心跳检测的实现相比传统的token刷新方式更为复杂，需要前端和后端都进行相应的开发和配置。</li></ol><p><strong>使用两个token（访问token和刷新token）的优势：</strong></p><ol><li><strong>更好的安全性</strong>：通过将访问token和刷新token分离，可以减少安全风险。即使访问token被泄露，攻击者也无法直接获取到刷新token，从而无法持续获取新的访问token。</li><li><strong>更好的灵活性</strong>：刷新token通常具有更长的有效期，这使得客户端在访问token过期后仍然有机会使用刷新token来获取新的访问token，而无需用户重新登录。</li></ol><p><strong>使用两个token的劣势：</strong></p><ol><li><strong>额外的存储和管理开销</strong>：客户端需要同时存储和管理访问token和刷新token，这增加了存储和管理的复杂度。</li><li><strong>可能的延迟</strong>：当访问token过期时，客户端需要发送请求使用刷新token来获取新的访问token，这可能会导致一定的延迟，影响用户体验。</li></ol><p>综上所述，两种方式各有其优劣。在选择时，需要根据具体的应用场景和需求进行权衡。例如，对于实时性要求较高且网络条件稳定的应用，使用WebSocket加心跳检测可能更为合适；而对于安全性要求较高或对网络延迟较敏感的应用，使用两个token的方式可能更为合适。</p><h1 id="浏览器端心跳检测的必要性"><a href="#浏览器端心跳检测的必要性" class="headerlink" title="浏览器端心跳检测的必要性"></a>浏览器端心跳检测的必要性</h1><p>首先我们先了解一下，目前的浏览器端的WebSocket何时会自动关闭WebSocket，并触发close事件呢？</p><ul><li>握手时的WebSocket地址不可用。</li><li>其它未知错误。</li><li>正常连接状态下，接收到服务器端的关闭帧就会触发关闭回调。</li></ul><p>也就是说建立正常连接后，中途浏览器端断网了，或者服务器没有发送关闭帧就关了连接，总之就是在连接无法再使用的情况下，浏览器没有接收到关闭帧，浏览器则会长时间保持连接状态。此时业务代码不去主动探测的话，是无法感知的。</p><p>另外通讯双方保持连接意味着需要长时间占用对方的资源。对于服务器端来说资源是非常宝贵的。长时间不活跃的连接，可能会被服务器应用层框架”优化”释放掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用WebSocket加心跳检测实现token无感刷新与传统的客户端存在两个token（例如访问token和刷新token）来实现无感刷新的方式相比，各有其优劣。以下是它们之间的主要差异：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用WebSocket加心跳检测的优势：&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>函数传参都是值传递</title>
    <link href="http://example.com/2024/03/24/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"/>
    <id>http://example.com/2024/03/24/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</id>
    <published>2024-03-24T13:44:06.863Z</published>
    <updated>2024-04-07T05:18:39.405Z</updated>
    
    <content type="html"><![CDATA[<p>let obj &#x3D; { value: 1 };  </p><p>function changeObject(obj) {<br>    &#x2F;&#x2F; 改变对象的属性<br>    obj.value &#x3D; 2;  </p><pre><code>// 试图改变对象的引用，不会影响到原始对象  obj = &#123; value: 3 &#125;;  </code></pre><p>}  </p><p>changeObject(obj);  </p><p>console.log(obj.value); &#x2F;&#x2F; 输出 2，不是 3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;let obj &amp;#x3D; { value: 1 };  &lt;/p&gt;
&lt;p&gt;function changeObject(obj) {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 改变对象的属性&lt;br&gt;    obj.value &amp;#x3D; 2;  &lt;/p&gt;
&lt;pre&gt;&lt;cod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二次封装分页组件</title>
    <link href="http://example.com/2024/03/19/vue/%E7%BB%84%E4%BB%B6/%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2024/03/19/vue/%E7%BB%84%E4%BB%B6/%E5%88%86%E9%A1%B5/</id>
    <published>2024-03-19T07:57:57.908Z</published>
    <updated>2024-04-07T05:14:52.154Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二次封装组件的三个"><a href="#二次封装组件的三个" class="headerlink" title="二次封装组件的三个"></a>二次封装组件的三个</h4><p>属性</p><p>插槽</p><p>ref</p><p><a href="https://www.douyin.com/search/%E6%B8%A1%E4%B8%80%E7%BB%84%E4%BB%B6?aid=cd8ce327-4950-4c39-8d30-51c361c73189&amp;modal_id=7329435609968282932&amp;publish_time=0&amp;sort_type=0&amp;type=general">https://www.douyin.com/search/%E6%B8%A1%E4%B8%80%E7%BB%84%E4%BB%B6?aid=cd8ce327-4950-4c39-8d30-51c361c73189&amp;modal_id=7329435609968282932&amp;publish_time=0&amp;sort_type=0&amp;type=general</a></p><h5 id="分页例子"><a href="#分页例子" class="headerlink" title="分页例子"></a>分页例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123; &#x27;hidden&#x27;: hidden &#125;&quot; class=&quot;pagination-container&quot;&gt;</span><br><span class="line">    &lt;el-pagination</span><br><span class="line">      :background=&quot;background&quot;</span><br><span class="line">      v-model:current-page=&quot;currentPage&quot;</span><br><span class="line">      v-model:page-size=&quot;pageSize&quot;</span><br><span class="line">      :layout=&quot;layout&quot;</span><br><span class="line">      :page-sizes=&quot;pageSizes&quot;</span><br><span class="line">      :pager-count=&quot;pagerCount&quot;</span><br><span class="line">      :total=&quot;total&quot;</span><br><span class="line">      @size-change=&quot;handleSizeChange&quot;   可以b&#x27;nu</span><br><span class="line">      @current-change=&quot;handleCurrentChange&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; scrollTo &#125; from &#x27;@/utils/scroll-to&#x27;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  total: &#123;</span><br><span class="line">    required: true,</span><br><span class="line">    type: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  page: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  limit: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  pageSizes: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default() &#123;</span><br><span class="line">      return [10, 20, 30, 50]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 移动端页码按钮的数量端默认值5</span><br><span class="line">  pagerCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: document.body.clientWidth &lt; 992 ? 5 : 7</span><br><span class="line">  &#125;,</span><br><span class="line">  layout: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;total, prev, pager, next, jumper,sizes&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  background: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true</span><br><span class="line">  &#125;,</span><br><span class="line">  autoScroll: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true</span><br><span class="line">  &#125;,</span><br><span class="line">  hidden: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit = defineEmits();</span><br><span class="line">const currentPage = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.page</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    emit(&#x27;update:page&#x27;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const pageSize = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.limit</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val)&#123;</span><br><span class="line">    emit(&#x27;update:limit&#x27;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function handleSizeChange(val) &#123;</span><br><span class="line">  if (currentPage.value * val &gt; props.total) &#123;</span><br><span class="line">    currentPage.value = 1</span><br><span class="line">  &#125;</span><br><span class="line">  emit(&#x27;pagination&#x27;, &#123; page: currentPage.value, limit: val &#125;)</span><br><span class="line">  if (props.autoScroll) &#123;</span><br><span class="line">    scrollTo(0, 800)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handleCurrentChange(val) &#123;</span><br><span class="line">  emit(&#x27;pagination&#x27;, &#123; page: val, limit: pageSize.value &#125;)</span><br><span class="line">  if (props.autoScroll) &#123;</span><br><span class="line">    scrollTo(0, 800)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.pagination-container &#123;</span><br><span class="line">  background: transparent;</span><br><span class="line">  padding: 32px 16px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.pagination-container.hidden &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="/../../../images/image-20240319155855063.png" alt="image-20240319155855063"></p><p><img src="/../../../images/image-20240319155902909.png" alt="image-20240319155902909"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二次封装组件的三个&quot;&gt;&lt;a href=&quot;#二次封装组件的三个&quot; class=&quot;headerlink&quot; title=&quot;二次封装组件的三个&quot;&gt;&lt;/a&gt;二次封装组件的三个&lt;/h4&gt;&lt;p&gt;属性&lt;/p&gt;
&lt;p&gt;插槽&lt;/p&gt;
&lt;p&gt;ref&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Service Worker和Web Worker</title>
    <link href="http://example.com/2024/03/11/web%20worker%20%E5%92%8C%20service.worer/"/>
    <id>http://example.com/2024/03/11/web%20worker%20%E5%92%8C%20service.worer/</id>
    <published>2024-03-11T03:11:55.112Z</published>
    <updated>2024-04-07T05:10:48.450Z</updated>
    
    <content type="html"><![CDATA[<p>Service Worker和Web Worker都是JavaScript中的工作线程，但它们在设计目标和使用场景上有一些显著的区别。</p><p>Web Worker主要用于执行后台任务，以避免阻塞主线程。它们运行独立的JavaScript文件，主要用于处理大量计算或执行长时间运行的任务，例如数据分析和图像处理，而不会导致页面无响应。Web Worker通过postMessage()方法向主线程发送消息，但无法访问DOM元素。</p><p>而Service Worker则是一种在浏览器中运行的脚本，用于拦截和处理网络请求、管理缓存等。Service Worker可以在网络请求到达时拦截它们，并使用缓存策略来响应用户的请求，以便在离线或网络不佳的情况下提供更好的用户体验。Service Worker还可以通过监听消息事件来接收来自其他脚本的消息，并执行相应的操作。与Web Worker不同，Service Worker具有一些额外的功能，如离线缓存和推送通知，使它们成为构建高性能、响应式Web应用的强大工具。</p><p>总结来说，Web Worker主要用于执行计算密集型任务，而Service Worker则更多地关注于网络请求的处理和缓存管理。两者都是提升Web应用性能和响应性的重要技术。</p><h3 id="Web-Worker-的通信时长"><a href="#Web-Worker-的通信时长" class="headerlink" title="Web Worker 的通信时长"></a>Web Worker 的通信时长</h3><p>并不是执行时间超过 50ms 的任务，就可以使用 Web Worker，还要先考虑<code>通信时长</code>的问题</p><p>假如一个运算执行时长为 100ms，但是通信时长为 300ms， 用了 Web Worker可能会更慢</p><p>比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源，下图中的 Time 是这个资源的通信时长（也叫加载时长）</p><p><img src="/../images/3b3f1e0b00b34a35813dd06f1354ee18tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="load.png"></p><p><strong>当任务的运算时长 - 通信时长 &gt; 50ms，推荐使用Web Worker</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Service Worker和Web Worker都是JavaScript中的工作线程，但它们在设计目标和使用场景上有一些显著的区别。&lt;/p&gt;
&lt;p&gt;Web Worker主要用于执行后台任务，以避免阻塞主线程。它们运行独立的JavaScript文件，主要用于处理大量计算或执</summary>
      
    
    
    
    
  </entry>
  
</feed>
