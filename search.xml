<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[axios和featch的写法]]></title>
      <url>/2024/11/12/%E6%9D%82/axios%E5%92%8Cfeatch/</url>
      <content type="html"><![CDATA[<h3 id="fetch和-axios的书写"><a href="#fetch和-axios的书写" class="headerlink" title="fetch和 axios的书写"></a>fetch和 axios的书写</h3><p><img src="/Yuanmingjian/../../images/image-20241112194707752.png" alt="image-20241112194707752"></p>
<p><img src="/Yuanmingjian/../../images/image-20241112200756387.png" alt="image-20241112200756387"></p>
<p>1axios中默认的请求头会给我们将Content-type自动设置成 application&#x2F;json  fetch就需要我们手动书写 不然就会导致传到后端的数据有误</p>
<p>2 请求体的数据在body中需要使用 JSON.stringify（） 将我们的js对象序列化  而在axios我们不需要关心这一点 axios也为我们做好了封装</p>
]]></content>
      
        <categories>
            
            <category> 杂 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络的一些杂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/11/11/%E5%B7%A5%E5%85%B7/nvm/</url>
      <content type="html"><![CDATA[<p>接入nvm</p>
<p>参考文章</p>
<p><a href="https://juejin.cn/post/7369027991442030643?searchId=20241111174855313D411D14D37EC1E9E8">https://juejin.cn/post/7369027991442030643?searchId=20241111174855313D411D14D37EC1E9E8</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[TS装饰器与元数据]]></title>
      <url>/2024/11/11/nest/Ts%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="装饰器的含义"><a href="#装饰器的含义" class="headerlink" title="装饰器的含义"></a>装饰器的含义</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。装饰器使用 @expression这种形式，expression求值后必须为一个函数，该函数会在运行时被调用（不管类是否实例化都会第一时间调用），被装饰者的信息（根据被装饰着不同而略有不同）将做为参数传入expression求值后的函数中。</p>
]]></content>
      
        <categories>
            
            <category> nest框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nest入门 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ioc依赖注入]]></title>
      <url>/2024/11/09/nest/ioc%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="ioc-控制反转"><a href="#ioc-控制反转" class="headerlink" title="ioc 控制反转"></a>ioc 控制反转</h3><p><strong>什么是控制反转（Inversion Of Control）</strong></p>
<p>控制反转是一种设计原则。顾名思义，它用于在面向对象设计中反转不同种类的控制以实现松耦合。在这里，控制是指一个类中除了完成其主要工作流程之外的其他所有流程，包括对应用程序流程的控制，以及对依赖对象创建和绑定流程的控制。</p>
<p><strong>什么是依赖注入（Dependency Injection）</strong></p>
<p>控制反转只告诉了我们需要怎么去做，但并没有告诉我们应该怎么做。所以实现控制反转的手段多种多样，其中比较流行的也是Nest、Spring等主流框架所使用的手段就是依赖注入。</p>
<p>依赖注入允许在类之外创建依赖对象，并通过<em><strong>不同的方式</strong></em>将这些对象提供给类。使用依赖注入的手段，我们能够将类所依赖对象的创建和绑定移动到类自身的实现之外。</p>
<p><em><strong>不同的方式</strong></em>包括：构造函数注入、属性注入、Setter方法注入、接口注入。</p>
<p><strong>我不想看概念了，能简单的说一下它们到底做了什么吗？</strong></p>
<p>通俗的说通过控制反转和依赖注入实现了以下功能：</p>
<p>如果类A需要类B，类A中并不直接控制创建类B的实例。与之相反，我们从类A外部控制类B实例的创建，类A之中只负责使用类B的实例，完全无需关心类B实例是如何创建的。</p>
<p><strong>参考文章</strong>：  <a href="https://juejin.cn/post/7085614364396355598">https://juejin.cn/post/7085614364396355598</a>  </p>
<p>最后，我们将Nest中的元素与我们自己编写的工厂进行一个类比：</p>
<ol>
<li><p>Provider &amp; Worker&#x2F;Machine：真正提供具体功能实现的低层类。</p>
</li>
<li><p>Controller &amp; ScrewWorkshop：调用低层类来为用户提供服务的高层类。</p>
</li>
<li><p>Nest框架本身 &amp; Factory：控制反转容器，对高层类和低层类统一管理，控制相关类的新建与注入，解藕了类之间的依赖。</p>
</li>
</ol>
<p><img src="/Yuanmingjian/../../images/image-20241112204839697.png"></p>
]]></content>
      
        <categories>
            
            <category> nest框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nest入门 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重学前端]]></title>
      <url>/2024/11/09/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/</url>
      <content type="html"><![CDATA[<p><img src="/Yuanmingjian/../images/image-20241109153545163.png" alt="image-20241109153545163"></p>
<p>js 按照文法、语义、运行时来拆分 </p>
<p>这符合编程语言的一般规律：<strong>用一定的词法和语法，表达一定语义，从而操作运行时。</strong></p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。</p>
<p>下面我们来看一看，为什么给对象添加的方法能用在基本类型上？</p>
<p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p>
<h2 id="装箱机制"><a href="#装箱机制" class="headerlink" title="装箱机制"></a>装箱机制</h2><p>3和new Number（3） 一个是基础类型 一个是对象类型</p>
<p>我给new Number（3）的原型对象加一个方法  3这个玩意可以直接调用 这是因为调用函数的时候 自动装箱转换成对象类型（new  Number（3））并调用该原型的方法 </p>
<p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</p>
<p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&quot;a&quot;));</span><br><span class="line"> </span><br><span class="line">console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p>
<p>但需要注意的是，<strong>call 本身会产生装箱操作</strong>，所以需要配合 typeof 来区分基本类型还是对象类型。</p>
<p>注意：&#x3D;&#x3D;运算符会自动拆箱 将对象转换为基本类型   object函数也会自动将对象转换为基本类型</p>
<h2 id="JavaScript对象：面向对象还是基于对象？"><a href="#JavaScript对象：面向对象还是基于对象？" class="headerlink" title="JavaScript对象：面向对象还是基于对象？"></a>JavaScript对象：面向对象还是基于对象？</h2><p>对象有如下几个特点。</p>
<ul>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。‘</li>
</ul>
<p>js对象独有的特点具有高度动态性的属性集合</p>
<p>在 JavaScript 中，对象的状态和行为其实都被抽象为了属性  一个值一个方法都是对象的属性</p>
<p><strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong></p>
<p>我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p>
<p>下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 1 &#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">console.log(o.a, o.b); //1 2</span><br></pre></td></tr></table></figure>

<p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter&#x2F;setter）两类。</p>
<h4 id="JavaScript-对象的两类属性"><a href="#JavaScript-对象的两类属性" class="headerlink" title="JavaScript 对象的两类属性"></a>JavaScript 对象的两类属性</h4><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p>
<p>先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>在大多数情况下，我们只关心数据属性的值即可。</p>
<p>第二类属性是访问器（getter&#x2F;setter）属性，它也有四个特征。</p>
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 1 &#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">//a 和 b 皆为数据属性</span><br><span class="line">Object.getOwnPropertyDescriptor(o,&quot;a&quot;) // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">Object.getOwnPropertyDescriptor(o,&quot;b&quot;) // &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。</p>
]]></content>
      
        <categories>
            
            <category> 基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nest简介]]></title>
      <url>/2024/11/08/nest/%E5%88%9D%E5%85%A5/</url>
      <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://nodejs.org/">Nest 是一个用于构建高效、可扩展的Node.js</a>服务器端应用程序的框架。它使用现代 JavaScript，以<a href="https://www.typescriptlang.org/">TypeScript</a>构建（保留与纯 JavaScript 的兼容性），并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式响应式编程）的元素。</p>
<p>在底层，Nest 使用了<a href="https://expressjs.com/">Express ，但也提供了与</a><a href="https://github.com/fastify/fastify">Fastify</a>等多种其他库的兼容性，从而可以轻松使用大量可用的第三方插件。</p>
<h3 id="q1：oop、fp、frp的解释"><a href="#q1：oop、fp、frp的解释" class="headerlink" title="q1：oop、fp、frp的解释"></a>q1：oop、fp、frp的解释</h3><h3 id="OOP（面向对象编程）"><a href="#OOP（面向对象编程）" class="headerlink" title="OOP（面向对象编程）"></a>OOP（面向对象编程）</h3><p><strong>面向对象</strong>编程是一种编程范式，它将数据和处理数据的方法组织成对象。对象是类的实例，类是对象的模板。</p>
<p><strong>特点</strong>:</p>
<ul>
<li>抽象：通过类和对象来模拟现实世界的事物。</li>
<li>封装：将数据和行为打包在一起。</li>
<li>继承：允许新的类继承一个或多个现有类的属性和方法。</li>
<li>多态：允许不同类的对象通过继承同一接口使用相同的代码。</li>
</ul>
<h3 id="FP（函数式编程）"><a href="#FP（函数式编程）" class="headerlink" title="FP（函数式编程）"></a>FP（函数式编程）</h3><p><strong>函数式编程</strong>是一种编程范式，它将计算视为函数的评估，并避免使用状态和可变数据。</p>
<p><strong>特点</strong>:</p>
<ul>
<li>纯函数：输出只依赖于输入的函数，没有副作用。</li>
<li>不可变性：数据一旦创建就不会被修改。</li>
<li>高阶函数：可以接收其他函数作为参数或将函数作为返回值的函数。</li>
<li>递归：函数通过自身调用以解决复杂问题。</li>
</ul>
<p>解决以下</p>
<ul>
<li>可扩展性–我是否需要不断地重构代码来支持额外的功能？</li>
<li>易模块化–如果我更改了一个文件，另一个文件是否会受到影响？</li>
<li>可重用性–是否有很多重复的代码？</li>
<li>可测性–给这些函数添加单元测试是否让我纠结？</li>
<li>易推理性–我写的代码是否非结构化严重并难以推理？</li>
</ul>
<p>函数式编程的目的是使用函数来<strong>抽象作用在数据之上的控制流和操作</strong>，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong></p>
<h3 id="FRP（函数式响应式编程）"><a href="#FRP（函数式响应式编程）" class="headerlink" title="FRP（函数式响应式编程）"></a>FRP（函数式响应式编程）</h3><p>函数式响应式编程是函数式编程的一个分支，它强调对事件或数据流的响应。</p>
<p><strong>特点</strong>:</p>
<ul>
<li><p>响应式：程序可以自动响应数据流的变化。</p>
</li>
<li><p>声明式：描述应该做什么，而不是如何做。</p>
</li>
<li><p>数据流：将数据变化视为流，并可以对这些流进行操作。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 – Michacel Feathers（Twitter）</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（面向切面编程）是一种编程范式，它允许开发者通过定义切面（Aspects）来对应用程序的各个部分添加横切关注点（Cross-Cutting Concerns）。横切关注点是那些不属于应用程序核心业务逻辑，但在整个应用程序中多处重复出现的功能或行为。AOP 允许开发者在不侵入业务逻辑的情况下来加入一些通用逻辑，如日志记录、事务管理、安全控制等。</p>
]]></content>
      
        <categories>
            
            <category> nest框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nest学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react的hook之useReducer]]></title>
      <url>/2024/10/18/react/useReducer/</url>
      <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>上边我们提到过基础的状态管理钩子 useState ，在 React Hook 中额外提供了一个关于状态管理的 useReducer。</p>
<h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a>useReducer 用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p>useReducer 接受三个参数分别是 reducer 函数、初始值 initialArg 以及一个可选的惰性初始化的 init 函数。</p>
<p>它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p>
<p>让我们通过一个简单的计数器例子来了解一下它的基础用法:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAction</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span>;</span><br><span class="line">  <span class="attr">payload</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">IState</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state: IState, action: IAction</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;subtract&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - action.<span class="property">payload</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Illegal operation in reducer.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello , My name is 19Qingfeng.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Counter: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;add&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          add 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;subtract&#x27;, payload: 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          subtract 1!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们创建了一个简单的 Counter 计数器组件，内部通过 useReducer 管理 couter 的状态。</p>
<blockquote>
<p>你可以在<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/elastic-kilby-x3kco">这里</a>来体验这个计数器小例子。</p>
</blockquote>
<h3 id="useState-amp-useReducer"><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h3><p>上边的计数器小例子我们其实通过 setState 完全也可以实现，大部分同学在写 component 时应该有存在这样一个疑问:</p>
<p>「什么时候使用 useState 又什么时候使用 useReducer ，useReducer 相比 useState 存在什么优势&#x2F;不足呢？」</p>
<p>其实在日常大多数情况下使用 useState 完全可以满足日常开发的作用，毕竟如果对于一个简单的操作如果使用 action -&gt; reducer -&gt; store 这种方式去管理状态实在是有点大材小用。</p>
<p>关于状态管理究竟是使用 useState 还是 useReducer 绝大多数文章会告诉你 useReducer 适用于复杂的状态逻辑。</p>
<p>没错，日常应用中我我也是这样使用的，存在多种复杂状态管理时利用 reducer 函数根据不同 action 去派发状态更新。</p>
<p>但是话又说回来如果某个 state 下存在很多操作状态，每个操作都有很多逻辑，对于这样复杂的状态，使用 useState 拥有单独的功能管理相比 reducer 中单个函数中的多个不同动作也许会更加清晰一些。</p>
<p>关于「什么时候使用 useState 又什么时候使用 useReducer」，在我个人看来这两种方式的使用更像是一种取舍<strong>总而言之尽量使用你觉得舒服的方法，对你和同事来说更容易理解就可以了。</strong></p>
<h3 id="深更新的组件做性能优化"><a href="#深更新的组件做性能优化" class="headerlink" title="深更新的组件做性能优化"></a>深更新的组件做性能优化</h3><p>在 useReducer 的官方文档中存在这样一句介绍:</p>
<blockquote>
<p>并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数</p>
</blockquote>
<p>在某些场景下我们通常会将函数作为 props 传递到 child component 中去，这样的话，每次父组件 re-render 时即使我们并没有修改当作 props 的函数，子组件也会重新渲染。</p>
<p>我们来一起看一下这个例子:  </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ts 代码解读复制代码<span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Hello This is Parent Component!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ParentCount: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ParentComponent</span>;</span><br><span class="line">ts 代码解读复制代码<span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="variable constant_">FC</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  callback?: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">&#123; callback &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;child re-render&#x27;</span>);</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello This is Child Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;callback &amp;&amp; callback()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们在父组件中传递给子组件一个 callback 函数作为 props ，当我们点击页面上的按钮来看看会发生什么:</p>
<p><img src="/Yuanmingjian/../../images/c88d9f17814249c692014fcf0e34142etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.gif" alt="QQ20211219-144858-HD.gif"></p>
<p>每次点击父组件的 button 时，子组件中的 effect 中被执行了。</p>
<p>此时其实我们传入子组件的 callback 并没有做什么改变，我们自然期望子组件中的 Effect 不会执行。</p>
<blockquote>
<p>产生这个原因的机制是 React 每次渲染都会重新执行组件函数，当重新执行父组件时会重新生成一个 callback 函数。因为 React 内部使用 Object.is 判断，所以 React 会认为子组件的 props 发生了变化。</p>
</blockquote>
<blockquote>
<p>你可以点击这里查看<a href="https://link.juejin.cn/?target=https://codesandbox.io/s/blue-wave-r5qs5"> CodeSanBox 例子</a></p>
</blockquote>
<p><strong>而在 useReduce 中返回的 dispatch 正是一个函数，但是 useReducer 的好处之一便是， dispatch 不会随着 re-render 而重新分配记忆位置，比方上述我们将 dispatch 作为 props 传入 child component 中时子组件中的 Effect 也并不会被执行。</strong></p>
<p>有兴趣的同学可以私下自己去尝试下，当然使用 useCallback 包括我们上述 Demo 中父组件的函数也是可以达到相同的效果，但是如此也就意味着說我们有非常多的 callback 需要绑在 useCallback 里边，这也许并不是一件好事</p>
<p>作者：19组清风<br>链接：<a href="https://juejin.cn/post/7043772161596588046">https://juejin.cn/post/7043772161596588046</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react的hook函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react的一些小记]]></title>
      <url>/2024/10/11/react/react%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="副作用的理解"><a href="#副作用的理解" class="headerlink" title="副作用的理解"></a>副作用的理解</h3><p> <img src="/Yuanmingjian/../../images/image-20241011175717835.png" alt="image-20241011175717835"></p>
<p><img src="/Yuanmingjian/../../images/image-20241011180049973.png" alt="image-20241011180049973"></p>
<p>由渲染本身引起的对接组件外部的操作  —— 副作用 如 发送网络请求、定时器</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react的一些小记（知识点） </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一行代码实现响应式]]></title>
      <url>/2024/09/25/css/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="columo-count-新特性"><a href="#columo-count-新特性" class="headerlink" title="columo count  新特性"></a>columo count  新特性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">### </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">column-count</span>: <span class="number">3</span>;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 在较宽屏幕下分为三列 */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">column-gap</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">         <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">column-count</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 中等宽度屏幕下分为两列 */</span></span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">​    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span></span><br><span class="line"><span class="language-css">​     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">​        <span class="attribute">column-count</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">​        <span class="comment">/* 窄屏幕下为一列 */</span></span></span><br><span class="line"><span class="language-css">​      &#125;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">​    <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">​    *&#123;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">​      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">​    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css的一些知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/05/17/%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title-微信公众号文章"><a href="#title-微信公众号文章" class="headerlink" title="title :微信公众号文章"></a>title :微信公众号文章</h2><p><a href="https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg">https://mp.weixin.qq.com/s/O8GCkAoA9RNNyELRg1sPMg</a> 在Vue中动态引入图片，为什么要用require</p>
<p><a href="https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw">https://mp.weixin.qq.com/s/f_ZxALB4fmycvOCmJCfVRw</a>  JS 分片任务的高阶函数封装</p>
<p><a href="https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw">https://mp.weixin.qq.com/s/r4KmP1cH-xgt7YaFV3JObw</a>  2024 Vue 联邦大会，全明星阵容！探讨 Vue 的未来和问题</p>
<p><a href="https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg">https://mp.weixin.qq.com/s/bRAtqjpyK7fVq2Ad4Hfslg</a> CSS3实现无缝滚动scroll，实用&#x3D;很丝滑+很漂亮+源码</p>
<p><a href="https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw">https://mp.weixin.qq.com/s/3SBpGx6EQCsmoh9qrnsmTw</a> 美化你的Github，变身专业大佬</p>
<p> <a href="https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ">https://mp.weixin.qq.com/s/bANThYgp1iqg9Bf8mVJNAQ</a>  前端如何防止接口重复提交</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue组件和vuex数据绑定]]></title>
      <url>/2024/05/09/bug/vue%E7%BB%84%E4%BB%B6%E5%92%8Cvuex%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h3 id="用computed作为桥梁"><a href="#用computed作为桥梁" class="headerlink" title="用computed作为桥梁"></a>用computed作为桥梁</h3><h5 id="之前放在data里面"><a href="#之前放在data里面" class="headerlink" title="之前放在data里面"></a>之前放在data里面</h5><p><img src="/Yuanmingjian/../../images/image-20240509172934274.png" alt="image-20240509172934274"></p>
<p>问题： 通过其他方式改变vuex里面这个state的数据后 该组件不会响应</p>
<p>原因：</p>
<ol>
<li><strong>Vue的响应式系统是基于getter和setter的</strong>：当Vue实例被创建时，它会遍历<code>data</code>对象中的所有属性，并使用<code>Object.defineProperty</code>将它们转化为getter&#x2F;setter，从而使这些属性变得“响应式”。<strong>但是，当你之后直接将Vuex的<code>state</code>中的数据赋值给<code>data</code>属性时，这些属性已经不再是Vue在初始化时定义的那些了，因此它们没有getter&#x2F;setter，也就不会触发视图更新。</strong></li>
</ol>
<p>解决方法</p>
<p><img src="/Yuanmingjian/../../images/image-20240509173132692.png" alt="image-20240509173132692"></p>
<p>把变量来放在computed里面</p>
<p>在Vue中，<code>computed</code>属性是基于它们的依赖进行缓存的。只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>computed</code>属性依赖的数据发生变化，它就会触发重新计算，并且如果计算的结果与之前的值不同，那么它还会触发视图更新。</p>
<p>Vuex的<code>state</code>是存储应用程序状态（也就是数据和状态信息）的地方。Vuex的状态管理模式是集中式的，也就是说我们有一个“单一状态树”，它包含了所有的应用状态。</p>
]]></content>
      
        <categories>
            
            <category> bug </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue的一些遇到的bug/问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[axios请求拦截]]></title>
      <url>/2024/04/11/axios%E6%8B%A6%E6%88%AA/</url>
      <content type="html"><![CDATA[<p><img src="/../images/image-20240411163605097.png" alt="image-20240411163605097"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[pnpm	与 npm]]></title>
      <url>/2024/04/10/pnpm/</url>
      <content type="html"><![CDATA[<p> 为什么浏览器可以访问nodemodules下的资源文件  因为vite或者webpack帮我们在一个端口假如是5173启动了一台静态服务器</p>
<p>文件访问能力是nodejs提供的 npm依旧是nodejs环境的 </p>
<h4 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h4><p>1利用操作系统的软连接技术提升性能</p>
<p>   a下载安装快</p>
<p>   b 节省磁盘空间</p>
<p>2 </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/04/09/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="setTimeout-与-setlnvertal-的区别"><a href="#setTimeout-与-setlnvertal-的区别" class="headerlink" title="setTimeout 与 setlnvertal 的区别"></a>setTimeout 与 setlnvertal 的区别</h3><ul>
<li><p>setTimeout 是递归循环，它基本上可以保证代码的执行顺序，每次的至少延迟时长大于等于设置的时间。</p>
</li>
<li><p>setlnvertal 每次定时触发执行回调函数，它的执行时间间隔可能会比期待的要小，而且不关心前一个回调函数是否执行，不会重复注册回调。</p>
<p> 定时放setinvertal进去 不管是否执行完 当执行时间大于间隔 会出现定时器代码间隔会比预期要小</p>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[响应式原理总结]]></title>
      <url>/2024/04/09/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="6-vue数据双向绑定的原理是什么？"><a href="#6-vue数据双向绑定的原理是什么？" class="headerlink" title="6.vue数据双向绑定的原理是什么？"></a>6.vue数据双向绑定的原理是什么？</h2><p><img src="/../../../images/image-20240125145019146.png" alt="image-20240125145019146"></p>
<h5 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h5><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给 订阅者，触发相应的监听回调。 </p>
<p>第一步:需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter<br>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据 变化 </p>
<p>第二步:compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图<br>第三步:Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情 是: </p>
<p>1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 </p>
<p>3、<strong>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</strong><br>第四步:MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher </p>
<p><strong>三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新;视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</strong></p>
<h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>Vue 的数据双向绑定是通过 Object.defineProperty() 方法实现的。在 Vue 中，每个组件实例都有一个对应的 Watcher 实例，Watcher 实例负责监听组件实例对象中所有用到的数据变化。</p>
<p>当数据发生变化时，Watcher 会通知订阅它的视图进行更新，从而实现了数据的响应式渲染。</p>
<p>具体来说，Vue 通过 Object.defineProperty() 方法实现了数据代理和数据劫持：</p>
<ul>
<li>数据代理：通过 Object.defineProperty() 方法将组件实例对象中的 data 对象中的属性代理到组件实例对象本身中，这样就可以通过 <a href="http://this.xxx/">this.xxx</a> 的方式直接访问 data 中的属性。</li>
<li>数据劫持：在代理过程中，由于使用了 Object.defineProperty() 方法，因此可以在读取或设置 data 属性值时，触发相应的 getter 和 setter 方法。在 getter 和 setter 方法中，通过收集 Watcher 实例的依赖关系，实现了数据发生变化时视图的响应式更新。</li>
</ul>
<p>总的来说，Vue 的数据双向绑定原理就是通过数据代理和数据劫持，以及 Watcher 实例的依赖收集和更新机制，实现了组件实例对象和视图之间的动态响应式绑定。这种机制避免了手动操作 DOM 元素的繁琐工作，提高了代码的可维护性和复用性。</p>
<p><img src="/../../../images/image-20240125144710461.png" alt="image-20240125144710461"></p>
<p><img src="/../../../images/image-20240125144948370.png" alt="image-20240125144948370"></p>
<h3 id="Dep补充"><a href="#Dep补充" class="headerlink" title="Dep补充"></a>Dep补充</h3><p><img src="/../../../images/image-20240125151254002.png" alt="image-20240125151254002"></p>
<h3 id="watcher补充"><a href="#watcher补充" class="headerlink" title="watcher补充"></a>watcher补充</h3><p><img src="/../../../images/image-20240202101644551.png" alt="image-20240202101644551"></p>
<p><img src="/../../../images/image-20240125153018052.png" alt="image-20240125153018052"></p>
<p><img src="/../../../images/image-20240125153538474.png" alt="image-20240125153538474"></p>
<p>在 Vue 中，<code>Dep</code>（依赖）和 <code>Watcher</code>（观察者）是实现响应式系统的重要组件。<code>Dep</code> 用来收集依赖（即 <code>Watcher</code>），当数据发生变化时，会通知所有依赖进行更新。<code>Watcher</code> 则用来观察数据的变化，当数据发生变化时，执行相应的回调函数。</p>
<p><code>Dep.target</code> 是一个全局变量，用来在收集依赖的过程中，将当前的 <code>Watcher</code> 与 <code>Dep</code> 进行绑定。</p>
<p>以下是 <code>Dep</code> 和 <code>Watcher</code> 如何互相绑定的简要过程：</p>
<ol>
<li><strong>初始化 Watcher</strong>：<br>当 Vue 组件需要观察某个数据时（例如，在模板中使用了数据属性），Vue 会为这个数据创建一个 <code>Watcher</code>。在创建 <code>Watcher</code> 的过程中，Vue 会将 <code>Dep.target</code> 设置为当前的 <code>Watcher</code>。</li>
<li><strong>访问数据</strong>：<br>当组件渲染或重新渲染时，会访问数据。如果数据是响应式的（即被 <code>Vue.observable</code> 或 <code>new Vue(&#123; data: ... &#125;)</code> 包裹过），那么这个数据会有一个与之关联的 <code>Dep</code> 实例。</li>
<li><strong>收集依赖</strong>：<br>在访问数据的过程中，<code>Dep</code> 会检查 <code>Dep.target</code> 是否存在。如果存在（即当前有 <code>Watcher</code> 正在观察数据），那么 <code>Dep</code> 会将 <code>Dep.target</code>（即当前的 <code>Watcher</code>）添加到其依赖列表中。</li>
<li><strong>重置 Dep.target</strong>：<br>收集完依赖后，Vue 会将 <code>Dep.target</code> 重置为 <code>null</code>，以确保下一个 <code>Watcher</code> 创建时不会错误地将之前的 <code>Watcher</code> 添加到新的依赖中。</li>
<li><strong>数据变化通知</strong>：<br>当数据发生变化时（例如，通过 <code>this.someData = newValue</code> 修改），<code>Dep</code> 会通知其依赖列表中的所有 <code>Watcher</code>。<code>Watcher</code> 接收到通知后，会执行其回调函数（通常是重新渲染组件）。</li>
</ol>
<p><code>defineReactive</code>、<code>observe</code>和<code>observer</code>在Vue的数据响应式原理中扮演着不同的角色。<code>defineReactive</code>负责定义对象的响应属性，<code>observe</code>负责递归地使对象的所有属性都具有响应性，而<code>observer</code>则是一个监听对象变化的机制或组件。它们共同工作，使得当数据发生变化时，视图可以自动更新，实现了数据的双向绑定。</p>
<p>observe—为新对象创建一个 observer对象</p>
<p>  observer对象遍历对象&#x2F;数组 </p>
<p>  依次为里面每一个item加一个dep  </p>
<p>  observer.walk()里面就是definereactive（）</p>
<p>这个函数就是dep 和 watcher的操作</p>
<p>dep 里面 关键点  subs数组存所有的watcher对象  addsub（这个是在watcher那边调用）</p>
<p>​                               nodify() 遍历subs数组去 执行watcher的一个notice 方法</p>
<p>​                              depend get数据的时候触发   执行watcher的adddep方法</p>
<p>watcher里面  关键点</p>
<h4 id="dep的depend-方法"><a href="#dep的depend-方法" class="headerlink" title="dep的depend 方法"></a>dep的depend 方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">   if (Dep.target) &#123;</span><br><span class="line">     Dep.target.addDep(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="watcher的adddep"><a href="#watcher的adddep" class="headerlink" title="watcher的adddep"></a>watcher的adddep</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1、添加 dep 给自己（watcher） </span><br><span class="line">// 2、添加自己（watcher）到 dep</span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  const id = dep.id</span><br><span class="line">  if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">    this.newDepIds.add(id)</span><br><span class="line">    this.newDeps.push(dep)</span><br><span class="line">    if (!this.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="过程大体"><a href="#过程大体" class="headerlink" title="过程大体"></a>过程大体</h4><p><strong>dep 和 watcher 建立联系的过程</strong></p>
<ul>
<li><p>执行watcher.get函数 做以下这几件事</p>
<p>1pushTarget(watcher)：将Dep.target设置为当前watche</p>
<p> 2 执行watcher.getter，watcher.getter执行期间，只要有读取到属性（已经做过响应式处理的属性），就会建立属性与watcher依赖收集（我们知道此时 的getter函数是通过遍历一个对象来一步步访问path的属性值，每一步都会触发数据的get拦截函数。）</p>
</li>
<li><p>依赖收集过程：</p>
</li>
<li><ul>
<li>watcher.getter方法会触发 属性的get函数 会执行dep.depend()</li>
<li>dep.depend() 会将执行当前Dep.target即watcher的addDep(dep)函数，并传入当前dep</li>
<li>watcher.addDep：会将dep存入newDeps实例属性上，并调用dep.addSub(watcher)，并传入watcher</li>
<li>dep.addSub：会将传入的watcher存入当前dep的subs实例属性上，然后dep和watcher就互相建立好联系</li>
</ul>
</li>
<li><p>watcher.getter执行结束后，会调用popTarget，将Dep.target设置为空</p>
</li>
</ul>
<h4 id="与diff时机-流程对比响应式思考"><a href="#与diff时机-流程对比响应式思考" class="headerlink" title="与diff时机 流程对比响应式思考"></a>与diff时机 流程对比响应式思考</h4><p>vue构造函数的时候当数据或者依赖改变的时候  运行一个函数  做两件事情     </p>
<p><img src="/../../../images/image-20240409140656037.png" alt="image-20240409140656037"></p>
<h4 id="顺序问题"><a href="#顺序问题" class="headerlink" title="顺序问题"></a>顺序问题</h4><p>在Vue.js的响应式系统中，<code>Observer</code>和<code>Watcher</code>之间的依赖收集过程是紧密相关的，但它们的执行顺序和职责有所不同。</p>
<p>首先，<code>Observer</code>类的主要职责是将一个对象转换为响应式的，即遍历对象的每个属性，并使用<code>defineReactive</code>函数将每个属性转换为getter&#x2F;setter的形式，同时为每个属性创建一个<code>Dep</code>实例来管理依赖。</p>
<p><strong>当组件实例化或渲染时，Vue.js会创建<code>Watcher</code>实例来观察数据的变化。<code>Watcher</code>在创建时会执行其<code>getter</code>函数，这通常是组件的渲染函数或计算属性的函数。</strong></p>
<p>在执行<code>watcher.getter</code>期间，当getter函数读取到已经做过响应式处理的属性时，会触发属性的getter方法。在getter方法中，如果该属性对应的<code>Dep</code>实例中没有这个<code>Watcher</code>的记录，那么就会将这个<code>Watcher</code>添加到该属性的<code>Dep</code>实例中，从而建立起属性与<code>Watcher</code>之间的依赖关系。</p>
<p>所以，简单来说，<strong>Observer在前，Watcher在后</strong>。先是通过Observer将对象转换为响应式的，并初始化每个属性的Dep实例。然后，当Watcher执行其getter函数时，会读取属性并触发依赖收集过程，将Watcher添加到属性的Dep实例中。</p>
<p>这个过程确保了当属性的值发生变化时，能够通知到所有依赖这个属性的Watcher，从而触发相应的更新操作，如重新渲染组件或重新计算属性等。</p>
<h3 id="watcher分类"><a href="#watcher分类" class="headerlink" title="watcher分类"></a>watcher分类</h3><p>在Vue中存在三种Watcher：</p>
<ul>
<li>负责视图变化的渲染Watcher</li>
<li>负责执行计算属性更新的的computed Watcher</li>
<li>用户通过watcher api自定义的user Watcher</li>
</ul>
<p>vue2中对属性进行遍历 让每一个对象变成响应式  是在creat之前完成得到的</p>
<p>vue3 中对对象进行代理  不用一开始就对对象的每一个属性变成响应式  只需要创建代理  这里相比vue2 就是如果有深入的递归对象   vue3就在之前会省去很多工作</p>
<p><img src="/../../../images/image-20240409160029495.png" alt="image-20240409160029495"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue插件]]></title>
      <url>/2024/04/08/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果插件是一个对象，必须提供 install 方法。</span><br><span class="line">如果插件是一个函数，它会被作为 install 方法。</span><br><span class="line">install 方法调用时，会将 Vue 作为参数传入。</span><br><span class="line"></span><br><span class="line">该方法需要在调用 new Vue() 之前被调用。</span><br><span class="line"></span><br><span class="line">当 install 方法被同一个插件多次调用，插件将只会被安装一次。</span><br></pre></td></tr></table></figure>

<p><img src="/../../../images/640-17125815901893.webp" alt="图片"></p>
<ul>
<li>创建一个插件(组件)</li>
<li>给该插件添加一个<strong>install</strong>方法，install方法里编写相关的注册逻辑，比如：把该插件注册为全局组件，这样就可以在整个项目中使用了。</li>
<li>在实例化Vue前，使用Vue.use(插件) 注册你的插件。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex pinia]]></title>
      <url>/2024/04/08/vue/vuex%E5%92%8Cpinina/</url>
      <content type="html"><![CDATA[<h3 id="Pinia-的优点："><a href="#Pinia-的优点：" class="headerlink" title="Pinia 的优点："></a>Pinia 的优点：</h3><ol>
<li>更加轻量级：相比 Vuex，Pinia 更加轻量级，因为它不需要使用 Vuex 的一些复杂的概念，如模块和 getter。</li>
<li>更加简单易用：Pinia 的 API 设计更加简单易用，因为它使用了 Vue.js 3 的新特性，如 Composition API。</li>
<li>更加灵活：Pinia 提供了更加灵活的状态管理方式，因为它支持多个 store 实例，而 Vuex 只支持一个 store 实例。</li>
</ol>
<h3 id="Vuex-的优点"><a href="#Vuex-的优点" class="headerlink" title="Vuex 的优点"></a>Vuex 的优点</h3><ol>
<li>更加成熟：Vuex 是一个比较成熟的状态管理库，它已经被广泛使用和测试。</li>
<li>更加稳定：Vuex 的稳定性也比 Pinia 更高，因为它已经经过了多个版本的迭代和改进。</li>
<li>更加强大：Vuex 提供了一些高级功能，如中间件和插件，使得它可以处理更加复杂的状态管理需求。</li>
</ol>
<p>Pinia采用了类似于React Hooks的方式来管理状态，这使得它更加直观和易于使用。Vuex则采用了一种基于mutations和actions的方式来管理状态，这可能需要更多的代码来实现相同的功能</p>
<h4 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h4><p><a href="https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1">https://juejin.cn/post/6855474001838342151?searchId=20240408210232FCD9127FFEF43F8A52DB#heading-1</a></p>
<p>Vuex本质是一个对象</p>
<p>Vuex对象有两个属性，一个是install方法，一个是Store这个类</p>
<p>install方法的作用是将store这个实例挂载到所有的组件上，注意是同一个store实例。</p>
<p>Store这个类拥有commit，dispatch这些方法，Store类里将用户传入的state包装成data，作为new Vue的参数，从而实现了state 值的响应式。</p>
<h2 id="六、实现Vuex的state"><a href="#六、实现Vuex的state" class="headerlink" title="六、实现Vuex的state"></a>六、实现Vuex的state</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码    &lt;p&gt;&#123;&#123;this.<span class="variable">$store</span>.state.num&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>我们都知道，可以通过这个 语句获得 state的值 但是我们在Store类里还没实现，显然，现在就这样取得话肯定报错。</p>
<p>前面讲过，我们是这样使用Store的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也就是说，我们把这个对象</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css复制代码&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当作参数了。</p>
<p>那我们可以直接在Class Store里，获取这个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = options.<span class="property">state</span> || &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这样是不是可以直接使用了呢？</p>
<p>试一下呗！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">//App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    123</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;this.$store.state.num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../../images/format,png.png" alt="img"></p>
<p>太赞了吧，怎么会这么简单。。。不敢相信。</p>
<p>哦不，当然没有这么简单，我们忽略了一点，state里的值也是响应式的哦，我们这样可没有实现响应式。</p>
<blockquote>
<p>曾经面试官问我Vuex和全局变量比有什么区别。这一点就是注意区别吧</p>
</blockquote>
<p>那要怎么实现响应式呢？ 我们知道，我们new Vue（）的时候，传入的data是响应式的，那我们是不是可以new 一个Vue，然后把state当作data传入呢？ 没有错，就是这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在是实现响应式了，但是我们怎么获得state呢？好像只能通过<code>this.$store.vm.state</code>了？但是跟我们平时用的时候不一样，所以，是需要转化下的。</p>
<p>我们可以给Store类添加一个state属性。这个属性自动触发get接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">state</span>:options.<span class="property">state</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增代码</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">state</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是ES6，的语法，有点类似于Object.defineProperty的get接口</p>
<p><img src="/../../images/format,png-17125828824606.png" alt="img"> 成功实现</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[箭头函数]]></title>
      <url>/2024/04/08/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>c 消除二义性</p>
<p>箭头函数 —》指令序列  和 对象没关系   不能new  也没有原型</p>
<h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p>3.51 <a href="mailto:&#88;&#64;&#x4d;&#x2e;&#87;&#109;">&#88;&#64;&#x4d;&#x2e;&#87;&#109;</a> 06&#x2F;20 ica:&#x2F; 箭头函数的意义 # JavaScript # 前端开发工程师 # 编程 # 程序员 # web前端  <a href="https://v.douyin.com/iYBp6x4f/">https://v.douyin.com/iYBp6x4f/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p>
<h4 id="与普通函数区别"><a href="#与普通函数区别" class="headerlink" title="与普通函数区别"></a>与普通函数区别</h4><p>1 箭头函数 不能new</p>
<p>2 没有argument对象</p>
<p>3 没有this  没有原型 </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Suspense]]></title>
      <url>/2024/04/07/vue/Suspense/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20240121162043161.png" alt="image-20240121162043161"></p>
<p>在 Vue 3 中，结合 Vue Router 使用 <code>Suspense</code> 可以帮助你更好地管理路由级别的加载状态。Vue Router 允许你定义路由时指定异步组件，而 <code>Suspense</code> 则可以在这些异步组件加载期间提供备用的内容或加载指示器。</p>
<p>以下是一个示例，展示了如何结合 Vue Router 和 <code>Suspense</code> 来管理路由级别的加载状态：</p>
<p>首先，确保你已经安装了 Vue Router 并设置了基本的路由配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js  </span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AsyncComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> routes = [  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/async&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./views/AsyncComponent.vue&#x27;</span>) &#125;,  </span><br><span class="line">];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;  </span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(process.<span class="property">env</span>.<span class="property">BASE_URL</span>),  </span><br><span class="line">  routes,  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>/async</code> 路由对应一个异步加载的组件 <code>AsyncComponent</code>。现在，我们可以在 App 组件中使用 <code>Suspense</code> 来处理这个路由的加载状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;  </span><br><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;  </span><br><span class="line">    &lt;Suspense&gt;  </span><br><span class="line">      &lt;template #default&gt;  </span><br><span class="line">        &lt;component :is=&quot;Component&quot; /&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #fallback&gt;  </span><br><span class="line">        &lt;div&gt;Loading...&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">      &lt;template #error&gt;  </span><br><span class="line">        &lt;div&gt;An error occurred while loading the component.&lt;/div&gt;  </span><br><span class="line">      &lt;/template&gt;  </span><br><span class="line">    &lt;/Suspense&gt;  </span><br><span class="line">  &lt;/router-view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">import &#123; Suspense &#125; from &#x27;vue&#x27;;  </span><br><span class="line">import router from &#x27;./router&#x27;;  </span><br><span class="line">  </span><br><span class="line">export default &#123;  </span><br><span class="line">  components: &#123;  </span><br><span class="line">    Suspense,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  setup() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      // 你可以在这里添加其他的响应式状态或方法  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用了 <code>router-view</code> 组件的插槽功能来包裹 <code>Suspense</code>。这样，每当路由改变时，<code>Component</code> 变量就会更新为当前路由对应的组件。<code>Suspense</code> 会根据这个组件是同步加载还是异步加载来显示不同的内容。</p>
<p>当访问 <code>/async</code> 路由时，由于 <code>AsyncComponent</code> 是异步加载的，<code>Suspense</code> 会显示 <code>fallback</code> 插槽的内容（即 “Loading…” 文本）。一旦 <code>AsyncComponent</code> 加载完成，<code>Suspense</code> 就会切换到 <code>default</code> 插槽的内容，即显示该组件。</p>
<p>如果在加载 <code>AsyncComponent</code> 的过程中发生错误，<code>Suspense</code> 将会显示 <code>error</code> 插槽的内容，提示用户发生了错误。</p>
<p>通过结合 Vue Router 和 <code>Suspense</code>，你可以实现更精细的路由级别加载状态管理，为用户提供更好的体验。这尤其适用于大型应用程序，其中许多组件可能是按需异步加载的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登陆下-无感刷新]]></title>
      <url>/2024/03/25/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>使用WebSocket加心跳检测实现token无感刷新与传统的客户端存在两个token（例如访问token和刷新token）来实现无感刷新的方式相比，各有其优劣。以下是它们之间的主要差异：</p>
<p><strong>使用WebSocket加心跳检测的优势：</strong></p>
<ol>
<li><strong>实时性</strong>：WebSocket提供了全双工的通信通道，使得服务器和客户端可以实时交换数据。这使得token的刷新过程更加及时，减少了因token过期导致的请求失败的可能性。</li>
<li><strong>减少请求次数</strong>：通过心跳检测，服务器可以在token过期前主动发送新的token给客户端，避免了客户端因token过期而需要重新请求token的情况，从而减少了不必要的网络请求。</li>
<li><strong>用户体验更好</strong>：由于token的刷新过程对用户来说是透明的，用户无需感知到任何操作或等待时间，从而提升了用户体验。</li>
</ol>
<p><strong>使用WebSocket加心跳检测的劣势：</strong></p>
<ol>
<li><strong>依赖稳定的网络连接</strong>：WebSocket需要稳定的网络连接才能保持通信。在网络不稳定或断开的情况下，可能会导致心跳检测失败或token刷新不及时。</li>
<li><strong>实现复杂度较高</strong>：WebSocket和心跳检测的实现相比传统的token刷新方式更为复杂，需要前端和后端都进行相应的开发和配置。</li>
</ol>
<p><strong>使用两个token（访问token和刷新token）的优势：</strong></p>
<ol>
<li><strong>更好的安全性</strong>：通过将访问token和刷新token分离，可以减少安全风险。即使访问token被泄露，攻击者也无法直接获取到刷新token，从而无法持续获取新的访问token。</li>
<li><strong>更好的灵活性</strong>：刷新token通常具有更长的有效期，这使得客户端在访问token过期后仍然有机会使用刷新token来获取新的访问token，而无需用户重新登录。</li>
</ol>
<p><strong>使用两个token的劣势：</strong></p>
<ol>
<li><strong>额外的存储和管理开销</strong>：客户端需要同时存储和管理访问token和刷新token，这增加了存储和管理的复杂度。</li>
<li><strong>可能的延迟</strong>：当访问token过期时，客户端需要发送请求使用刷新token来获取新的访问token，这可能会导致一定的延迟，影响用户体验。</li>
</ol>
<p>综上所述，两种方式各有其优劣。在选择时，需要根据具体的应用场景和需求进行权衡。例如，对于实时性要求较高且网络条件稳定的应用，使用WebSocket加心跳检测可能更为合适；而对于安全性要求较高或对网络延迟较敏感的应用，使用两个token的方式可能更为合适。</p>
<h1 id="浏览器端心跳检测的必要性"><a href="#浏览器端心跳检测的必要性" class="headerlink" title="浏览器端心跳检测的必要性"></a>浏览器端心跳检测的必要性</h1><p>首先我们先了解一下，目前的浏览器端的WebSocket何时会自动关闭WebSocket，并触发close事件呢？</p>
<ul>
<li>握手时的WebSocket地址不可用。</li>
<li>其它未知错误。</li>
<li>正常连接状态下，接收到服务器端的关闭帧就会触发关闭回调。</li>
</ul>
<p>也就是说建立正常连接后，中途浏览器端断网了，或者服务器没有发送关闭帧就关了连接，总之就是在连接无法再使用的情况下，浏览器没有接收到关闭帧，浏览器则会长时间保持连接状态。此时业务代码不去主动探测的话，是无法感知的。</p>
<p>另外通讯双方保持连接意味着需要长时间占用对方的资源。对于服务器端来说资源是非常宝贵的。长时间不活跃的连接，可能会被服务器应用层框架”优化”释放掉。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[函数传参都是值传递]]></title>
      <url>/2024/03/24/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</url>
      <content type="html"><![CDATA[<p>let obj &#x3D; { value: 1 };  </p>
<p>function changeObject(obj) {<br>    &#x2F;&#x2F; 改变对象的属性<br>    obj.value &#x3D; 2;  </p>
<pre><code>// 试图改变对象的引用，不会影响到原始对象  
obj = &#123; value: 3 &#125;;  
</code></pre>
<p>}  </p>
<p>changeObject(obj);  </p>
<p>console.log(obj.value); &#x2F;&#x2F; 输出 2，不是 3</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[二次封装分页组件]]></title>
      <url>/2024/03/19/vue/%E7%BB%84%E4%BB%B6/%E5%88%86%E9%A1%B5/</url>
      <content type="html"><![CDATA[<h4 id="二次封装组件的三个"><a href="#二次封装组件的三个" class="headerlink" title="二次封装组件的三个"></a>二次封装组件的三个</h4><p>属性</p>
<p>插槽</p>
<p>ref</p>
<p><a href="https://www.douyin.com/search/%E6%B8%A1%E4%B8%80%E7%BB%84%E4%BB%B6?aid=cd8ce327-4950-4c39-8d30-51c361c73189&amp;modal_id=7329435609968282932&amp;publish_time=0&amp;sort_type=0&amp;type=general">https://www.douyin.com/search/%E6%B8%A1%E4%B8%80%E7%BB%84%E4%BB%B6?aid=cd8ce327-4950-4c39-8d30-51c361c73189&amp;modal_id=7329435609968282932&amp;publish_time=0&amp;sort_type=0&amp;type=general</a></p>
<h5 id="分页例子"><a href="#分页例子" class="headerlink" title="分页例子"></a>分页例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123; &#x27;hidden&#x27;: hidden &#125;&quot; class=&quot;pagination-container&quot;&gt;</span><br><span class="line">    &lt;el-pagination</span><br><span class="line">      :background=&quot;background&quot;</span><br><span class="line">      v-model:current-page=&quot;currentPage&quot;</span><br><span class="line">      v-model:page-size=&quot;pageSize&quot;</span><br><span class="line">      :layout=&quot;layout&quot;</span><br><span class="line">      :page-sizes=&quot;pageSizes&quot;</span><br><span class="line">      :pager-count=&quot;pagerCount&quot;</span><br><span class="line">      :total=&quot;total&quot;</span><br><span class="line">      @size-change=&quot;handleSizeChange&quot;   可以b&#x27;nu</span><br><span class="line">      @current-change=&quot;handleCurrentChange&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; scrollTo &#125; from &#x27;@/utils/scroll-to&#x27;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  total: &#123;</span><br><span class="line">    required: true,</span><br><span class="line">    type: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  page: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  limit: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  pageSizes: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default() &#123;</span><br><span class="line">      return [10, 20, 30, 50]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 移动端页码按钮的数量端默认值5</span><br><span class="line">  pagerCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: document.body.clientWidth &lt; 992 ? 5 : 7</span><br><span class="line">  &#125;,</span><br><span class="line">  layout: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;total, prev, pager, next, jumper,sizes&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  background: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true</span><br><span class="line">  &#125;,</span><br><span class="line">  autoScroll: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true</span><br><span class="line">  &#125;,</span><br><span class="line">  hidden: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit = defineEmits();</span><br><span class="line">const currentPage = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.page</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    emit(&#x27;update:page&#x27;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const pageSize = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.limit</span><br><span class="line">  &#125;,</span><br><span class="line">  set(val)&#123;</span><br><span class="line">    emit(&#x27;update:limit&#x27;, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function handleSizeChange(val) &#123;</span><br><span class="line">  if (currentPage.value * val &gt; props.total) &#123;</span><br><span class="line">    currentPage.value = 1</span><br><span class="line">  &#125;</span><br><span class="line">  emit(&#x27;pagination&#x27;, &#123; page: currentPage.value, limit: val &#125;)</span><br><span class="line">  if (props.autoScroll) &#123;</span><br><span class="line">    scrollTo(0, 800)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handleCurrentChange(val) &#123;</span><br><span class="line">  emit(&#x27;pagination&#x27;, &#123; page: val, limit: pageSize.value &#125;)</span><br><span class="line">  if (props.autoScroll) &#123;</span><br><span class="line">    scrollTo(0, 800)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.pagination-container &#123;</span><br><span class="line">  background: transparent;</span><br><span class="line">  padding: 32px 16px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.pagination-container.hidden &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../../../images/image-20240319155855063.png" alt="image-20240319155855063"></p>
<p><img src="/../../../images/image-20240319155902909.png" alt="image-20240319155902909"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Service Worker和Web Worker]]></title>
      <url>/2024/03/11/web%20worker%20%E5%92%8C%20service.worer/</url>
      <content type="html"><![CDATA[<p>Service Worker和Web Worker都是JavaScript中的工作线程，但它们在设计目标和使用场景上有一些显著的区别。</p>
<p>Web Worker主要用于执行后台任务，以避免阻塞主线程。它们运行独立的JavaScript文件，主要用于处理大量计算或执行长时间运行的任务，例如数据分析和图像处理，而不会导致页面无响应。Web Worker通过postMessage()方法向主线程发送消息，但无法访问DOM元素。</p>
<p>而Service Worker则是一种在浏览器中运行的脚本，用于拦截和处理网络请求、管理缓存等。Service Worker可以在网络请求到达时拦截它们，并使用缓存策略来响应用户的请求，以便在离线或网络不佳的情况下提供更好的用户体验。Service Worker还可以通过监听消息事件来接收来自其他脚本的消息，并执行相应的操作。与Web Worker不同，Service Worker具有一些额外的功能，如离线缓存和推送通知，使它们成为构建高性能、响应式Web应用的强大工具。</p>
<p>总结来说，Web Worker主要用于执行计算密集型任务，而Service Worker则更多地关注于网络请求的处理和缓存管理。两者都是提升Web应用性能和响应性的重要技术。</p>
<h3 id="Web-Worker-的通信时长"><a href="#Web-Worker-的通信时长" class="headerlink" title="Web Worker 的通信时长"></a>Web Worker 的通信时长</h3><p>并不是执行时间超过 50ms 的任务，就可以使用 Web Worker，还要先考虑<code>通信时长</code>的问题</p>
<p>假如一个运算执行时长为 100ms，但是通信时长为 300ms， 用了 Web Worker可能会更慢</p>
<p>比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源，下图中的 Time 是这个资源的通信时长（也叫加载时长）</p>
<p><img src="/../images/3b3f1e0b00b34a35813dd06f1354ee18tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="load.png"></p>
<p><strong>当任务的运算时长 - 通信时长 &gt; 50ms，推荐使用Web Worker</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vite]]></title>
      <url>/2024/03/11/%E5%B7%A5%E7%A8%8B%E5%8C%96/vite/</url>
      <content type="html"><![CDATA[<h2 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h2><h3 id="什么是esbuild？"><a href="#什么是esbuild？" class="headerlink" title="什么是esbuild？"></a>什么是<a href="https://link.juejin.cn/?target=https://esbuild.github.io/">esbuild</a>？</h3><p><code>esbuild</code> 是一款基于 <code>Go</code> 语言开发的 <code>javascript</code> 构建打包工具，相比传统的构建工具，主打性能优势。同样规模的项目，使用 <code>Esbuild</code> 可以将打包速度提升 <code>10</code> - <code>100</code> 倍，这对广大一直饱受 <code>Webpack</code> 缓慢打包速度折磨的开发人员来说，简直就是福音。</p>
<p>下图为esbuild和其他的构建工具用默认配置打包10个three.js库所花费时间的对比：</p>
<p><img src="/Yuanmingjian/../images/1256b2f12e9149a99e2ddd0864f84128tplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="1.png"></p>
<h3 id="为什么能这么快？"><a href="#为什么能这么快？" class="headerlink" title="为什么能这么快？"></a>为什么能这么快？</h3><ol>
<li><strong>Golang 开发</strong></li>
</ol>
<p>采用 Go 语言开发，传统的JS开发的构建工具并不适合资源打包这种 CPU 密集场景下，Go更具性能优势。</p>
<ol>
<li><strong>多核并行</strong></li>
</ol>
<p>go具有多线程运行能力，而JS本质上就是一门单线程语言。由于go的多个线程是可以共享内存的，所以可以将解析、编译和生成的工作并行化。</p>
<ol>
<li><strong>从零开始</strong></li>
</ol>
<p>从一开始就考虑性能，不使用第三方依赖，从始至终是使用的是一致的数据结构，从而避免数据转换无意义的消耗。</p>
<ol>
<li><strong>内存的有效利用</strong></li>
</ol>
<p>在 JS 开发的传统打包工具当中一般会频繁地解析和传递抽象语法树( AST )数据，比如 <code>字符串 -&gt; TS -&gt; JS -&gt; 字符串，然后字符串 -&gt; JS -&gt; 旧的JS -&gt; 字符串，然后字符串 -&gt; JS -&gt; minified JS -&gt; 字符串</code>，这其中会涉及复杂的编译工具链，比如 <code>webpack -&gt; babel -&gt; terser</code>，每次接触到新的工具链，都得重新解析 AST，导致大量的内存占用。</p>
<p>esbuild 仅触及整个JavaScript AST 3次：</p>
<ol>
<li>进行词法分析，解析，作用域设置和声明符号的过程</li>
<li>绑定符号，最小化语法。比如：将 JSX &#x2F; TS转换为 JS。</li>
<li>AST生成JS，source map生成。</li>
</ol>
<p>当 AST 数据在CPU缓存中仍然处于活跃状态时，会最大化AST数据的重用。</p>
<p><img src="/Yuanmingjian/../images/caa44f9761434f0dbbd0dcf35023d592tplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="2.png"></p>
<h3 id="为什么还没有一统江山？"><a href="#为什么还没有一统江山？" class="headerlink" title="为什么还没有一统江山？"></a>为什么还没有一统江山？</h3><p>虽然esbuild有很多优点，但是缺点也非常的明显，从esbuild的官方文档<a href="https://link.juejin.cn/?target=https://esbuild.github.io/faq/%23upcoming-roadmap">upcoming roadmap</a>中，就能看出下面的问题：</p>
<ul>
<li><strong>ESbuild 没有提供 AST 的操作能力，打包产物无法降级到 ES5 及以下，不能兼容一些低版本浏览器</strong></li>
<li><strong>Code splitting 还在计划中</strong></li>
<li><strong>没有TS的类型检测</strong></li>
<li><strong>默认不支持vue，angular等代码文件格式</strong></li>
<li>……</li>
</ul>
<p>简单来说，现在希望直接将esbuild放入到生产环境中，还需要一些路走，并不足以支撑一个大型项目的开发需求。有些内容虽然我们可以通过插件去实现，但是并不是开箱即用的功能，对于项目开发的新手来说，并不友好。变相增加了开发成本</p>
<h3 id="为什么要学习esbuild"><a href="#为什么要学习esbuild" class="headerlink" title="为什么要学习esbuild?"></a>为什么要学习esbuild?</h3><p>无论如何，<code>esbuild</code>为我们所熟知，还是因为<a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/"><strong>Vite</strong></a>，<code>esbuild</code>是组成<code>Vite</code>的两架马车之一。</p>
<p>下图描述了<code>Vite</code>的架构组成:</p>
<p><img src="/Yuanmingjian/../images/486d548a80ae414da3e27fccb0f4609dtplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="3.png"></p>
<h3 id="为什么Vite要使用esbuild？"><a href="#为什么Vite要使用esbuild？" class="headerlink" title="为什么Vite要使用esbuild？"></a>为什么Vite要使用esbuild？</h3><p>一个字…快</p>
<p>现在来说，Vite在下面几个地方都依托于esbuild，而未来随着esbuild的完善，应该会做进一步处理</p>
<ul>
<li><strong>依赖预构建—作为 Bundle 工具</strong></li>
<li><strong>单文件编译——作为 TS 和 JSX 编译工具</strong></li>
<li><strong>代码压缩——作为压缩工具</strong></li>
</ul>
<h3 id="什么是no-bundle"><a href="#什么是no-bundle" class="headerlink" title="什么是no-bundle?"></a>什么是no-bundle?</h3><p><code>ESM</code>是<code>JavaScript</code>提出的官方标准化模块系统，不同于之前的<code>CJS</code>，<code>AMD</code>，<code>CMD</code>等等，<code>ESM</code>提供了更原生以及更动态的模块加载方案，最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行<code>import</code>，动态引入我们需要的模块，而不是把所有模块打包在一起。</p>
<p>Vite 是一个提倡 <code>no-bundle</code> 的构建工具，相比于传统的 Webpack，能做到开发时的模块按需编译，而不用先打包完再加载。</p>
<p><img src="/Yuanmingjian/../images/2af3265093ef49bfb9a8e01d14093610tplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="4.png"></p>
<p><img src="/Yuanmingjian/../images/0622a82d840544ea82322b776f5abf4etplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="5.png"></p>
<h3 id="什么是依赖预构建？"><a href="#什么是依赖预构建？" class="headerlink" title="什么是依赖预构建？"></a>什么是依赖预构建？</h3><p>模块代码其实分为两部分，一部分是源代码，也就是业务代码，另一部分是第三方依赖的代码，即<code>node_modules</code>中的代码。所谓的<code>no-bundle</code>只是对于源代码而言，对于第三方依赖而言，我们基本不会去改变他，Vite 还是选择 bundle(打包)，这个部分，就依赖于<code>esbuild</code>。</p>
<p>但是关键点是，为什么在开发阶段我们要对第三方依赖进行预构建? 如果不进行预构建会怎么样？</p>
<p>首先 Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行。但是，我们没有办法控制第三方的打包规范。还有相当多的第三方库仍然没有 ES 版本的产物。</p>
<p>此外，ESM还有一个比较重要的问题——<strong>请求瀑布流问题</strong>。ESM的每个<code>import</code>都会触发一次新的文件请求，因此在<code>依赖层级深</code>、<code>涉及模块数量多</code>的情况下，会触发很多个网络请求，巨大的请求量加上 <strong>Chrome 对同一个域名下只能同时支持 6个 HTTP 并发请求的限制</strong>，导致页面加载十分缓慢，与 Vite 主导性能优势的初衷背道而驰。</p>
<p>在进行<strong>依赖的预构建</strong>之后，这种第三方库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多</p>
<h2 id="都有-Rollup-了，为什么还需要-Rolldown？"><a href="#都有-Rollup-了，为什么还需要-Rolldown？" class="headerlink" title="都有 Rollup 了，为什么还需要 Rolldown？"></a>都有 Rollup 了，为什么还需要 Rolldown？</h2><p>Rolldown 旨在成为 Vite 未来使用的核心底层打包工具，与常见的开箱即用的构建工具（如Webpack、Vite等）不同，它更加专注于底层的打包逻辑和核心功能，以满足 Vite 对于高效打包的特定需求。</p>
<p><img src="/Yuanmingjian/../images/640.png" alt="图片"></p>
<p>目前，Vite 的底层使用了两个打包工具：</p>
<ul>
<li><strong>Esbuild</strong>：Esbuild 是一款高性能的  JavaScript 打包器，专注于实现极速的构建过程。它支持多种模块类型、语法转换和插件扩展，且无需缓存即可迅速完成打包任务。在 Vite 中，Esbuild 被用于依赖预打包、TypeScript和JSX转换、目标降级以及代码压缩。</li>
<li><strong>Rollup</strong>：Rollup 是一个JavaScript模块打包器，能够编译小块代码成复杂的大型代码块，特别支持ES6模块。它支持 Tree Shaking，有效去除未使用的代码，减少最终文件大小。在 Vite 中，Rollup 被用于生产构建，并支持一个与Rollup 兼容的插件接口。</li>
</ul>
<p>Vite 之所以采用两个不同的打包工具，是因为虽然 Esbuild 速度卓越且功能丰富，但其在代码块拆分方面的局限使其不适用于应用打包；而 Rollup 虽在应用打包方面成熟可靠，但性能却不及原生编译工具。两者各有优势，功能互补，因此 Vite 需要结合使用以满足不同需求。</p>
<p>然而，使用两个不同的打包工具存在明显弊端：它们之间的输出差异可能导致开发环境与生产环境行为的不一致，同时，用户代码在生产构建过程中会被多次解析、转换和序列化，从而增加了不必要的性能开销。</p>
<p>因此，希望 Vite 能够整合一个单一的、性能卓越的打包工具，既能减少解析和序列化开销，又能与 Rollup 插件生态兼容，并具备出色的大型应用构建输出控制能力。所以，Rolldown 就诞生了！</p>
<p>正是在这个背景下，Rolldown 应运而生！</p>
<h2 id="Rolldown-的未来"><a href="#Rolldown-的未来" class="headerlink" title="Rolldown 的未来"></a>Rolldown 的未来</h2><p>Rolldown 使用 Rust 编写，并且使用了 Oxc 中的工具。Oxc 是字节跳动出品的一个用 Rust 编写的 JavaScript 高性能工具集合，该项目的重点在于构建 JavaScript 的基本编译器工具：<strong>解析器、linter、格式化程序、转译器、压缩器</strong>和<strong>解析引擎</strong>。此外，OXC 还为 Rspack、Rolldown 和 Ezno 等新兴 JavaScript 工具提供支持。</p>
<p><img src="/Yuanmingjian/../images/640-17101245635925.png" alt="图片"></p>
<p>目前，Rolldown 主要依赖其高效的解析器和解析引擎进行工作。未来，一旦 Oxc 的转换器和压缩器可用，Rolldown 也将计划集成它们，Rolldown 也将直接作为独立的打包使用。</p>
<p>当 Rolldown 发展至成熟阶段时，它将能够直接取代 Esbuild 和 Rollup，这样将减少了对外部工具的依赖，为未来的功能扩展提供更大的便利和灵活性。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[dll库的使用]]></title>
      <url>/2024/03/10/dll/</url>
      <content type="html"><![CDATA[<p>在Vue项目中结合Webpack使用DLL可以显著提高构建性能，特别是在处理大型项目或包含大量不经常变动的依赖时。以下是一个使用Webpack DLL插件在Vue项目中实现DLL的示例：</p>
<h3 id="步骤-1-创建DLL库"><a href="#步骤-1-创建DLL库" class="headerlink" title="步骤 1: 创建DLL库"></a>步骤 1: 创建DLL库</h3><p>首先，你需要创建一个DLL库，这个库将包含你想要从主<u>构建中分离出来的</u>代码。这通常包括第三方<em>库或你自</em>己的不经常&#x3D;&#x3D;变动的代码&#x3D;&#x3D;。</p>
<ol>
<li><strong>创建DLL项目目录</strong>：在你的Vue项目根目录下创建一个新目录，例如<code>dll</code>。</li>
<li><strong>安装Webpack DLL插件</strong>：在<code>dll</code>目录下，初始化一个npm项目并安装<code>webpack</code>和<code>webpack-dll-plugin</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dll  </span><br><span class="line">npm init -y  </span><br><span class="line">npm install webpack webpack-cli --save-dev  </span><br><span class="line">npm install webpack-dll-plugin --save-dev</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>创建DLL的Webpack配置文件</strong>：在<code>dll</code>目录下创建一个<code>webpack.dll.config.js</code>文件，并配置DLL插件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js  </span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DllPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dll-plugin&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">  <span class="attr">entry</span>: &#123;  </span><br><span class="line">    <span class="attr">vendor</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;vue-router&#x27;</span>, <span class="string">&#x27;axios&#x27;</span>, <span class="comment">/* 其他不经常变动的依赖 */</span>],  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">output</span>: &#123;  </span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),  </span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>,  </span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_library&#x27;</span>,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">plugins</span>: [  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DllPlugin</span>(&#123;  </span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_library&#x27;</span>,  </span><br><span class="line">      <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;manifest.json&#x27;</span>),  </span><br><span class="line">    &#125;),  </span><br><span class="line">  ],  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>构建DLL库</strong>：运行Webpack来构建DLL库。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码</span><br><span class="line"></span><br><span class="line">npx webpack --config webpack.dll.config.js</span><br></pre></td></tr></table></figure>

<p>这将在<code>dll/dist</code>目录下生成<code>vendor.dll.js</code>文件，并在<code>dll</code>目录下生成<code>manifest.json</code>文件，该文件包含了DLL库中各模块的映射关系。</p>
<h3 id="步骤-2-在Vue项目中引用DLL库"><a href="#步骤-2-在Vue项目中引用DLL库" class="headerlink" title="步骤 2: 在Vue项目中引用DLL库"></a>步骤 2: 在Vue项目中引用DLL库</h3><p>接下来，你需要在Vue项目中配置Webpack来引用这个DLL库。</p>
<ol>
<li><strong>在Vue项目中安装Webpack DLL插件</strong>（如果尚未安装）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码</span><br><span class="line"></span><br><span class="line">npm install webpack-dll-plugin --save-dev</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>修改Vue项目的Webpack配置文件</strong>：在你的Vue项目的Webpack配置文件中（通常是<code>vue.config.js</code>或<code>webpack.config.js</code>），添加DLL插件的引用，并排除已经在DLL库中的模块。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 或 webpack.config.js  </span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DllPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dll-plugin&#x27;</span>);  </span><br><span class="line"><span class="keyword">const</span> dllManifest = <span class="built_in">require</span>(<span class="string">&#x27;./dll/manifest.json&#x27;</span>); <span class="comment">// 引入DLL的manifest文件  </span></span><br><span class="line">  </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">  <span class="comment">// ... 其他配置 ...  </span></span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;  </span><br><span class="line">    <span class="attr">plugins</span>: [  </span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;  </span><br><span class="line">        <span class="attr">context</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dll&#x27;</span>), <span class="comment">// 必须和dll中webpack.dll.config.js配置的output.path一致  </span></span><br><span class="line">        <span class="attr">manifest</span>: dllManifest,  </span><br><span class="line">      &#125;),  </span><br><span class="line">    ],  </span><br><span class="line">    <span class="attr">optimization</span>: &#123;  </span><br><span class="line">      <span class="attr">splitChunks</span>: &#123;  </span><br><span class="line">        <span class="attr">cacheGroups</span>: &#123;  </span><br><span class="line">          <span class="attr">vendor</span>: &#123;  </span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,  </span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;vendors&#x27;</span>,  </span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,  </span><br><span class="line">          &#125;,  </span><br><span class="line">        &#125;,  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">resolve</span>: &#123;  </span><br><span class="line">      <span class="attr">alias</span>: &#123;  </span><br><span class="line">        <span class="comment">// 如果有需要，可以通过alias来重命名DLL中的库以避免和全局的冲突  </span></span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="comment">// ... 其他配置 ...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>更新项目的入口文件</strong>：在你的Vue项目的入口文件（通常是<code>main.js</code>或<code>src/main.js</code>）中，不再需要引入已经在DLL库中的依赖。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js  </span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 不再需要引入已经在DLL库中的依赖，如Vue、vue-router等  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;  </span><br><span class="line">  router,  </span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),  </span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>构建并运行Vue项目</strong>：现在，当你构建和运行Vue项目时，Webpack将使用DLL库中的代码，从而提高了构建速度。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build  </span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你已经在Vue项目中成功使用了DLL来优化构建性能。注意，DLL</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一些场景题]]></title>
      <url>/2024/03/09/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>深拷贝</p>
<p>千位分隔符</p>
<p>判断一颗二叉树是否对称<br>异步并发控制M个任务每次执行N个，尽可能快的执行完（利用await配合Promise对超出任务进行阻塞，前面执行完了之后区调用promise的resolve达到目的）面试官说我这种方法写的很优雅</p>
<p><img src="/../../images/4AD4E80A524642AC09CB58AE849573AA.png" alt="img"></p>
<p>请求超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 模拟请求</span><br><span class="line">function request(params) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(params)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 超时包装函数</span><br><span class="line"> * @param &#123;() =&gt; Promise&lt;any&gt;&#125; p 请求函数</span><br><span class="line"> * @param &#123;number&#125; timeout 超时时间</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">function timeoutWrap(p, timeout) &#123;</span><br><span class="line">  const delay = new Promise((_, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      reject(&#x27;超时了&#x27;)</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;)</span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    const p1 = p(...args)</span><br><span class="line">    const res = Promise.race([p1, delay])</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const r1 = timeoutWrap(request, 1000)(&#123; id: 1 &#125;)</span><br><span class="line">r1.then(response =&gt; &#123;</span><br><span class="line">  console.log(response)</span><br><span class="line">&#125;).catch(e =&gt; &#123;</span><br><span class="line">  console.log(&#x27;e&#x27;, e)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="写一个树形组件"><a href="#写一个树形组件" class="headerlink" title="写一个树形组件?"></a>写一个树形组件?</h4><h5 id="数据存localStorage中会不会遇到有上限的情况？什么时候清除合适"><a href="#数据存localStorage中会不会遇到有上限的情况？什么时候清除合适" class="headerlink" title="数据存localStorage中会不会遇到有上限的情况？什么时候清除合适"></a>数据存localStorage中会不会遇到有上限的情况？什么时候清除合适</h5><p> 通常每个源（例如一个特定的网站）的 <code>localStorage</code> 限制在几兆字节（MB）到几十兆字节（MB）之间。当达到这个限制时，再尝试存储更多的数据会失        败。<strong>5MB</strong> 到 <strong>10MB</strong> </p>
<ol>
<li><strong>数据过期</strong>：如果你的应用存储了时效性数据（例如，用户会话信息、临时缓存等），那么这些数据在过期后应该被清除。</li>
<li><strong>用户操作</strong>：有时用户可能会执行某些操作，比如注销账户或删除特定数据，这时你也应该相应地清除 <code>localStorage</code> 中的数据。</li>
<li><strong>存储空间管理</strong>：如果你的应用经常需要存储大量数据，并且接近或达到 <code>localStorage</code> 的上限，那么你可能需要实施一种策略来定期清理不再需要的数据。</li>
<li><strong>隐私和安全性</strong>：在某些情况下，出于隐私和安全性的考虑，你可能需要在用户退出登录或关闭浏览器时清除 <code>localStorage</code> 中的数据。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自己的面试题]]></title>
      <url>/2024/03/08/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="武汉公司"><a href="#武汉公司" class="headerlink" title="武汉公司"></a>武汉公司</h4><p>http是什么 如何理解</p>
<p>https</p>
<p>tcp和udp</p>
<p>三次挥手</p>
<p>闭包</p>
<p><strong>虚拟dom</strong> </p>
<p>new一个实例</p>
<p>各种定位</p>
<p>隐藏dom</p>
<p>js数据类型</p>
<p><strong>项目遇到的问题</strong></p>
<p>返回的错误报错</p>
<h4 id="字节一面"><a href="#字节一面" class="headerlink" title="字节一面"></a>字节一面</h4><p>1自我介绍</p>
<p>2介绍项目 （websork） 渲染优化方案 </p>
<p>3首屏渲染 懒加载如何做 </p>
<p>4上线发布流程 大概是什么 </p>
<p>4vue3 proxy和definepro</p>
<p>5输入url到页面呈现的过程</p>
<p>6websorkt原理</p>
<p>7<strong>看代码输出过程 宏微队列</strong></p>
<p>8将数组对象转化为树状结构</p>
<p>9手撕快排</p>
<p>10场景利用proxy 打印对象路径</p>
<h4 id="美团暑期实习一面"><a href="#美团暑期实习一面" class="headerlink" title="美团暑期实习一面"></a>美团暑期实习一面</h4><p>1 自我介绍</p>
<p>2 闭包是什么 用在什么地方</p>
<p>3 迭代器是什么</p>
<p>4 全局作用域和块级作用域</p>
<p>5 css的权重如何计算</p>
<p>5 webpack 的 loader 和 plugin是什么</p>
<p>6 手写element tree结构</p>
<p>7手写提示框组件</p>
<p>8 手写单例模式</p>
<h4 id="云智一面"><a href="#云智一面" class="headerlink" title="云智一面"></a>云智一面</h4><p>1自我介绍</p>
<p>2项目</p>
<p>3事件循环 具体微任务 宏任务</p>
<p>4vue-router的两个模式</p>
<p>5nodejs如何看文件大小 和环境比哪里</p>
<p>6vuex和pinan区别</p>
<p>7csrf攻击     利用cookie在同源请求中 携带从发送给服务器特点 实现用户的冒充   防御：1同源检测 cook的sametit</p>
<h4 id="暑期实习腾讯云智1面"><a href="#暑期实习腾讯云智1面" class="headerlink" title="暑期实习腾讯云智1面"></a>暑期实习腾讯云智1面</h4><p>1自我介绍</p>
<p>2 ts好处</p>
<p>3 vuex的原理 ××</p>
<p>4 vue-router的两个模式</p>
<p>5nodejs的事件循环 </p>
<p>6nodejs洋葱圈模型 ×</p>
<p>7 网络安全 xss csrf</p>
<p>8 vue2 vue3 提升</p>
<p>9 说说虚拟dom</p>
<p>10 排序有哪些 快排思路</p>
<p>11 闭包 ×</p>
<p>12  primose promise的使用场景  ××</p>
<p>13 ayanc awiat  以及其实现原理</p>
<p>14  遇到的困难 如何解决   </p>
<p>15 webpack的打包 具体讲一下</p>
<p>16 用过那些ts的高级语法</p>
<p>17 uniapp使用起来有什么优劣</p>
<h3 id="美团优选暑期一面"><a href="#美团优选暑期一面" class="headerlink" title="美团优选暑期一面"></a>美团优选暑期一面</h3><p>1项目  性能优化部分</p>
<p>2小程序的各种问题 </p>
<p>  a 生命周期</p>
<p>  b 网络请求</p>
<p>  c 小程序和其他的异同</p>
<p>3 promise all  promise 源码如何设计的</p>
<p>4 数组 手写fliter</p>
<p>5 深浅拷贝  手写深拷贝</p>
<p>6 udp和tcp</p>
<p>7 数组和链表的区别</p>
<p>8 进程和线程的区别</p>
<p>9 let和var的区别</p>
<p>10 css flexs属性  </p>
<p>11 隐藏一个div 有哪些方法</p>
<p>12  js数组的方法</p>
<h3 id="美团优选暑期二面"><a href="#美团优选暑期二面" class="headerlink" title="美团优选暑期二面"></a>美团优选暑期二面</h3><p>纯项目</p>
<p>1介绍错误日志上报的错误</p>
<p>  a为什么要把错误给前端来收集</p>
<p>  b了解它的下游如何工作的嘛</p>
<p>2 单点登陆</p>
<p>   什么是单点登陆  非单点登陆的情况下 如何做到安全   token为什么要经常刷新   双token-攻击者也会拿到刷新token去换</p>
<p>3 场景题 输入框联想  </p>
<p>   防抖之后 如果出现打字的特别慢会出现什么情况  如果同时发多个请求如何保证返回顺序渲染正确——-请求竞态  请求取消</p>
<h3 id="重庆云智一面"><a href="#重庆云智一面" class="headerlink" title="重庆云智一面"></a>重庆云智一面</h3><p>1直接做一道题 </p>
<p>&#x2F;&#x2F; 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p>
<p>&#x2F;&#x2F; 要求：</p>
<p>&#x2F;&#x2F; 1.找到所有出现两次的元素</p>
<p>&#x2F;&#x2F; 2.不用到任何额外空间</p>
<p>&#x2F;&#x2F; 3.在O(n)时间复杂度</p>
<p> 2 深挖项目  小程序部分深挖</p>
<p> 3 封装组件部分  </p>
<p> 4 如何调用的腾讯云接口 对象存储</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[性能优化]]></title>
      <url>/2024/03/08/%E9%9D%A2%E7%BB%8F/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h2><h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
<p>典型的CDN系统由下面三个部分组成：</p>
<ul>
<li><p><strong>分发服务系统：</strong>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</p>
</li>
<li><p><strong>负载均衡系统：</strong>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</p>
</li>
<li><p><strong>运营管理系统：</strong>运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
</li>
</ul>
<h3 id="2-CDN的作用"><a href="#2-CDN的作用" class="headerlink" title="2. CDN的作用"></a>2. CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。</p>
<p>（1）在性能方面，引入CDN的作用在于：</p>
<ul>
<li><p>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</p>
</li>
<li><p>部分资源请求分配给了CDN，减少了服务器的负载</p>
</li>
</ul>
<p>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</p>
<ul>
<li><p>针对DDoS：通过监控分析异常流量，限制其请求频率</p>
</li>
<li><p>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</p>
</li>
</ul>
<p>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</p>
<h3 id="3-CDN的原理"><a href="#3-CDN的原理" class="headerlink" title="3. CDN的原理"></a>3. CDN的原理</h3><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 <a href="http://www.test.com/">www.test.com</a> 的解析过程如下：</p>
<p>（1） 检查浏览器缓存</p>
<p>（2）检查操作系统缓存，常见的如hosts文件</p>
<p>（3）检查路由器缓存</p>
<p>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询</p>
<p>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</p>
<ul>
<li><p>根服务器返回顶级域名(TLD)服务器如<code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回<code>.com</code>的地址</p>
</li>
<li><p>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</p>
</li>
<li><p>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</p>
</li>
<li><p>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</p>
</li>
</ul>
<p><strong>CDN的工作原理：</strong></p>
<p>（1）用户未使用CDN缓存资源的过程：</p>
<ol>
<li><p>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</p>
</li>
<li><p>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</p>
</li>
<li><p>服务器向浏览器返回响应数据</p>
</li>
</ol>
<p>（2）用户使用CDN缓存资源的过程：</p>
<ol>
<li><p>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</p>
</li>
<li><p>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</p>
</li>
<li><p>用户向CDN的全局负载均衡设备发起数据请求</p>
</li>
<li><p>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</p>
</li>
<li><p>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</p>
</li>
<li><p>全局负载均衡设备把服务器的IP地址返回给用户</p>
</li>
<li><p>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</p>
</li>
</ol>
<p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p>
<p><img src="/../../images/1603966294889-153271b5-4b9f-4470-b05f-c7a9f030d043.png" alt="img"></p>
<p>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p>
<h3 id="4-CDN的使用场景"><a href="#4-CDN的使用场景" class="headerlink" title="4. CDN的使用场景"></a>4. CDN的使用场景</h3><ul>
<li><p><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</p>
</li>
<li><p><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</p>
</li>
<li><p><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</p>
</li>
</ul>
<h2 id="二、懒加载"><a href="#二、懒加载" class="headerlink" title="二、懒加载"></a>二、懒加载</h2><h3 id="1-懒加载的概念"><a href="#1-懒加载的概念" class="headerlink" title="1. 懒加载的概念"></a>1. 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p>
<p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>
<h3 id="2-懒加载的特点"><a href="#2-懒加载的特点" class="headerlink" title="2. 懒加载的特点"></a>2. 懒加载的特点</h3><ul>
<li><p><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</p>
</li>
<li><p><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</p>
</li>
<li><p><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</p>
</li>
</ul>
<h3 id="3-懒加载的实现原理"><a href="#3-懒加载的实现原理" class="headerlink" title="3. 懒加载的实现原理"></a>3. 懒加载的实现原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p>
<p>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。</p>
<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>
<p>使用原生JavaScript实现懒加载：</p>
<p><strong>知识点：</strong></p>
<p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度</p>
<p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离</p>
<p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>
<p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p>
<p><strong>图示：</strong></p>
<p><img src="/../../images/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png" alt="img"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var imgs = document.querySelectorAll(&#x27;img&#x27;);</span><br><span class="line">function lozyLoad()&#123;</span><br><span class="line">        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">        var winHeight= window.innerHeight;</span><br><span class="line">        for(var i=0;i &lt; imgs.length;i++)&#123;</span><br><span class="line">            if(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;</span><br><span class="line">                imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  window.onscroll = lozyLoad();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4-懒加载与预加载的区别"><a href="#4-懒加载与预加载的区别" class="headerlink" title="4. 懒加载与预加载的区别"></a>4. 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<ul>
<li><p><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</p>
</li>
<li><p><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong>通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p>
</li>
</ul>
<h2 id="三、回流与重绘"><a href="#三、回流与重绘" class="headerlink" title="三、回流与重绘"></a>三、回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li><p>页面的首次渲染</p>
</li>
<li><p>浏览器的窗口大小发生变化</p>
</li>
<li><p>元素的内容发生变化</p>
</li>
<li><p>元素的尺寸或者位置发生变化</p>
</li>
<li><p>元素的字体大小发生变化</p>
</li>
<li><p>激活CSS伪类</p>
</li>
<li><p>查询某些属性或者调用某些方法</p>
</li>
<li><p>添加或者删除可见的DOM元素</p>
</li>
</ul>
<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p>
<ul>
<li><p>全局范围：从根节点开始，对整个渲染树进行重新布局</p>
</li>
<li><p>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</p>
</li>
</ul>
<h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p>
<p>下面这些操作会导致重绘：</p>
<ul>
<li><p>color、background 相关属性：background-color、background-image 等</p>
</li>
<li><p>outline 相关属性：outline-color、outline-width 、text-decoration</p>
</li>
<li><p>border-radius、visibility、box-shadow</p>
</li>
</ul>
<p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p>
<h3 id="2-如何避免回流与重绘？"><a href="#2-如何避免回流与重绘？" class="headerlink" title="2. 如何避免回流与重绘？"></a>2. 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p>
<ul>
<li><p>操作DOM时，尽量在低层级的DOM节点进行操作</p>
</li>
<li><p>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</p>
</li>
<li><p>使用CSS的表达式</p>
</li>
<li><p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>
</li>
<li><p>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>
</li>
<li><p>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</p>
</li>
<li><p>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p>
</li>
<li><p>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</p>
</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-如何优化动画？"><a href="#3-如何优化动画？" class="headerlink" title="3. 如何优化动画？"></a>3. 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p>
<h3 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对<code>documentFragment</code>的解释：</p>
<p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
<p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p>
<h2 id="四、节流与防抖"><a href="#四、节流与防抖" class="headerlink" title="四、节流与防抖"></a>四、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul>
<li><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
</li>
<li><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
</li>
</ul>
<p><strong>防抖函数的应用场景：</strong></p>
<ul>
<li><p>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</p>
</li>
<li><p>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</p>
</li>
</ul>
<p><strong>节流函数的****适⽤场景：</strong></p>
<ul>
<li><p>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</p>
</li>
<li><p>缩放场景：监控浏览器resize</p>
</li>
<li><p>动画场景：避免短时间内多次触发动画引起性能问题</p>
</li>
</ul>
<h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = [...arguments];</span><br><span class="line"></span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数节流的实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 时间戳版</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = [...arguments],</span><br><span class="line">      nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定时器版</span><br><span class="line">function throttle (fun, wait)&#123;</span><br><span class="line">  let timeout = null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let context = this</span><br><span class="line">    let args = [...arguments]</span><br><span class="line">    if(!timeout)&#123;</span><br><span class="line">      timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">        fun.apply(context, args)</span><br><span class="line">        timeout = null </span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h2><h3 id="1-如何对项目中的图片进行优化？"><a href="#1-如何对项目中的图片进行优化？" class="headerlink" title="1. 如何对项目中的图片进行优化？"></a>1. 如何对项目中的图片进行优化？</h3><ol>
<li><p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</p>
</li>
<li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</p>
</li>
<li><p>小图使用 base64 格式</p>
</li>
<li><p>将多个图标文件整合到一张图片中（雪碧图）</p>
</li>
<li><p>选择正确的图片格式：</p>
</li>
</ol>
<ul>
<li></li>
<li><ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
</ul>
</li>
<li><ul>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
</ul>
</li>
<li><ul>
<li>照片使用 JPEG</li>
</ul>
</li>
</ul>
<h3 id="2-常见的图片格式及使用场景"><a href="#2-常见的图片格式及使用场景" class="headerlink" title="2. 常见的图片格式及使用场景"></a>2. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p>
<p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p>
<p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p>
<p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p>
<p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p>
<p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</p>
<p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p>
<ul>
<li><p>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</p>
</li>
<li><p>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</p>
</li>
<li><p>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</p>
</li>
</ul>
<h2 id="六、Webpack优化"><a href="#六、Webpack优化" class="headerlink" title="六、Webpack优化"></a>六、Webpack优化</h2><h3 id="1-如何提⾼webpack的打包速度"><a href="#1-如何提⾼webpack的打包速度" class="headerlink" title="1. 如何提⾼webpack的打包速度**?**"></a>1. 如何提⾼<strong>webpack</strong>的打包速度**?**</h3><h4 id="（1）优化-Loader"><a href="#（1）优化-Loader" class="headerlink" title="（1）优化 Loader"></a>（1）优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。</p>
<p>首先我们<strong>优化 Loader 的文件搜索范围</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p>
<p>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: &#x27;babel-loader?cacheDirectory=true&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="（2）HappyPack"><a href="#（2）HappyPack" class="headerlink" title="（2）HappyPack"></a>（2）HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p>
<p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: &#x27;happypack/loader?id=happybabel&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: &#x27;happybabel&#x27;,</span><br><span class="line">    loaders: [&#x27;babel-loader?cacheDirectory&#x27;],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="（3）DllPlugin"><a href="#（3）DllPlugin" class="headerlink" title="（3）DllPlugin"></a>（3）DllPlugin</h4><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 想统一打包的类库</span><br><span class="line">    vendor: [&#x27;react&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    filename: &#x27;[name].dll.js&#x27;,</span><br><span class="line">    library: &#x27;[name]-[hash]&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      // name 必须和 output.library 一致</span><br><span class="line">      name: &#x27;[name]-[hash]&#x27;,</span><br><span class="line">      // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.join(__dirname, &#x27;dist&#x27;, &#x27;[name]-manifest.json&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(&#x27;./dist/vendor-manifest.json&#x27;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（4）代码压缩"><a href="#（4）代码压缩" class="headerlink" title="（4）代码压缩"></a>（4）代码压缩</h4><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p>
<p>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p>
<h4 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h4><p>可以通过一些小的优化点来加快打包速度</p>
<ul>
<li><p><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p>
</li>
<li><p><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p>
</li>
<li><p><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p>
</li>
</ul>
<h3 id="2-如何减少-Webpack-打包体积"><a href="#2-如何减少-Webpack-打包体积" class="headerlink" title="2. 如何减少 Webpack 打包体积"></a>2. 如何减少 Webpack 打包体积</h3><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p>
<p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p>
<h4 id="（2）Scope-Hoisting"><a href="#（2）Scope-Hoisting" class="headerlink" title="（2）Scope Hoisting"></a>（2）Scope Hoisting</h4><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p>
<p>比如希望打包两个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">export const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from &#x27;./test.js&#x27;</span><br></pre></td></tr></table></figure>



<p>对于这种情况，打包出来的代码会类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  function (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（3）Tree-Shaking"><a href="#（3）Tree-Shaking" class="headerlink" title="（3）Tree Shaking"></a>（3）Tree Shaking</h4><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">export const a = 1</span><br><span class="line">export const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from &#x27;./test.js&#x27;</span><br></pre></td></tr></table></figure>



<p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p>
<p>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>
<h3 id="3-如何⽤webpack来优化前端性能？"><a href="#3-如何⽤webpack来优化前端性能？" class="headerlink" title="3. 如何⽤webpack来优化前端性能？"></a>3. 如何⽤<strong>webpack</strong>来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>
<ul>
<li><p><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</p>
</li>
<li><p><strong>利⽤<strong><strong>CDN</strong></strong>加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</p>
</li>
<li><p><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</p>
</li>
<li><p><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</p>
</li>
<li><p><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</p>
</li>
</ul>
<h3 id="4-如何提⾼webpack的构建速度？"><a href="#4-如何提⾼webpack的构建速度？" class="headerlink" title="4. 如何提⾼webpack的构建速度？"></a>4. 如何提⾼<strong>webpack</strong>的构建速度？</h3><ol>
<li><p>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</p>
</li>
<li><p>通过 externals 配置来提取常⽤库</p>
</li>
<li><p>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</p>
</li>
<li><p>使⽤ Happypack 实现多线程加速编译</p>
</li>
<li><p>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</p>
</li>
<li><p>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[js面试题]]></title>
      <url>/2024/03/08/%E9%9D%A2%E7%BB%8F/js%E5%86%9B%E5%93%A5/</url>
      <content type="html"><![CDATA[<p>##运营主业面试辅导</p>
<p><a href="https://mp.weixin.qq.com/s/TIWzYxyz0MIBeoFEa-nM8Q">https://mp.weixin.qq.com/s/TIWzYxyz0MIBeoFEa-nM8Q</a></p>
<p>零基础 </p>
<p><a href="https://mp.weixin.qq.com/s/JQYJiTCnTSp7hEBnkokg7A">https://mp.weixin.qq.com/s/JQYJiTCnTSp7hEBnkokg7A</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkxOTQzNTQzNA==&amp;mid=2247484143&amp;idx=1&amp;sn=a88ecb1813843d27cea1b093c443c082&amp;chksm=c1a3632af6d4ea3cf902fef93c97a78d36e55f529e2a5adadabda4f8f5600c9f5130e73b2696&amp;token=1569762841&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzkxOTQzNTQzNA==&amp;mid=2247484143&amp;idx=1&amp;sn=a88ecb1813843d27cea1b093c443c082&amp;chksm=c1a3632af6d4ea3cf902fef93c97a78d36e55f529e2a5adadabda4f8f5600c9f5130e73b2696&amp;token=1569762841&amp;lang=zh_CN#rd</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-null和undefined区别"><a href="#1-null和undefined区别" class="headerlink" title="1. null和undefined区别"></a>1. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h3 id="2-typeof-null-的结果是什么，为什么？"><a href="#2-typeof-null-的结果是什么，为什么？" class="headerlink" title="2. typeof null 的结果是什么，为什么？"></a>2. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p>
<p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  1: int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="line">010: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line">100: string   - 当前存储的数据指向一个字符串。</span><br><span class="line">110: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure>



<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p>
<p>有两种特殊数据类型：</p>
<ul>
<li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li>
<li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li>
</ul>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h3 id="3-intanceof-操作符的实现原理及实现"><a href="#3-intanceof-操作符的实现原理及实现" class="headerlink" title="3. intanceof 操作符的实现原理及实现"></a>3. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  // 获取对象的原型</span><br><span class="line">  let proto = Object.getPrototypeOf(left)</span><br><span class="line">  // 获取构造函数的 prototype 对象</span><br><span class="line">  let prototype = right.prototype; </span><br><span class="line"> </span><br><span class="line">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!proto) return false;</span><br><span class="line">    if (proto === prototype) return true;</span><br><span class="line">    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br><span class="line">    proto = Object.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等"><a href="#4-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等" class="headerlink" title="4. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>4. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let n1 = 0.1, n2 = 0.2</span><br><span class="line">console.log(n1 + n2)  // 0.30000000000000004</span><br></pre></td></tr></table></figure>



<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入</span><br></pre></td></tr></table></figure>



<p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p>
<p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
<p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p>
<p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p>
<p>下面看一下<strong>双精度数是如何保存</strong>的：</p>
<p><img src="/../../images/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" alt="img"></p>
<ul>
<li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li>
<li>第二部分（绿色）：用来存储指数（exponent），占用11位</li>
<li>第三部分（红色）：用来存储小数（fraction），占用52位</li>
</ul>
<p>对于0.1，它的二进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.00011001100110011001100110011001100110011001100110011001 10011...</span><br></pre></td></tr></table></figure>



<p>转为科学计数法（科学计数法的结果就是浮点数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1001100110011001100110011001100110011001100110011001*2^-4</span><br></pre></td></tr></table></figure>



<p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001100110011001100110011001100110011001100110011001</span><br></pre></td></tr></table></figure>



<p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p>
<p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p>
<ul>
<li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li>
<li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li>
<li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li>
</ul>
<p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p>
<p>所以，0.1表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1111111011 1001100110011001100110011001100110011001100110011001</span><br></pre></td></tr></table></figure>



<p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p>
<p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function numberepsilon(arg1,arg2)&#123;                   </span><br><span class="line">  return Math.abs(arg1 - arg2) &lt; Number.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">console.log(numberepsilon(0.1 + 0.2, 0.3)); // true</span><br></pre></td></tr></table></figure>



<h3 id="5-如何获取安全的-undefined-值？"><a href="#5-如何获取安全的-undefined-值？" class="headerlink" title="5. 如何获取安全的 undefined 值？"></a>5. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h3 id="6-typeof-NaN-的结果是什么？"><a href="#6-typeof-NaN-的结果是什么？" class="headerlink" title="6. typeof NaN 的结果是什么？"></a>6. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof NaN; // &quot;number&quot;</span><br></pre></td></tr></table></figure>



<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D;&#x3D; NaN 为 true。</p>
<h3 id="7-isNaN-和-Number-isNaN-函数的区别？"><a href="#7-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="7. isNaN 和 Number.isNaN 函数的区别？"></a>7. isNaN 和 Number.isNaN 函数的区别？</h3><ul>
<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ul>
<h3 id="8-JavaScript有哪些数据类型，它们的区别？"><a href="#8-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="8. JavaScript有哪些数据类型，它们的区别？"></a>8. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p>
<ul>
<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h3 id="9-数据类型检测的方式有哪些"><a href="#9-数据类型检测的方式有哪些" class="headerlink" title="9. 数据类型检测的方式有哪些"></a>9. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 2);               // number</span><br><span class="line">console.log(typeof true);            // boolean</span><br><span class="line">console.log(typeof &#x27;str&#x27;);           // string</span><br><span class="line">console.log(typeof []);              // object    </span><br><span class="line">console.log(typeof function()&#123;&#125;);    // function</span><br><span class="line">console.log(typeof &#123;&#125;);              // object</span><br><span class="line">console.log(typeof undefined);       // undefined</span><br><span class="line">console.log(typeof null);            // object</span><br></pre></td></tr></table></figure>



<p>其中数组、对象、null都会被判断为object，其他判断都正确。</p>
<p><strong>（2）instanceof</strong></p>
<p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是****判断在其原型链中能否找到该类型的原型</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(2 instanceof Number);                    // false</span><br><span class="line">console.log(true instanceof Boolean);                // false </span><br><span class="line">console.log(&#x27;str&#x27; instanceof String);                // false </span><br><span class="line"> </span><br><span class="line">console.log([] instanceof Array);                    // true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);                   // true</span><br></pre></td></tr></table></figure>



<p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
<p><strong>（3） constructor</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log((2).constructor === Number); // true</span><br><span class="line">console.log((true).constructor === Boolean); // true</span><br><span class="line">console.log((&#x27;str&#x27;).constructor === String); // true</span><br><span class="line">console.log(([]).constructor === Array); // true</span><br><span class="line">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class="line">console.log((&#123;&#125;).constructor === Object); // true</span><br></pre></td></tr></table></figure>



<p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype = new Array();</span><br><span class="line"> </span><br><span class="line">var f = new Fn();</span><br><span class="line"> </span><br><span class="line">console.log(f.constructor===Fn);    // false</span><br><span class="line">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure>



<p><strong>（4）Object.prototype.toString.call()</strong></p>
<p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line"> </span><br><span class="line">console.log(a.call(2));</span><br><span class="line">console.log(a.call(true));</span><br><span class="line">console.log(a.call(&#x27;str&#x27;));</span><br><span class="line">console.log(a.call([]));</span><br><span class="line">console.log(a.call(function()&#123;&#125;));</span><br><span class="line">console.log(a.call(&#123;&#125;));</span><br><span class="line">console.log(a.call(undefined));</span><br><span class="line">console.log(a.call(null));</span><br></pre></td></tr></table></figure>



<p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法</p>
<h3 id="10-操作符什么时候用于字符串的拼接？"><a href="#10-操作符什么时候用于字符串的拼接？" class="headerlink" title="10. + 操作符什么时候用于字符串的拼接？"></a>10. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>
<p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h3 id="11-为什么会有BigInt的提案？"><a href="#11-为什么会有BigInt的提案？" class="headerlink" title="11. 为什么会有BigInt的提案？"></a>11. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p>
<h3 id="12-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#12-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="12. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>12. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>Object.assign():</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = Object.assign(&#123;&#125;, outObj)</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="1-箭头函数的this指向哪⾥？"><a href="#1-箭头函数的this指向哪⾥？" class="headerlink" title="1. 箭头函数的this指向哪⾥？"></a>1. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
<p>可以⽤Babel理解⼀下箭头函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES6 </span><br><span class="line">const obj = &#123; </span><br><span class="line">  getArrow() &#123; </span><br><span class="line">    return () =&gt; &#123; </span><br><span class="line">      console.log(this === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转化后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5，由 Babel 转译</span><br><span class="line">var obj = &#123; </span><br><span class="line">   getArrow: function getArrow() &#123; </span><br><span class="line">     var _this = this; </span><br><span class="line">     return function () &#123; </span><br><span class="line">        console.log(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-扩展运算符的作用及使用场景"><a href="#2-扩展运算符的作用及使用场景" class="headerlink" title="2. 扩展运算符的作用及使用场景"></a>2. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p>
<p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>



<p>上述方法实际上等价于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>



<p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p>
<p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br></pre></td></tr></table></figure>



<p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p>需要注意：<strong>扩展运算符对****对象实例的拷贝属于浅拷贝</strong>。</p>
<p><strong>（2）数组扩展运算符</strong></p>
<p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line">console.log(...[1, [2, 3, 4], 5])</span><br><span class="line">// 1 [2, 3, 4] 5</span><br></pre></td></tr></table></figure>



<p>下面是数组的扩展运算符的应用：</p>
<ul>
<li><strong>将数组转换为参数序列</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line">const numbers = [1, 2];</span><br><span class="line">add(...numbers) // 3</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>复制数组</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = [...arr1];</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>合并数组</strong></li>
</ul>
<p>如果想在数组内合并数组，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&#x27;two&#x27;, &#x27;three&#x27;];</span><br><span class="line">const arr2 = [&#x27;one&#x27;, ...arr1, &#x27;four&#x27;, &#x27;five&#x27;];</span><br><span class="line">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [...rest, last] = [1, 2, 3, 4, 5];         // 报错</span><br><span class="line">const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>将字符串转为真正的数组</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...&#x27;hello&#x27;]    // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li>
</ul>
<p>比较常见的应用是可以将某些数据结构转为数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">  const args = [...arguments];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p>
<ul>
<li><strong>使用</strong><code>**Math**</code><strong>函数获取数组中特定的值</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [9, 4, 7, 1];</span><br><span class="line">Math.min(...numbers); // 1</span><br><span class="line">Math.max(...numbers); // 9</span><br></pre></td></tr></table></figure>



<h3 id="3-Proxy-可以实现什么功能？"><a href="#3-Proxy-可以实现什么功能？" class="headerlink" title="3. Proxy 可以实现什么功能？"></a>3. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p = new Proxy(target, handler)</span><br></pre></td></tr></table></figure>



<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p>
<p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      return Reflect.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">let p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    console.log(`&#x27;$&#123;property&#125;&#x27; = $&#123;target[property]&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = 2 // 监听到属性a改变</span><br><span class="line">p.a // &#x27;a&#x27; = 2</span><br></pre></td></tr></table></figure>



<p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
<h3 id="4-对对象与数组的解构的理解"><a href="#4-对对象与数组的解构的理解" class="headerlink" title="4. 对对象与数组的解构的理解"></a>4. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>
<p><strong>1）数组的解构</strong></p>
<p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c] = [1, 2, 3]</span><br></pre></td></tr></table></figure>



<p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p>
<p><img src="/../../images/1616076913177-30749c84-8254-4543-a3e7-c2fb488a4228.png" alt="img"></p>
<p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [a,,c] = [1,2,3]</span><br></pre></td></tr></table></figure>



<p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p>
<p><img src="/../../images/1616076913186-eb8be693-9b19-48e5-bda5-9dbd7cc77ea6.png" alt="img"></p>
<p><strong>2）对象的解构</strong></p>
<p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const stu = &#123;</span><br><span class="line">  name: &#x27;Bob&#x27;,</span><br><span class="line">  age: 24</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>假如想要解构它的两个自有属性，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name, age &#125; = stu</span><br></pre></td></tr></table></figure>



<p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p>
<p><img src="/../../images/1616076913314-53687a23-07ef-4a01-a78a-a0304f2b2826.png" alt="img"></p>
<p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; age, name &#125; = stu</span><br></pre></td></tr></table></figure>



<h3 id="5-如何提取高度嵌套的对象里的指定属性？"><a href="#5-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="5. 如何提取高度嵌套的对象里的指定属性？"></a>5. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const school = &#123;</span><br><span class="line">   classes: &#123;</span><br><span class="line">      stu: &#123;</span><br><span class="line">         name: &#x27;Bob&#x27;,</span><br><span class="line">         age: 24,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name &#125; = school</span><br></pre></td></tr></table></figure>



<p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; classes &#125; = school</span><br><span class="line">const &#123; stu &#125; = classes</span><br><span class="line">const &#123; name &#125; = stu</span><br><span class="line">name // &#x27;Bob&#x27;</span><br></pre></td></tr></table></figure>



<p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123; classes: &#123; stu: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line">console.log(name)  // &#x27;Bob&#x27;</span><br></pre></td></tr></table></figure>



<p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p>
<h3 id="6-对-rest-参数的理解"><a href="#6-对-rest-参数的理解" class="headerlink" title="6. 对 rest 参数的理解"></a>6. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function mutiple(...args) &#123;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (var val of args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">mutiple(1, 2, 3, 4) // 24</span><br></pre></td></tr></table></figure>



<p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function mutiple(...args) &#123;</span><br><span class="line">  console.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(1, 2, 3, 4) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>



<p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p>
<h3 id="7-ES6中模板语法与字符串处理"><a href="#7-ES6中模板语法与字符串处理" class="headerlink" title="7. ES6中模板语法与字符串处理"></a>7. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;css&#x27;   </span><br><span class="line">var career = &#x27;coder&#x27; </span><br><span class="line">var hobby = [&#x27;coding&#x27;, &#x27;writing&#x27;]</span><br><span class="line">var finalString = &#x27;my name is &#x27; + name + &#x27;, I work as a &#x27; + career + &#x27;, I love &#x27; + hobby[0] + &#x27; and &#x27; + hobby[1]</span><br></pre></td></tr></table></figure>



<p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;css&#x27;   </span><br><span class="line">var career = &#x27;coder&#x27; </span><br><span class="line">var hobby = [&#x27;coding&#x27;, &#x27;writing&#x27;]</span><br><span class="line">var finalString = `my name is $&#123;name&#125;, I work as a $&#123;career&#125; I love $&#123;hobby[0]&#125; and $&#123;hobby[1]&#125;`</span><br></pre></td></tr></table></figure>



<p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p>
<ul>
<li>在模板字符串中，空格、缩进、换行都会被保留</li>
<li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li>
</ul>
<p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let list = `</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">`;</span><br><span class="line">console.log(message); // 正确输出，不存在报错</span><br></pre></td></tr></table></figure>



<p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  const finalString = `$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`</span><br><span class="line">  console.log(finalString)</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2) // 输出 &#x27;1 + 2 = 3&#x27;</span><br></pre></td></tr></table></figure>



<p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p>
<ul>
<li><p><strong>存在性判定</strong>：在过去，当判断一个字符&#x2F;字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。 </p>
</li>
<li></li>
<li><ul>
<li><strong>includes</strong>：判断字符串与子串的包含关系：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const son = &#x27;haha&#x27; </span><br><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">father.includes(son) // true</span><br></pre></td></tr></table></figure>



<ul>
<li></li>
<li><ul>
<li><strong>startsWith</strong>：判断字符串是否以某个&#x2F;某串字符开头：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">father.startsWith(&#x27;haha&#x27;) // false</span><br><span class="line">father.startsWith(&#x27;xixi&#x27;) // true</span><br></pre></td></tr></table></figure>



<ul>
<li></li>
<li><ul>
<li><strong>endsWith</strong>：判断字符串是否以某个&#x2F;某串字符结尾：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">  father.endsWith(&#x27;hehe&#x27;) // true</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sourceCode = &#x27;repeat for 3 times;&#x27;</span><br><span class="line">const repeated = sourceCode.repeat(3) </span><br><span class="line">console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;</span><br></pre></td></tr></table></figure>



<h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<p>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null;</span><br><span class="line">  let constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断参数是否是一个函数</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>



<h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map默认情况不包含任何键，只包含显式插入的键。</td>
<td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td>
<td>Object 的键必须是 String 或是Symbol。</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代。</td>
<td>迭代Object需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong></p>
<p>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p>
<p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = [</span><br><span class="line">     [&quot;name&quot;,&quot;张三&quot;],</span><br><span class="line">     [&quot;age&quot;,18],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>Map数据结构有以下操作方法：</p>
<ul>
<li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li>
<li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
<li>**clear()**：map.clear()清除所有成员，没有返回值。</li>
</ul>
<p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历Map的所有成员。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">     [&quot;foo&quot;,1],</span><br><span class="line">     [&quot;bar&quot;,2],</span><br><span class="line">])</span><br><span class="line">for(let key of map.keys())&#123;</span><br><span class="line">    console.log(key);  // foo bar</span><br><span class="line">&#125;</span><br><span class="line">for(let value of map.values())&#123;</span><br><span class="line">     console.log(value); // 1 2</span><br><span class="line">&#125;</span><br><span class="line">for(let items of map.entries())&#123;</span><br><span class="line">    console.log(items);  // [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span><br><span class="line">&#125;</span><br><span class="line">map.forEach( (value,key,map) =&gt; &#123;</span><br><span class="line">     console.log(key,value); // foo 1    bar 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>（2）WeakMap</strong></p>
<p>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p>
<p>该对象也有以下几种方法：</p>
<ul>
<li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
</ul>
<p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p>
<p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p>
<p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p>
<p><code>WeakMap</code> 中的键（key）对对象的引用确实是弱引用，这意味着这些引用不会阻止垃圾回收器回收对象。但是，具体什么时候垃圾回收器会回收这些对象，则取决于 JavaScript 引擎的垃圾回收机制以及当前内存使用情况。</p>
<p>垃圾回收器在运行时定期运行，检查哪些对象是不再可达的（即没有强引用指向它们）。对于 <code>WeakMap</code> 的键来说，如果它们没有其他的强引用（即除了 <code>WeakMap</code> 中的引用外，没有其他变量或数据结构引用它们），那么这些对象就被认为是不可达的，垃圾回收器就可以回收它们的内存。</p>
<p><strong>总结：</strong></p>
<ul>
<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在</p>
<p>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p><strong>标准内置对象的分类：</strong></p>
<p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p>
<p>例如 Infinity、NaN、undefined、null 字面量</p>
<p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p>
<p>例如 eval()、parseFloat()、parseInt() 等</p>
<p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</p>
<p>例如 Object、Function、Boolean、Symbol、Error 等</p>
<p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</p>
<p>例如 Number、Math、Date</p>
<p>（5）字符串，用来表示和操作字符串的对象。</p>
<p>例如 String、RegExp</p>
<p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p>
<p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</p>
<p>例如 Map、Set、WeakMap、WeakSet</p>
<p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</p>
<p>例如 SIMD 等</p>
<p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</p>
<p>例如 JSON 等</p>
<p>（10）控制抽象对象</p>
<p>例如 Promise、Generator 等</p>
<p>（11）反射</p>
<p>例如 Reflect、Proxy</p>
<p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</p>
<p>例如 Intl、Intl.Collator 等</p>
<p>（13）WebAssembly</p>
<p>（14）其他</p>
<p>例如 arguments</p>
<p><strong>总结：</strong></p>
<p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p>
<h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// （1）匹配 16 进制颜色值</span><br><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line"></span><br><span class="line">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line"></span><br><span class="line">// （3）匹配 qq 号</span><br><span class="line">var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;</span><br><span class="line"></span><br><span class="line">// （4）手机号码正则</span><br><span class="line">var regex = /^1[34578]\d&#123;9&#125;$/g;</span><br><span class="line"></span><br><span class="line">// （5）用户名正则</span><br><span class="line">var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/;</span><br></pre></td></tr></table></figure>



<h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>
<p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为</p>
<p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>
<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<ul>
<li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li>
<li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>
</ul>
<h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p>
<p>一般有以下几种方式：</p>
<ul>
<li><strong>defer 属性：</strong>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li>
<li><strong>async 属性：</strong>给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li>
<li><strong>动态创建 DOM 方式：</strong>动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li>
<li><strong>使用 setTimeout 延迟方法：</strong>设置一个定时器来延迟加载js脚本文件</li>
<li><strong>让 JS 最后加载：</strong>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>
</ul>
<h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组转换为数组的方法有这样几种：</p>
<p>（1）通过 call 调用数组的 slice 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>



<p>（2）通过 call 调用数组的 splice 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br></pre></td></tr></table></figure>



<p>（3）通过 apply 调用数组的 concat 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>



<p>（4）通过 Array.from 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br></pre></td></tr></table></figure>



<h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul>
<li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li>数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
<h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p>
<ul>
<li>它是基于拉丁字母的一套电脑编码系统。</li>
<li>它定义了一个用于代表常见字符的字典。</li>
<li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li>
<li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li>
</ul>
<p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p>
<p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p>
<h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p>
<p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p>
<p><code>UTF-8</code>的编码规则：</p>
<ul>
<li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li>
<li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li>
</ul>
<p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p>
<table>
<thead>
<tr>
<th>编码范围（编号对应的十进制数）</th>
<th>二进制格式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00—0x7F （0-127）</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0x80—0x7FF （128-2047）</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x800—0xFFFF  （2048-65535）</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x10000—0x10FFFF  （65536以上）</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p>
<ul>
<li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li>
<li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li>
<li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li>
</ul>
<p>来看一个实际的例子：</p>
<p>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code></p>
<p>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code></p>
<p>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code></p>
<p>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p>
<h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p>
<p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：</p>
<p><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p>
<p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 2**<strong>16</strong></strong>-1<strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是</strong>辅助平面**，码点范围是 <code>U+10000—U+10FFFF</code>。</p>
<p><strong>2. UTF-16 概念：</strong></p>
<p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p>
<p><strong>3. UTF-16 编码规则：</strong></p>
<ul>
<li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li>
<li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li>
</ul>
<p><strong>4. 编码识别</strong></p>
<p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p>
<p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p>
<p>辅助平面共有 <strong>2****20</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p>
<p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p>
<p><strong>5. 举例说明</strong></p>
<p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p>
<ul>
<li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li>
<li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li>
<li>将得到的两个10位二进制数分别对应到两个区间中</li>
<li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li>
</ul>
<h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p>
<p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p>
<h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p>
<ul>
<li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li>
<li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li>
<li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li>
<li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li>
</ul>
<h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p>
<p>常见的位运算有以下几种：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96;</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td>各二进制位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td>
</tr>
</tbody></table>
<h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 0 = 0  </span><br><span class="line">0 &amp; 1 = 0  </span><br><span class="line">1 &amp; 0 = 0  </span><br><span class="line">1 &amp; 1 = 1</span><br></pre></td></tr></table></figure>



<p>总结：两位同时为1，结果才为1，否则结果为0。</p>
<p>例如：3&amp;5 即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0011 </span><br><span class="line">   0000 0101 </span><br><span class="line"> = 0000 0001</span><br></pre></td></tr></table></figure>



<p>因此 3&amp;5 的值为1。</p>
<p>注意：负数按补码形式参加按位与运算。</p>
<p><strong>用途：</strong></p>
<p><strong>（1）判断奇偶</strong></p>
<p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p>
<p><strong>（2）清零</strong></p>
<p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>
<h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 | 0 = 0</span><br><span class="line">0 | 1 = 1  </span><br><span class="line">1 | 0 = 1  </span><br><span class="line">1 | 1 = 1</span><br></pre></td></tr></table></figure>



<p>总结：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如：3|5即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0011</span><br><span class="line">  0000 0101 </span><br><span class="line">= 0000 0111</span><br></pre></td></tr></table></figure>



<p>因此，3|5的值为7。</p>
<p>注意：负数按补码形式参加按位或运算。</p>
<h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ^ 0 = 0  </span><br><span class="line">0 ^ 1 = 1  </span><br><span class="line">1 ^ 0 = 1  </span><br><span class="line">1 ^ 1 = 0</span><br></pre></td></tr></table></figure>



<p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p>
<p>例如：3|5即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0011</span><br><span class="line">  0000 0101 </span><br><span class="line">= 0000 0110</span><br></pre></td></tr></table></figure>



<p>因此，3^5的值为6。</p>
<p>异或运算的性质:</p>
<ul>
<li>交换律：<code>(a^b)^c == a^(b^c)</code></li>
<li>结合律：<code>(a + b)^c == a^b + b^c</code></li>
<li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li>
<li>自反性: <code>a^b^b=a^0=a</code>;</li>
</ul>
<h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p>
<p>运算规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ 1 = 0</span><br><span class="line">~ 0 = 1</span><br></pre></td></tr></table></figure>



<p>总结：对一个二进制数按位取反，即将0变1，1变0。</p>
<p>例如：~6 即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0110</span><br><span class="line">= 1111 1001</span><br></pre></td></tr></table></figure>



<p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p>
<p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0110</span><br><span class="line">   = 1111 1001</span><br><span class="line">反码：1000 0110</span><br><span class="line">补码：1000 0111</span><br></pre></td></tr></table></figure>



<p>因此，~6的值为-7。</p>
<h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p>
<p>设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。</p>
<p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>
<h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>
<p>例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p>
<p>操作数每右移一位，相当于该数除以2。</p>
<h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。</p>
<p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p>
<p><strong>（1）原码</strong></p>
<p>原码就是一个数的二进制数。</p>
<p>例如：10的原码为0000 1010</p>
<p><strong>（2）反码</strong></p>
<ul>
<li>正数的反码与原码相同，如：10 反码为 0000 1010</li>
<li>负数的反码为除符号位，按位取反，即0变1，1变0。</li>
</ul>
<p>例如：-10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码：1000 1010</span><br><span class="line">反码：1111 0101</span><br></pre></td></tr></table></figure>



<p><strong>（3）补码</strong></p>
<ul>
<li>正数的补码与原码相同，如：10 补码为 0000 1010</li>
<li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li>
</ul>
<p>例如：-10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原码：1000 1010</span><br><span class="line">反码：1111 0101</span><br><span class="line">补码：1111 0110</span><br></pre></td></tr></table></figure>



<h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p>
<p>要遍历类数组，有三个方法：</p>
<p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">  Array.prototype.forEach.call(arguments, a =&gt; console.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）使用Array.from方法将类数组转化成数组：‌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">  const arrArgs = Array.from(arguments) </span><br><span class="line">  arrArgs.forEach(a =&gt; console.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）使用展开运算符将类数组转化成数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">    const arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(a =&gt; console.log(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul>
<li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>
</ul>
<h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p>
<p>常见的类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br></pre></td></tr></table></figure>



<h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul>
<li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li>
<li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li>
<li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li>
</ul>
<h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>



<p>使用Promise封装AJAX：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>
<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<p><img src="/../../images/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png" alt="img"></p>
<h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 修改原型</span><br><span class="line">Person.prototype.getName = function() &#123;&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">console.log(p.__proto__ === Person.prototype) // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // true</span><br><span class="line">// 重写原型</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">console.log(p.__proto__ === Person.prototype)        // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // false</span><br></pre></td></tr></table></figure>



<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">p.constructor = Person</span><br><span class="line">console.log(p.__proto__ === Person.prototype)        // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // true</span><br></pre></td></tr></table></figure>



<h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.__proto__  // Person.prototype</span><br><span class="line">Person.prototype.__proto__  // Object.prototype</span><br><span class="line">p.__proto__.__proto__ //Object.prototype</span><br><span class="line">p.__proto__.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">Person.prototype.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">p1.__proto__.constructor // Person</span><br><span class="line">Person.prototype.constructor  // Person</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.__proto__  // Person.prototype</span><br><span class="line">Person.prototype.__proto__  // Object.prototype</span><br><span class="line">p.__proto__.__proto__ //Object.prototype</span><br><span class="line">p.__proto__.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">Person.prototype.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">p1.__proto__.constructor // Person</span><br><span class="line">Person.prototype.constructor  // Person</span><br></pre></td></tr></table></figure>



<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h2 id="五、执行上下文-x2F-作用域链-x2F-闭包"><a href="#五、执行上下文-x2F-作用域链-x2F-闭包" class="headerlink" title="五、执行上下文&#x2F;作用域链&#x2F;闭包"></a>五、执行上下文&#x2F;作用域链&#x2F;闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途；</p>
<ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  window.B = function () &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() // 1</span><br></pre></td></tr></table></figure>



<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<ul>
<li>第一种是使用闭包的方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  ;(function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, j * 1000)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>
<ul>
<li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    function timer(j) &#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * 1000,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
<p>（2）函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p><strong>作用域链：</strong></p>
<p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p>
<p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>
<p><strong>（2）函数执行上下文</strong></p>
<p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>
<p><strong>（3）</strong><code>**eval**</code><strong>函数执行上下文</strong></p>
<p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p>
<h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul>
<li>JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = &#x27;Hello World!&#x27;;</span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&#x27;Inside first function&#x27;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&#x27;Again inside first function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&#x27;Inside second function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">//执行顺序</span><br><span class="line">//先执行second(),在执行first()</span><br></pre></td></tr></table></figure>



<h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<p><strong>1）创建阶段</strong></p>
<p>（1）this绑定</p>
<ul>
<li>在全局执行上下文中，this指向全局对象（window对象）</li>
<li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
<p>（2）创建词法环境组件</p>
<ul>
<li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li>
<li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>
</ul>
<p>（3）创建变量环境组件</p>
<ul>
<li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>
</ul>
<p><strong>2）执行阶段</strong></p>
<p>此阶段会完成对变量的分配，最后执行完代码。</p>
<p><strong>简单来说执行上下文就是指：</strong></p>
<p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>
<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>
</ul>
<h2 id="六、this-x2F-call-x2F-apply-x2F-bind"><a href="#六、this-x2F-call-x2F-apply-x2F-bind" class="headerlink" title="六、this&#x2F;call&#x2F;apply&#x2F;bind"></a>六、this&#x2F;call&#x2F;apply&#x2F;bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<ul>
<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ul>
<h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  let args = [...arguments].slice(1),</span><br><span class="line">    result = null;</span><br><span class="line">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用函数</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>（2）apply 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用方法</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>（3）bind 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">    fn = this;</span><br><span class="line">  return function Fn() &#123;</span><br><span class="line">    // 根据调用方式，传入不同绑定值</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p>
<ul>
<li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li>
<li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li>
<li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li>
<li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>
</ul>
<h3 id="2-setTimeout、Promise、Async-x2F-Await-的区别"><a href="#2-setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async&#x2F;Await 的区别"></a>2. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;) //1. 打印 script start</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)   // 4. 打印 settimeout</span><br><span class="line">&#125;)  // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="line">console.log(&#x27;script end&#x27;)   //3. 打印 script start</span><br><span class="line">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></pre></td></tr></table></figure>



<h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">let promise1 = new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(&#x27;promise1 end&#x27;)</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></pre></td></tr></table></figure>



<p>当JS主线程执行到Promise对象时：</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<h4 id="（3）async-x2F-await"><a href="#（3）async-x2F-await" class="headerlink" title="（3）async&#x2F;await"></a>（3）async&#x2F;await</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">   console.log(&#x27;async1 start&#x27;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">async1();</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></pre></td></tr></table></figure>



<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function func1() &#123;</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(func1())</span><br></pre></td></tr></table></figure>



<p><img src="/../../images/1604021075237-8249a8df-3a28-4bca-9f22-02923aba8618.png" alt="img"></p>
<p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);  // 30</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
<h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>（1）Promise的实例有<strong>三个状态</strong>:</p>
<ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成）</li>
<li>Rejected（已拒绝）</li>
</ul>
<p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
<p>（2）Promise的实例有<strong>两个过程</strong>：</p>
<ul>
<li>pending -&gt; fulfilled : Resolved（已完成）</li>
<li>pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>
<p><strong>Promise的特点：</strong></p>
<ul>
<li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p><strong>Promise的缺点：</strong></p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p><strong>总结：</strong></p>
<p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p>
<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<p><strong>注意：</strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>一般情况下都会使用</strong><code>**new Promise()**</code><strong>来创建promise对象，但是也可以使用</strong><code>**promise.resolve**</code><strong>和</strong> <code>**promise.reject**</code><strong>这两个方法：</strong></p>
<ul>
<li><strong>Promise.resolve</strong></li>
</ul>
<p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(11).then(function(value)&#123;</span><br><span class="line">  console.log(value); // 打印出11</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p>
<p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p>
<ul>
<li><strong>Promise.reject</strong></li>
</ul>
<p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(new Error(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure>



<p>就是下面的代码new Promise的简单形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">   reject(new Error(&quot;我错了，请原谅俺！！&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>下面是使用resolve方法和reject方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function testPromise(ready) &#123;</span><br><span class="line">  return new Promise(function(resolve,reject)&#123;</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">      resolve(&quot;hello world&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      reject(&quot;No thanks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">// 方法调用</span><br><span class="line">testPromise(true).then(function(msg)&#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p>
<h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li><strong>then()</strong></li>
</ol>
<p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p>
<p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p>
<p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    ajax(&#x27;first&#x27;).success(function(res)&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p>
<p><strong>2. catch()</strong></p>
<p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;,(err) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>3. all()</strong></p>
<p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(1);</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    //结果为：[1,2,3] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p>
<p><strong>（4）race()</strong></p>
<p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       reject(1);</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    //结果：2</span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    console.log(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>5. finally()</strong></p>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>



<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>



<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./a.txt&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">  fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">    fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>上面的代码有如下缺点：</p>
<ul>
<li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p><code>Promise</code>出现之后，代码变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">function read(url)&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(url,&#x27;utf8&#x27;,function(error,data)&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read(&#x27;./a.txt&#x27;).then(data=&gt;&#123;</span><br><span class="line">  return read(data) </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  return read(data)  </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p>
<h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）****Promise.all</strong></p>
<p><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p>
<p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>
<p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
<p><strong>（2）Promise.race</strong></p>
<p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p><strong>回收机制</strong>：</p>
<ul>
<li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
<h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p>
<p><strong>1）标记清除</strong></p>
<ul>
<li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p><strong>2）引用计数</strong></p>
<ul>
<li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code>obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">    let obj1 = &#123;&#125;;</span><br><span class="line">    let obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; // obj1 引用 obj2</span><br><span class="line">    obj2.a = obj1; // obj2 引用 obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种情况下，就要手动释放变量占用的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.a =  null</span><br><span class="line"> obj2.a =  null</span><br></pre></td></tr></table></figure>



<h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li><strong>对</strong><code>**object**</code><strong>进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
<h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[网络部分的面试题]]></title>
      <url>/2024/03/08/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="一、TCP与UDP"><a href="#一、TCP与UDP" class="headerlink" title="一、TCP与UDP"></a>一、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p>
<p><strong>（1）UDP</strong></p>
<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它的特点如下：</p>
<p><strong>1）面向无连接</strong></p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<p><strong>2）有单播，多播，广播的功能</strong></p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<p><strong>3）面向报文</strong></p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<p><strong>4）不可靠性</strong></p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong></p>
<p><img src="/../../images/1604023358917-72134998-53bd-4d9c-b71f-7a762dff31a9.png" alt="img"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>
<p><strong>（2）TCP</strong></p>
<p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>
<p>它有以下几个特点：</p>
<p><strong>1）面向连接</strong></p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<p><strong>2）仅支持单播传输</strong></p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<p><strong>3）面向字节流</strong></p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<p><strong>4）可靠传输</strong></p>
<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p><strong>5）提供拥塞控制</strong></p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>
<p><strong>6）提供全双工通信</strong></p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul>
<li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p>
<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>
<ul>
<li>慢启动（慢开始）</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p><strong>（1）慢启动（慢开始）</strong></p>
<ul>
<li><p>在开始发送的时候设置cwnd &#x3D; 1（cwnd指的是拥塞窗口） </p>
</li>
<li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。 </p>
</li>
<li><p>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) </p>
</li>
<li></li>
<li><ul>
<li>当cnwd &lt; ssthresh，使用慢开始算法</li>
<li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>
</ul>
</li>
</ul>
<p><strong>（2）拥塞避免</strong></p>
<ul>
<li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。 </li>
<li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一 </li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br>  <img src="/../../images/1604022952123-62276cba-d882-46c9-8a1c-70655dc501af.png" alt="img"> </li>
<li>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li>
</ul>
<p><strong>（3）快速重传</strong></p>
<ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>
</ul>
<p><strong>（4）快速恢复</strong></p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="/../../images/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png" alt="img"></li>
</ul>
<h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<ul>
<li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li>
<li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li>
<li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li>
<li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li>
</ul>
<h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
<h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img src="/../../images/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png" alt="img"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>
</ul>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
<ul>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
</ul>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p>
<ul>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<p><strong>简单来说就是以下三步：</strong></p>
<ul>
<li><strong>第一次握手：</strong>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
<li><strong>第二次握手：</strong>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
<li><strong>第三次握手：</strong>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><img src="/../../images/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png" alt="img"></p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<ul>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<ul>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<ul>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p><strong>那为什么需要四次挥手呢？</strong></p>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
<p><strong>简单来说就是以下四步：</strong></p>
<ul>
<li><strong>第一次<strong><strong>挥手</strong></strong>：</strong>若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次****挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次<strong><strong>挥手</strong></strong>：</strong>客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>
<h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理**?**"></a>10. <strong>TCP</strong>粘包是怎么回事，如何处理**?**</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p>
<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p>
<p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p>
<p>A. 先接收到 data1, 然后接收到 data2 .</p>
<p>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.</p>
<p>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.</p>
<p>D. ⼀次性接收到了 data1 和 data2 的全部数据.</p>
<p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p>
<ul>
<li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li>
<li><strong>关闭</strong> <strong>Nagle</strong> <strong>算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li>
<li><strong>进⾏封包</strong><strong>&#x2F;拆包：</strong>封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li>
</ul>
<h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul>
<li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li>
</ul>
<h2 id="二、WebSocket"><a href="#二、WebSocket" class="headerlink" title="二、WebSocket"></a>二、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>
<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>
<p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p>
<p><strong>WebSocket 特点的如下：</strong></p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据‘’</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<p><strong>Websocket的使用方法如下：</strong></p>
<p>在客户端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br><span class="line">let ws = new WebSocket(&#x27;ws://localhost:9999&#x27;);</span><br><span class="line">// 在客户端与服务端建立连接后触发</span><br><span class="line">ws.onopen = function() &#123;</span><br><span class="line">    console.log(&quot;Connection open.&quot;); </span><br><span class="line">    ws.send(&#x27;hello&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 在服务端给客户端发来消息的时候触发</span><br><span class="line">ws.onmessage = function(res) &#123;</span><br><span class="line">    console.log(res);       // 打印的是MessageEvent对象</span><br><span class="line">    console.log(res.data);  // 打印的是收到的消息</span><br><span class="line">&#125;;</span><br><span class="line">// 在客户端与服务端建立关闭后触发</span><br><span class="line">ws.onclose = function(evt) &#123;</span><br><span class="line">  console.log(&quot;Connection closed.&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>
<p><strong>短轮询的基本思路：</strong>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>
<p><strong>长轮询的基本思路：</strong>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<p><strong>SSE 的基本思想：</strong>服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p>
<p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>
<p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p>
<p>对于这四种即使通信协议，从性能的角度来看：</p>
<p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p>
<p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p>
<p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p>
<p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>
<h2 id="三、HTTP协议"><a href="#三、HTTP协议" class="headerlink" title="三、HTTP协议"></a>三、HTTP协议</h2><h3 id="1-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#1-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="1. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>1. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</p>
<ul>
<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h3 id="2-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#2-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="2. HTTP 1.1 和 HTTP 2.0 的区别"></a>2. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong>HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong>HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong>HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<p><strong>【1】队头堵塞：</strong></p>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
<h3 id="3-HTTP和HTTPS协议的区别"><a href="#3-HTTP和HTTPS协议的区别" class="headerlink" title="3. HTTP和HTTPS协议的区别"></a>3. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="4-GET和POST的请求的区别"><a href="#4-GET和POST的请求的区别" class="headerlink" title="4. GET和POST的请求的区别"></a>4. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong>因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>发送的报文格式：</strong>Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>安全性：</strong>Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong>post 的参数传递支持更多的数据类型。</li>
</ul>
<h3 id="5-POST和PUT请求的区别"><a href="#5-POST和PUT请求的区别" class="headerlink" title="5. POST和PUT请求的区别"></a>5. POST和PUT请求的区别</h3><ul>
<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li>
<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>
</ul>
<h3 id="6-常见的HTTP请求头和响应头"><a href="#6-常见的HTTP请求头和响应头" class="headerlink" title="6. 常见的HTTP请求头和响应头"></a>6. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p>
<ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p><strong>HTTP Responses Header 常见的响应头：</strong></p>
<ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<p>常见的 Content-Type 属性值有以下四种：</p>
<p>（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据。</p>
<h3 id="7-HTTP状态码304是多好还是少好"><a href="#7-HTTP状态码304是多好还是少好" class="headerlink" title="7. HTTP状态码304是多好还是少好"></a>7. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>
<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>
<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>
<p><strong>产生较多304状态码的原因：</strong></p>
<ul>
<li>页面更新周期长或不更新</li>
<li>纯静态页面或强制生成静态html</li>
</ul>
<p><strong>304状态码出现过多会造成以下问题：</strong></p>
<ul>
<li>网站快照停止；</li>
<li>收录减少；</li>
<li>权重下降。</li>
</ul>
<h3 id="8-常见的HTTP请求方法"><a href="#8-常见的HTTP请求方法" class="headerlink" title="8. 常见的HTTP请求方法"></a>8. 常见的HTTP请求方法</h3><ul>
<li>GET: 向服务器获取数据；</li>
<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>
<li>PUT：上传文件，更新数据；</li>
<li>DELETE：删除服务器上的对象；</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>
<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>
</ul>
<h3 id="9-OPTIONS请求方法及使用场景"><a href="#9-OPTIONS请求方法及使用场景" class="headerlink" title="9. OPTIONS请求方法及使用场景"></a>9. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>
<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</p>
<p>IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）</span><br></pre></td></tr></table></figure>



<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>
<ul>
<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li>
<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li>
<li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li>
<li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li>
<li>Google (chrome)：URL最大长度限制为 8182 个字符。</li>
</ul>
<p>主流的服务器对get方法中url的长度限制范围：</p>
<ul>
<li>Apache (Server)：能接受最大url长度为8192个字符。</li>
<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li>
</ul>
<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="11-URL有哪些组成部分"><a href="#11-URL有哪些组成部分" class="headerlink" title="11 URL有哪些组成部分"></a>11 URL有哪些组成部分</h3><p>以下面的URL为例：<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name"><strong>http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name</strong></a></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h3 id="12-与缓存相关的HTTP请求头有哪些"><a href="#12-与缓存相关的HTTP请求头有哪些" class="headerlink" title="12. 与缓存相关的HTTP请求头有哪些"></a>12. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p>
<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
<p>协商缓存：</p>
<ul>
<li>Etag、If-None-Match</li>
<li>Last-Modified、If-Modified-Since</li>
</ul>
<h2 id="四、HTTPS协议"><a href="#四、HTTPS协议" class="headerlink" title="四、HTTPS协议"></a>四、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><img src="/../../images/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png" alt="img"></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>
<h3 id="2-TLS-x2F-SSL的工作原理"><a href="#2-TLS-x2F-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h3><p><strong>TLS&#x2F;SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>基于散列函数验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商</li>
</ul>
<p><img src="/../../images/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" alt="img"></p>
<h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p>
<p><strong>特点：</strong>在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p>
<h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p>
<p><strong>特点：</strong>对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>
<h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>
<p><strong>特点：</strong>非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p>
<p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p>
<h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<p><img src="/../../images/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png" alt="img"></p>
<h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p>
<ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p>
<ul>
<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>
<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>
</ul>
<p>HTTPS的<strong>缺点</strong>如下：</p>
<ul>
<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>
<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高；</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>
<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>
</ul>
<h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p>
<ul>
<li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</li>
<li>⾮对称加密：</li>
</ul>
<p>\1. 私钥 + 公钥&#x3D; 密钥对</p>
<p>\2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</p>
<p>\3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</p>
<p>\4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</p>
<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p>
<p><strong>解决⽅案：</strong></p>
<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p>
<p>此时⼜带来⼀个问题，中间⼈问题：</p>
<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。</p>
<p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>
<p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。</p>
<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</p>
<h2 id="五、HTTP状态码"><a href="#五、HTTP状态码" class="headerlink" title="五、HTTP状态码"></a>五、HTTP状态码</h2><p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p>
<h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p>
<h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p>
<h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong></p>
<p>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
<h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong></p>
<p>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>
<li>未登陆的用户访问用户中心重定向到登录页面。</li>
<li>访问404页面重新定向到首页。</li>
</ul>
<h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p>303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p>
<p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p>
<p>注意：</p>
<ul>
<li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li>
<li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li>
</ul>
<h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong></p>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p>
<p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p>
<p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p>
<h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p>
<p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p>
<h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
<h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p>
<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p>以下情况会出现401：</p>
<ul>
<li>401.1 - 登录失败。</li>
<li>401.2 - 服务器配置导致登录失败。</li>
<li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li>
<li>401.4 - 筛选器授权失败。</li>
<li>401.5 - ISAPI&#x2F;CGI 应用程序授权失败。</li>
<li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p>
<p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p>
<ul>
<li>403.1 - 执行访问被禁止。</li>
<li>403.2 - 读访问被禁止。</li>
<li>403.3 - 写访问被禁止。</li>
<li>403.4 - 要求 SSL。</li>
<li>403.5 - 要求 SSL 128。</li>
<li>403.6 - IP 地址被拒绝。</li>
<li>403.7 - 要求客户端证书。</li>
<li>403.8 - 站点访问被拒绝。</li>
<li>403.9 - 用户数过多。</li>
<li>403.10 - 配置无效。</li>
<li>403.11 - 密码更改。</li>
<li>403.12 - 拒绝访问映射表。</li>
<li>403.13 - 客户端证书被吊销。</li>
<li>403.14 - 拒绝目录列表。</li>
<li>403.15 - 超出客户端访问许可。</li>
<li>403.16 - 客户端证书不受信任或无效。</li>
<li>403.17 - 客户端证书已过期或尚未生效</li>
<li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<p>以下情况会出现404：</p>
<ul>
<li>404.0 -（无） – 没有找到文件或目录。</li>
<li>404.1 - 无法在所请求的端口上访问 Web 站点。</li>
<li>404.2 - Web 服务扩展锁定策略阻止本请求。</li>
<li>404.3 - MIME 映射策略阻止本请求。</li>
</ul>
<h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure>



<h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p>
<h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p>
<ul>
<li>502.1 - CGI （通用网关接口）应用程序超时。</li>
<li>502.2 - CGI （通用网关接口）应用程序出错。</li>
</ul>
<h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>服务器停机维护时，主动用503响应请求；</li>
<li>nginx 设置限速，超过限速，会返回503。</li>
</ul>
<h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p>
<p>使用场景：代码执行时间超时，或者发生了死循环。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<p><strong>（2）3XX 重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<p><strong>（3）4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<p><strong>（4）5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。</p>
<h2 id="六、DNS协议介绍"><a href="#六、DNS协议介绍" class="headerlink" title="六、DNS协议介绍"></a>六、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
<h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p>
<p>（1）在区域传输的时候使用TCP协议</p>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。</li>
</ul>
<p>（2）在域名解析的时候使用UDP协议</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
<h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p>
<ul>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
</ul>
<p>比如要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（Name，Value，Type，TTL）</span><br></pre></td></tr></table></figure>



<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p>
<ul>
<li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<h2 id="七、网络模型"><a href="#七、网络模型" class="headerlink" title="七、网络模型"></a>七、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。</p>
<p><img src="/../../images/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp" alt="img"></p>
<h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>
<ul>
<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li>
<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li>
<li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>
</ul>
<h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>
<h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>
<h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>
<h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>
<h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p><strong>OSI七层模型通信特点：对等通信</strong></p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<h3 id="2-TCP-x2F-IP五层协议"><a href="#2-TCP-x2F-IP五层协议" class="headerlink" title="2. TCP&#x2F;IP五层协议"></a>2. TCP&#x2F;IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下：</p>
<p><img src="/../../images/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png" alt="img"></p>
<p><img src="/../../images/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png" alt="img"></p>
<ul>
<li><p>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。 </p>
</li>
<li><p>**传输层 (transport layer)**：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议： </p>
</li>
<li></li>
<li><ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li><p>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。 </p>
</li>
<li><p>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。 </p>
</li>
<li><p>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p>
</li>
</ul>
<p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p>
<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src="/../../images/1604025001463-47398363-0ab1-4bcf-b247-5d3d76ce117a.webp" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：</p>
<p><img src="/../../images/1604025001203-7b104c36-1453-475e-a282-ff2e9cb19e2c.webp" alt="img"></p>
<p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：</p>
<p><img src="/../../images/1604065635582-1a4e62ba-bdfa-45db-8a56-0302ff9a8020.png" alt="img"></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器面试题]]></title>
      <url>/2024/03/08/%E9%9D%A2%E7%BB%8F/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li><p>获取页面的数据，如DOM、cookie、localStorage；</p>
</li>
<li><p>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</p>
</li>
<li><p>破坏页面结构；</p>
</li>
<li><p>流量劫持（将链接指向某网站）；</p>
</li>
</ul>
<h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li><p>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</p>
</li>
<li><p>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</p>
</li>
<li><p>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</p>
</li>
</ul>
<p><strong>1）存储型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li><p>攻击者将恶意代码提交到⽬标⽹站的数据库中。</p>
</li>
<li><p>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p>
</li>
<li><p>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</p>
</li>
<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>
</li>
</ol>
<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
<p><strong>2）反射型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>
</li>
<li><p>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</p>
</li>
<li><p>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</p>
</li>
<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>
</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>
<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>
<p><strong>3）DOM</strong> <strong>型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong></p>
<ol>
<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>
</li>
<li><p>⽤户打开带有恶意代码的 URL。</p>
</li>
<li><p>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</p>
</li>
<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>
</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>
<h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li><p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>
</li>
<li><p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>
</li>
</ul>
<ol>
<li><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p>
</li>
<li><p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式</p>
</li>
</ol>
<ul>
<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>
</ul>
<h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是****利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>
<ul>
<li><p>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</p>
</li>
<li><p>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p>
</li>
<li><p>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p>
</li>
</ul>
<h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><p><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</p>
</li>
<li><p><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</p>
</li>
<li><p><strong>对</strong> <strong>Cookie 进行****双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>
</li>
<li><p><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>
</li>
</ul>
<h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下:</p>
<ul>
<li><p>客户端发送请求到服务端，请求被中间⼈截获</p>
</li>
<li><p>服务器向客户端发送公钥</p>
</li>
<li><p>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</p>
</li>
<li><p>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</p>
</li>
<li><p>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</p>
</li>
<li><p>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</p>
</li>
</ul>
<h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题**?**"></a>6. 有哪些可能引起前端安全的问题**?**</h3><ul>
<li><p>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等；</p>
</li>
<li><p>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</p>
</li>
<li><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</p>
</li>
<li><p>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</p>
</li>
</ul>
<h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p>
<p>（1）<strong>DNS****劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p>
<ul>
<li><p>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</p>
</li>
<li><p>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</p>
</li>
</ul>
<p>（2）<strong>HTTP****劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li><p>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p>
</li>
<li><p>线程是进程中的更小单位，描述了执行一段指令所需的时间。</p>
</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>
<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
<p><strong>（2）线程之间共享进程中的数据。</strong></p>
<p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p><strong>（4）进程之间的内容相互隔离。</strong>进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>
<p><strong>Chrome浏览器的架构图</strong>：</p>
<p><img src="/../../images/1603803289911-191cabf3-e7e2-4354-a83d-858668cc116f.png" alt="img"></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li><p>1 个浏览器主进程</p>
</li>
<li><p>1 个 GPU 进程</p>
</li>
<li><p>1 个网络进程</p>
</li>
<li><p>多个渲染进程</p>
</li>
<li><p>多个插件进程</p>
</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><p><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>
</li>
<li><p><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>
</li>
<li><p><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><p><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</p>
</li>
<li><p><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</p>
</li>
</ul>
<h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul>
<li><p>进程可以看做独立应用，线程不能</p>
</li>
<li><p>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</p>
</li>
<li><p>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</p>
</li>
<li><p>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
</li>
<li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</p>
</li>
</ul>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><img src="/../../images/1603803289922-6462f252-aa33-4cf6-b541-d8bc2e285125.png" alt="img"></p>
<p><strong>（1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）时间触发线程</strong></p>
<p><strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li><p>XMLHttpRequest连接后通过浏览器新开一个线程请求；</p>
</li>
<li><p>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</p>
</li>
</ul>
<h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p>
<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p>管道的特点：</p>
<ul>
<li><p>只能单向通信</p>
</li>
<li><p>只能血缘关系的进程进行通信</p>
</li>
<li><p>依赖于文件系统</p>
</li>
<li><p>生命周期随进程</p>
</li>
<li><p>面向字节流的服务</p>
</li>
<li><p>管道内部提供了同步机制</p>
</li>
</ul>
<p><strong>（2）消息队列通信</strong></p>
<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<p><strong>（3）信号量通信</strong></p>
<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<p><strong>（4）信号通信</strong></p>
<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
<p><strong>（5）共享内存通信</strong></p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><strong>（6）套接字通信</strong></p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>
<li><p><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
</li>
<li><p><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p>
</li>
</ul>
<h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li><p>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</p>
</li>
<li><p>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</p>
</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li><p>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
</li>
<li><p>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li><p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p>
</li>
<li><p>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p>
</li>
<li><p>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</p>
</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li><p>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</p>
</li>
<li><p>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</p>
</li>
<li><p>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</p>
</li>
<li><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
</li>
</ul>
<h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
<ul>
<li><p><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p>
</li>
<li><p><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</p>
</li>
<li><p><strong>使****用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</p>
</li>
<li><p><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</p>
</li>
</ul>
<h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#x27;sw.js&#x27;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#x27;service worker 注册成功&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#x27;servcie worker 注册失败&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// sw.js</span><br><span class="line">// 监听 `install` 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#x27;install&#x27;, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#x27;my-cache&#x27;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#x27;./index.html&#x27;, &#x27;./index.js&#x27;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line">// 拦截所有请求事件</span><br><span class="line">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#x27;fetch source&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：</p>
<p><img src="/../../images/1615478097248-5e3c9a93-5683-41de-8787-e87705d31fe1.png" alt="img"></p>
<p>在 Cache 中也可以发现所需的文件已被缓存：</p>
<p><img src="/../../images/1615477994804-e7eaa2c7-91bf-406d-b024-5add76d37d5e.png" alt="img"></p>
<h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>
<ul>
<li><p>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</p>
</li>
<li><p>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</p>
</li>
<li><p>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</p>
</li>
<li><p>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</p>
</li>
<li><p>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</p>
</li>
</ul>
<p><img src="/../../images/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png" alt="img"></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>
<ol>
<li><p><strong>Service Worker：</strong>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></p>
</li>
<li><p><strong>Memory Cache：</strong>Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
</li>
<li><p><strong>Disk Cache：</strong>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>
</li>
</ol>
<p><strong>Disk Cache：</strong>Push Cache 是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong>其具有以下特点：</p>
<ul>
<li><p>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</p>
</li>
<li><p>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</p>
</li>
<li><p>一旦连接被关闭，Push Cache 就被释放</p>
</li>
<li><p>多个页面可以使用相同的 HTTP&#x2F;2 连接，也就是说能使用同样的缓存</p>
</li>
<li><p>Push Cache 中的缓存只能被使用一次</p>
</li>
<li><p>浏览器可以拒绝接受已经存在的资源推送</p>
</li>
<li><p>可以给其他域名推送资源</p>
</li>
</ul>
<h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p><code>Cache-Control</code>可设置的字段：</p>
<ul>
<li><p><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age&#x3D;来精确控制；</p>
</li>
<li><p><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</p>
</li>
<li><p><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</p>
</li>
<li><p><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</p>
</li>
<li><p><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</p>
</li>
<li><p><code>s-maxage=</code>：优先级高于max-age&#x3D;，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</p>
</li>
<li><p><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</p>
</li>
</ul>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p><strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li><p>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</p>
</li>
<li><p>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</p>
</li>
</ul>
<h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p>上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li><p><code>max-age=xxx</code> 过期了</p>
</li>
<li><p>值为<code>no-store</code></p>
</li>
</ul>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <strong>Etag</strong> 和 <strong>Last-Modified</strong> 属性。</p>
<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>
<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li><p>减少了服务器的负担，提高了网站的性能</p>
</li>
<li><p>加快了客户端网页的加载速度</p>
</li>
<li><p>减少了多余网络数据传输</p>
</li>
</ul>
<h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li><p><strong>点击刷新按钮或者按 F5：</strong>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</p>
</li>
<li><p><strong>用户按 Ctrl+F5（强制刷新）：</strong>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</p>
</li>
<li><p>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</p>
</li>
</ul>
<h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>
<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>
<ul>
<li><p>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</p>
</li>
<li><p>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</p>
</li>
</ul>
<h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>
<ul>
<li><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p>
</li>
<li><p>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</p>
</li>
</ul>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul>
<li><p><strong>Trident：</strong>这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p>
</li>
<li><p><strong>Gecko：</strong>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p>
</li>
<li><p><strong>Presto：</strong>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p>
</li>
<li><p><strong>Webkit：</strong>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</p>
</li>
<li><p><strong>Blink：</strong>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</p>
</li>
</ul>
<h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p>
<p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p>
<p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p>
<p>（4） Safari 浏览器内核：Webkit 内核；</p>
<p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p>
<p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p>
<p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p>
<p>（8） 百度浏览器、世界之窗内核：IE 内核；</p>
<p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p>
<p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p>
<h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul>
<li><p><strong>⽤户界⾯</strong> - 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。</p>
</li>
<li><p><strong>浏览器引擎</strong> - 在⽤户界⾯和呈现引擎之间传送指令。</p>
</li>
<li><p><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</p>
</li>
<li><p><strong>⽹络</strong> - ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。</p>
</li>
<li><p><strong>⽤户界⾯后端</strong> - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。</p>
</li>
<li><p><strong>JavaScript</strong> <strong>解释器</strong>。⽤于解析和执⾏ JavaScript 代码。</p>
</li>
<li><p><strong>数据存储</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</p>
</li>
</ul>
<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>
<h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li><p>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</p>
</li>
<li><p>然后对 CSS 进行解析，生成 CSSOM 规则树。</p>
</li>
<li><p>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p>
</li>
<li><p>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p>
</li>
<li><p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p>
</li>
</ul>
<p>大致过程如图所示：</p>
<p><img src="/../../images/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305-17098305024006.png" alt="img"></p>
<p><strong>注意：</strong>这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<p>（1）尽量将JavaScript文件放在body的最后</p>
<p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p>
<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
<ul>
<li><p><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</p>
</li>
<li><p><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</p>
</li>
<li><p><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</p>
</li>
</ul>
<p><strong>（2）针对CSS：</strong>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li><p><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</p>
</li>
<li><p><a href=""><strong>@import</strong> </a> ：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</p>
</li>
<li><p><strong>style</strong>：GUI直接渲染</p>
</li>
</ul>
<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p><strong>（3）针对DOM树、CSSOM树：</strong></p>
<p>可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li><p>HTML文件的代码层级尽量不要太深</p>
</li>
<li><p>使用语义化的标签，来避免不标准语义化的特殊处理</p>
</li>
<li><p>减少CSSD代码的层级，因为选择器是从左向右进行解析的</p>
</li>
</ul>
<p><strong>（4）减少回流与重绘：</strong></p>
<ul>
<li><p>操作DOM时，尽量在低层级的DOM节点进行操作</p>
</li>
<li><p>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</p>
</li>
<li><p>使用CSS的表达式</p>
</li>
<li><p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>
</li>
<li><p>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>
</li>
<li><p>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</p>
</li>
<li><p>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p>
</li>
<li><p>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</p>
</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<p>（1）关键资源的数量。</p>
<p>（2）关键路径长度。</p>
<p>（3）关键字节的数量。</p>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>
<p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>
<p>（3）优化关键字节数以缩短下载时间（往返次数）。</p>
<p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li><p>Cookie一旦创建成功，名称就无法修改</p>
</li>
<li><p>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</p>
</li>
<li><p>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</p>
</li>
<li><p>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</p>
</li>
<li><p>Cookie在请求一个新的页面的时候都会被发送过去</p>
</li>
</ul>
<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li><p>使用Nginx反向代理</p>
</li>
<li><p>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</p>
</li>
</ol>
<p><strong>Cookie的使用场景：</strong></p>
<ul>
<li><p>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</p>
</li>
<li><p>可以用来统计页面的点击次数</p>
</li>
</ul>
<h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li><p>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</p>
</li>
<li><p>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</p>
</li>
<li><p>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</p>
</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li><p>存在浏览器兼容问题，IE8以下版本的浏览器不支持</p>
</li>
<li><p>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</p>
</li>
<li><p>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</p>
</li>
</ul>
<p><strong>LocalStorage的****常用API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据到 localStorage</span><br><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 获取数据</span><br><span class="line">let data = localStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除保存的数据</span><br><span class="line">localStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 localStorage 删除所有保存的数据</span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">localStorage.key(index)</span><br></pre></td></tr></table></figure>



<p><strong>LocalStorage的****使用场景：</strong></p>
<ul>
<li><p>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</p>
</li>
<li><p>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</p>
</li>
</ul>
<h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage****与LocalStorage对比：</strong></p>
<ul>
<li><p>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</p>
</li>
<li><p>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</p>
</li>
<li><p>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</p>
</li>
</ul>
<p><strong>SessionStorage的****常用API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据到 sessionStorage</span><br><span class="line">sessionStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 获取数据</span><br><span class="line">let data = sessionStorage.getItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除保存的数据</span><br><span class="line">sessionStorage.removeItem(&#x27;key&#x27;);</span><br><span class="line"></span><br><span class="line">// 从 sessionStorage 删除所有保存的数据</span><br><span class="line">sessionStorage.clear();</span><br><span class="line"></span><br><span class="line">// 获取某个索引的Key</span><br><span class="line">sessionStorage.key(index)</span><br></pre></td></tr></table></figure>



<p><strong>SessionStorage的****使用场景</strong></p>
<ul>
<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
<h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>
<ul>
<li><p><strong>Name</strong>：cookie的名称</p>
</li>
<li><p><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</p>
</li>
<li><p><strong>Size</strong>： cookie的大小</p>
</li>
<li><p><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</p>
</li>
<li><p><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</p>
</li>
<li><p><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</p>
</li>
<li><p><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</p>
</li>
<li><p><strong>Expires&#x2F;Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li><p><strong>cookie：</strong>其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p>
</li>
<li><p><strong>sessionStorage：</strong>html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p>
</li>
<li><p><strong>localStorage：</strong>html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</p>
</li>
</ul>
<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li><p>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</p>
</li>
<li><p>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</p>
</li>
<li><p>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</p>
</li>
<li><p>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</p>
</li>
<li><p>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</p>
</li>
</ul>
<h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li><p><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
</li>
<li><p><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
</li>
<li><p><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
</li>
<li><p><strong>同源限制：</strong>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
</li>
<li><p><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
</li>
<li><p><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
</li>
</ul>
<h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>
<p>下表给出了与 URL <a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a></td>
<td>同源</td>
<td>完全相同</td>
</tr>
<tr>
<td><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td>
<td>同源</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td>
<td>跨域</td>
<td>协议不同</td>
</tr>
<tr>
<td><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td>
<td>跨域</td>
<td>端口不同 ( http:&#x2F;&#x2F; 默认端口是80)</td>
</tr>
<tr>
<td><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td>
<td>跨域</td>
<td>主机不同</td>
</tr>
</tbody></table>
<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>
<p><strong>同源政策主要限制了三个方面：</strong></p>
<ul>
<li><p>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
</li>
<li><p>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p>
</li>
<li><p>当前域下 ajax 无法发送跨域请求。</p>
</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p>
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p>
<p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>
<p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>
<p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>
<p><strong>1）请求方法是以下三种方法之一：</strong></p>
<ul>
<li><p>HEAD</p>
</li>
<li><p>GET</p>
</li>
<li><p>POST</p>
</li>
</ul>
<p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p>
<ul>
<li><p>Accept</p>
</li>
<li><p>Accept-Language</p>
</li>
<li><p>Content-Language</p>
</li>
<li><p>Last-Event-ID</p>
</li>
<li><p>Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</p>
</li>
</ul>
<p>若不满足以上条件，就属于非简单请求了。</p>
<p><strong>（1）简单请求过程：</strong></p>
<p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值</span><br><span class="line">Content-Type: text/html; charset=utf-8   // 表示文档类型</span><br></pre></td></tr></table></figure>



<p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>
<p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>**Access-Control-Allow-Origin**</code></p>
<p><strong>（2）非简单请求过程</strong></p>
<p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>
<p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>
<p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>
<ul>
<li><p><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</p>
</li>
<li><p><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</p>
</li>
</ul>
<p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>
<p>服务器回应的CORS的字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段</span><br><span class="line">Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒</span><br></pre></td></tr></table></figure>



<p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p><strong>在非简单请求中，至少需要设置以下字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Access-Control-Allow-Origin&#x27;  </span><br><span class="line">&#x27;Access-Control-Allow-Methods&#x27;</span><br><span class="line">&#x27;Access-Control-Allow-Headers&#x27;</span><br></pre></td></tr></table></figure>



<h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li><strong>在请求中设置</strong> <code>**withCredentials**</code></li>
</ul>
<p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 原生 xml 的设置方式</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// axios 设置方式</span><br><span class="line">axios.defaults.withCredentials = true;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Access-Control-Allow-Credentials 设置为 true</strong></p>
</li>
<li><p><strong>Access-Control-Allow-Origin 设置为非</strong> <code>*****</code></p>
</li>
</ul>
<h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<p>1）原生JS实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;;</span><br><span class="line">    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">    // 回调执行函数</span><br><span class="line">    function handleCallback(res) &#123;</span><br><span class="line">        alert(JSON.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br></pre></td></tr></table></figure>



<p>2）Vue axios实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.$http = axios;</span><br><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>后端node.js代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var querystring = require(&#x27;querystring&#x27;);</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var params = querystring.parse(req.url.split(&#x27;?&#x27;)[1]);</span><br><span class="line">    var fn = params.callback;</span><br><span class="line">    // jsonp返回设置</span><br><span class="line">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/javascript&#x27; &#125;);</span><br><span class="line">    res.write(fn + &#x27;(&#x27; + JSON.stringify(params) + &#x27;)&#x27;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br></pre></td></tr></table></figure>



<p><strong>JSONP的缺点：</strong></p>
<ul>
<li><p>具有局限性， 仅支持get方法</p>
</li>
<li><p>不安全，可能会遭受XSS攻击</p>
</li>
</ul>
<h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li><p>页面和其打开的新窗口的数据传递</p>
</li>
<li><p>多窗口之间消息传递</p>
</li>
<li><p>页面与嵌套的iframe消息传递</p>
</li>
<li><p>上面三个场景的跨域数据传递</p>
</li>
</ul>
<p>用法：postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li><p><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</p>
</li>
<li><p><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</p>
</li>
</ul>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &#x27;aym&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http://www.domain2.com&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain2 ---&gt; &#x27; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>2）b.html：(domain2.com&#x2F;b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<p>1）nginx配置解决iconfont跨域</p>
<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）nginx反向代理接口跨域</p>
<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>
<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>
<p>nginx具体配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p><strong>1）非vue框架的跨域</strong></p>
<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<ul>
<li>前端代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:3000/login?user=admin&#x27;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>



<ul>
<li>中间件服务器代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(&#x27;/&#x27;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &#x27;http://www.domain2.com:8080&#x27;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#x27;Proxy server is listen at port 3000...&#x27;);</span><br></pre></td></tr></table></figure>



<p><strong>2）vue框架的跨域</strong></p>
<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &#x27;/login&#x27;,</span><br><span class="line">            target: &#x27;http://www.domain2.com:8080&#x27;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1）父窗口：(domain.com&#x2F;a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    var user = &#x27;admin&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>1）子窗口：(child.domain.com&#x2F;a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    console.log(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &#x27;#user=admin&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&#x27;data from c.html ---&gt; &#x27; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>2）b.html：(.domain2.com&#x2F;b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>3）c.html：(<a href="https://link.zhihu.com/?target=http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&#x27;hello: &#x27; + location.hash.replace(&#x27;#user=&#x27;, &#x27;&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &#x27;http://www.domain1.com/proxy.html&#x27;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&#x27;&#x27;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&#x27;http://www.domain2.com/b.html&#x27;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>2）proxy.html：(domain1.com&#x2F;proxy.html)</p>
<p>中间代理页，与a.html同域，内容为空即可。</p>
<p>3）b.html：(domain2.com&#x2F;b.html)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &#x27;This is domain2 data!&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1）前端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&#x27;http://www.domain2.com:8080&#x27;);</span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&#x27;connect&#x27;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        console.log(&#x27;data from server: ---&gt; &#x27; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&#x27;disconnect&#x27;, function() &#123; </span><br><span class="line">        console.log(&#x27;Server socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>2）Nodejs socket后台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var socket = require(&#x27;socket.io&#x27;);</span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;Content-type&#x27;: &#x27;text/html&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&#x27;connection&#x27;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        client.send(&#x27;hello：&#x27; + msg);</span><br><span class="line">        console.log(&#x27;data from client: ---&gt; &#x27; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&#x27;disconnect&#x27;, function() &#123;</span><br><span class="line">        console.log(&#x27;Client socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul>
<li><strong>正向代理：</strong></li>
</ul>
<p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>
<ul>
<li><strong>反向代理：</strong></li>
</ul>
<p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。</p>
<p>一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>
<p>两者区别如图示：</p>
<p><img src="/../../images/1605256274960-50bd9e69-dde9-4782-b2c0-6afc8188fca2.jpeg" alt="img"></p>
<p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>
<h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>
<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>
<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>
<h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li><p><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</p>
</li>
<li><p><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p>
</li>
<li><p><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p>
</li>
</ul>
<h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul>
<li><p>普通浏览器使用：event.stopPropagation()</p>
</li>
<li><p>IE浏览器使用：event.cancelBubble &#x3D; true;</p>
</li>
</ul>
<h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
<h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul>
<li><strong>减少内存消耗</strong></li>
</ul>
<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>



<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
<ul>
<li><strong>动态绑定事件</strong></li>
</ul>
<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span><br><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  // 判断是否匹配目标元素</span><br><span class="line">  if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li><p>元素中，绑定事件委托的次数；</p>
</li>
<li><p>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</p>
</li>
</ul>
<p>在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li><p>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</p>
</li>
<li><p>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</p>
</li>
<li><p>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</p>
</li>
</ul>
<h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    if (e.target.nodeName == &quot;A&quot;)</span><br><span class="line">        console.log(&quot;a&quot;);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>



<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">    var node = e.target;</span><br><span class="line">    while (node.parentNode.nodeName != &quot;BODY&quot;) &#123;</span><br><span class="line">        if (node.nodeName == &quot;A&quot;) &#123;</span><br><span class="line">            console.log(&quot;a&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>



<h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul>
<li><p><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</p>
</li>
<li><p><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p>
</li>
</ul>
<h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>
<p><img src="/../../images/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png" alt="img"></p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li><p>首先执行同步代码，这属于宏任务</p>
</li>
<li><p>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</p>
</li>
<li><p>执行所有微任务</p>
</li>
<li><p>当执行完所有微任务后，如有必要会渲染页面</p>
</li>
<li><p>然后开始下一轮 Event Loop，执行宏任务中的异步代码</p>
</li>
</ul>
<h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul>
<li><p>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p>
</li>
<li><p>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I&#x2F;O 操作、UI 渲染等。</p>
</li>
</ul>
<h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p>
<p><img src="/../../images/1615476375478-4f0a93a1-de5e-4536-9bbe-4e69c1f91773.gif" alt="img"></p>
<p>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>
<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  throw new Error(&#x27;error&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>



<p><img src="/../../images/1615476375462-269c6a54-a21d-460c-aa82-a713ef9a2999.png" alt="img"></p>
<p>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>



<p><img src="/../../images/1615476375388-2867ba62-cf27-4740-91fd-485f0ae12986.png" alt="img"></p>
<h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src="/../../images/1615476641904-a9763034-9114-4a7c-aa50-1bdb612f2f5e.png" alt="img"></p>
<p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p>
<p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I &#x2F; O回调（系统调用相关的回调）。</p>
<p>（3）<strong>Idle&#x2F;Prepare</strong>：仅供内部使用。</p>
<p>（4）<strong>Poll（轮询阶段）</strong>：</p>
<ul>
<li><p>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</p>
</li>
<li><p>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I&#x2F;O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</p>
</li>
</ul>
<p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p>
<p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p>
<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li><p>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</p>
</li>
<li><p>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</p>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[手写mian'shi'ti]]></title>
      <url>/2024/03/08/%E9%9D%A2%E7%BB%8F/%E6%89%8B%E5%86%99%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>实现步骤：</p>
<ol>
<li><p>首先获取类型的原型</p>
</li>
<li><p>然后获得对象的原型</p>
</li>
<li><p>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></p>
</li>
</ol>
<p>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let proto = Object.getPrototypeOf(left), // 获取对象的原型</span><br><span class="line">      prototype = right.prototype; // 获取构造函数的 prototype 对象</span><br><span class="line"></span><br><span class="line">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!proto) return false;</span><br><span class="line">    if (proto === prototype) return true;</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null;</span><br><span class="line">  let constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断参数是否是一个函数</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>



<h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const RESOLVED = &quot;resolved&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  // 保存初始化状态</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // 初始化状态</span><br><span class="line">  this.state = PENDING;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 或者 rejected 传入的值</span><br><span class="line">  this.value = null;</span><br><span class="line"></span><br><span class="line">  // 用于保存 resolve 的回调函数</span><br><span class="line">  this.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 用于保存 reject 的回调函数</span><br><span class="line">  this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  // 状态转变为 resolved 方法</span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变，</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.resolvedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 状态转变为 rejected 方法</span><br><span class="line">  function reject(value) &#123;</span><br><span class="line">    // 保证代码的执行顺序为本轮事件循环的末尾</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 只有状态为 pending 时才能转变</span><br><span class="line">      if (self.state === PENDING) &#123;</span><br><span class="line">        // 修改状态</span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        // 设置传入的值</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        // 执行回调函数</span><br><span class="line">        self.rejectedCallbacks.forEach(callback =&gt; &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将两个方法传入函数执行</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // 遇到错误时，捕获错误，执行 reject 函数</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(onResolved, onRejected) &#123;</span><br><span class="line">  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br><span class="line">  onResolved =</span><br><span class="line">    typeof onResolved === &quot;function&quot;</span><br><span class="line">      ? onResolved</span><br><span class="line">      : function(value) &#123;</span><br><span class="line">          return value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &quot;function&quot;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : function(error) &#123;</span><br><span class="line">          throw error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  // 如果是等待状态，则将函数加入对应列表中</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.resolvedCallbacks.push(onResolved);</span><br><span class="line">    this.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果状态已经凝固，则直接执行对应状态的函数</span><br><span class="line"></span><br><span class="line">  if (this.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.state === REJECTED) &#123;</span><br><span class="line">    onRejected(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-手写-Promise-then"><a href="#5-手写-Promise-then" class="headerlink" title="5. 手写 Promise.then"></a>5. 手写 Promise.then</h3><p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> &#x2F; <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。</p>
<p><strong>那么，怎么保证后一个</strong> <code>**then**</code> <strong>里的方法在前一个</strong> <code>**then**</code><strong>（可能是异步）结束之后再执行呢？</strong></p>
<p>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p>
<ul>
<li><p>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</p>
</li>
<li><p>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onReject)&#123;</span><br><span class="line">    // 保存前一个promise的this</span><br><span class="line">    const self = this; </span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 封装前一个promise成功时执行的函数</span><br><span class="line">      let fulfilled = () =&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          const result = onFulfilled(self.value); // 承前</span><br><span class="line">          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后</span><br><span class="line">        &#125;catch(err)&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 封装前一个promise失败时执行的函数</span><br><span class="line">      let rejected = () =&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          const result = onReject(self.reason);</span><br><span class="line">          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);</span><br><span class="line">        &#125;catch(err)&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      switch(self.status)&#123;</span><br><span class="line">        case PENDING: </span><br><span class="line">          self.onFulfilledCallbacks.push(fulfilled);</span><br><span class="line">          self.onRejectedCallbacks.push(rejected);</span><br><span class="line">          break;</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilled();</span><br><span class="line">          break;</span><br><span class="line">        case REJECT:</span><br><span class="line">          rejected();</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li><p>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</p>
</li>
<li><p>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调</p>
</li>
</ul>
<h3 id="6-手写-Promise-all"><a href="#6-手写-Promise-all" class="headerlink" title="6. 手写 Promise.all"></a>6. 手写 Promise.all</h3><p><strong>1) 核心思路</strong></p>
<ol>
<li><p>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</p>
</li>
<li><p>这个方法返回一个新的 promise 对象，</p>
</li>
<li><p>遍历传入的参数，用Promise.resolve()将参数”包一层”，使其变成一个promise对象</p>
</li>
<li><p>参数所有回调成功才是成功，返回值数组与参数顺序一致</p>
</li>
<li><p>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</p>
</li>
</ol>
<p><strong>2）实现代码</strong></p>
<p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function promiseAll(promises) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if(!Array.isArray(promises))&#123;</span><br><span class="line">        throw new TypeError(`argument must be a array`)</span><br><span class="line">    &#125;</span><br><span class="line">    var resolvedCounter = 0;</span><br><span class="line">    var promiseNum = promises.length;</span><br><span class="line">    var resolvedResult = [];</span><br><span class="line">    for (let i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      Promise.resolve(promises[i]).then(value=&gt;&#123;</span><br><span class="line">        resolvedCounter++;</span><br><span class="line">        resolvedResult[i] = value;</span><br><span class="line">        if (resolvedCounter == promiseNum) &#123;</span><br><span class="line">            return resolve(resolvedResult)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,error=&gt;&#123;</span><br><span class="line">        return reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// test</span><br><span class="line">let p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        resolve(3)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">promiseAll([p3, p1, p2]).then(res =&gt; &#123;</span><br><span class="line">    console.log(res) // [3, 1, 2]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="7-手写-Promise-race"><a href="#7-手写-Promise-race" class="headerlink" title="7. 手写 Promise.race"></a>7. 手写 Promise.race</h3><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.race = function (args) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    for (let i = 0, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">      args[i].then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-手写防抖函数"><a href="#8-手写防抖函数" class="headerlink" title="8. 手写防抖函数"></a>8. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let context = this,</span><br><span class="line">        args = arguments;</span><br><span class="line"></span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-手写节流函数"><a href="#9-手写节流函数" class="headerlink" title="9. 手写节流函数"></a>9. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  let curTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let context = this,</span><br><span class="line">        args = arguments,</span><br><span class="line">        nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - curTime &gt;= delay) &#123;</span><br><span class="line">      curTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-手写类型判断函数"><a href="#10-手写类型判断函数" class="headerlink" title="10. 手写类型判断函数"></a>10. 手写类型判断函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getType(value) &#123;</span><br><span class="line">  // 判断数据是 null 的情况</span><br><span class="line">  if (value === null) &#123;</span><br><span class="line">    return value + &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断数据是引用类型的情况</span><br><span class="line">  if (typeof value === &quot;object&quot;) &#123;</span><br><span class="line">    let valueClass = Object.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);</span><br><span class="line">    type.pop();</span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 判断数据是基本数据类型的情况和函数的情况</span><br><span class="line">    return typeof value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-手写-call-函数"><a href="#11-手写-call-函数" class="headerlink" title="11. 手写 call 函数"></a>11. 手写 call 函数</h3><p>call 函数的实现步骤：</p>
<ol>
<li><p>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
</li>
<li><p>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p>
</li>
<li><p>处理传入的参数，截取第一个参数后的所有参数。</p>
</li>
<li><p>将函数作为上下文对象的一个属性。</p>
</li>
<li><p>使用上下文对象来调用这个方法，并保存返回结果。</p>
</li>
<li><p>删除刚才新增的属性。</p>
</li>
<li><p>返回结果。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// call函数实现</span><br><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  let args = [...arguments].slice(1),</span><br><span class="line">      result = null;</span><br><span class="line">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用函数</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="12-手写-apply-函数"><a href="#12-手写-apply-函数" class="headerlink" title="12. 手写 apply 函数"></a>12. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p>
<ol>
<li><p>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
</li>
<li><p>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p>
</li>
<li><p>将函数作为上下文对象的一个属性。</p>
</li>
<li><p>判断参数值是否传入</p>
</li>
<li><p>使用上下文对象来调用这个方法，并保存返回结果。</p>
</li>
<li><p>删除刚才新增的属性</p>
</li>
<li><p>返回结果</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// apply 函数实现</span><br><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用方法</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="13-手写-bind-函数"><a href="#13-手写-bind-函数" class="headerlink" title="13. 手写 bind 函数"></a>13. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p>
<ol>
<li><p>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
</li>
<li><p>保存当前函数的引用，获取其余传入参数值。</p>
</li>
<li><p>创建一个函数返回</p>
</li>
<li><p>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// bind 函数实现</span><br><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">      fn = this;</span><br><span class="line">  return function Fn() &#123;</span><br><span class="line">    // 根据调用方式，传入不同绑定值</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="14-函数柯里化的实现"><a href="#14-函数柯里化的实现" class="headerlink" title="14. 函数柯里化的实现"></a>14. 函数柯里化的实现</h3><p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line"></span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">      // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es6 实现</span><br><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-实现AJAX请求"><a href="#15-实现AJAX请求" class="headerlink" title="15. 实现AJAX请求"></a>15. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><p><strong>创建一个 XMLHttpRequest 对象。</strong></p>
</li>
<li><p>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p>
</li>
<li><p>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</p>
</li>
<li><p>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, SERVER_URL, true);</span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>



<h3 id="16-使用Promise封装AJAX请求"><a href="#16-使用Promise封装AJAX请求" class="headerlink" title="16. 使用Promise封装AJAX请求"></a>16. 使用Promise封装AJAX请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-实现浅拷贝"><a href="#17-实现浅拷贝" class="headerlink" title="17. 实现浅拷贝"></a>17. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p>
<h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</li>
<li><p>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</p>
</li>
<li><p>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;a: 1&#125;;</span><br><span class="line">let object2 = &#123;b: 2&#125;;</span><br><span class="line">let object3 = &#123;c: 3&#125;;</span><br><span class="line">Object.assign(target,object2,object3);  </span><br><span class="line">console.log(target);  // &#123;a: 1, b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line">let obj2 = &#123;...obj1&#125;;</span><br><span class="line">obj1.a = 2;</span><br><span class="line">console.log(obj1); //&#123;a:2,b:&#123;c:1&#125;&#125;</span><br><span class="line">console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line">obj1.b.c = 2;</span><br><span class="line">console.log(obj1); //&#123;a:2,b:&#123;c:2&#125;&#125;</span><br><span class="line">console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul>
<li><p><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</p>
</li>
<li><p>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.slice()); // [1,2,3,4]</span><br><span class="line">console.log(arr.slice() === arr); //false</span><br></pre></td></tr></table></figure>



<h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul>
<li><p><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
</li>
<li><p>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.concat()); // [1,2,3,4]</span><br><span class="line">console.log(arr.concat() === arr); //false</span><br></pre></td></tr></table></figure>



<h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 浅拷贝的实现;</span><br><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;// 浅拷贝的实现;</span><br><span class="line"></span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;// 浅拷贝的实现;</span><br><span class="line">function shallowCopy(object) &#123;</span><br><span class="line">  // 只拷贝对象</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line">  // 根据 object 的类型判断是新建一个数组还是对象</span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  // 遍历 object，并且判断是 object 的属性才拷贝</span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="18-实现深拷贝"><a href="#18-实现深拷贝" class="headerlink" title="18. 实现深拷贝"></a>18. 实现深拷贝</h3><ul>
<li><p><strong>浅拷贝：</strong>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</p>
</li>
<li><p><strong>深拷贝：</strong>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</p>
</li>
</ul>
<h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul>
<li><p><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</p>
</li>
<li><p>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;  a: 0,</span><br><span class="line">              b: &#123;</span><br><span class="line">                 c: 0</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 1;</span><br><span class="line">obj1.b.c = 1;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br></pre></td></tr></table></figure>



<h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝的实现</span><br><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        typeof object[key] === &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dateFormat(new Date(&#x27;2020-12-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/12/01</span><br><span class="line">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy/MM/dd&#x27;) // 2020/04/01</span><br><span class="line">dateFormat(new Date(&#x27;2020-04-01&#x27;), &#x27;yyyy年MM月dd日&#x27;) // 2020年04月01日</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const dateFormat = (dateInput, format)=&gt;&#123;</span><br><span class="line">    var day = dateInput.getDate() </span><br><span class="line">    var month = dateInput.getMonth() + 1  </span><br><span class="line">    var year = dateInput.getFullYear()   </span><br><span class="line">    format = format.replace(/yyyy/, year)</span><br><span class="line">    format = format.replace(/MM/,month)</span><br><span class="line">    format = format.replace(/dd/,day)</span><br><span class="line">    return format</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure>



<h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p>
<ul>
<li><p>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</p>
</li>
<li><p>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</p>
</li>
<li><p>按照上面的规律执行，直到遍历完成</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;</span><br><span class="line">  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>



<p>还有一方法就是倒序遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">let length = arr.length,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp;</span><br><span class="line">  while (length) &#123;</span><br><span class="line">    randomIndex = Math.floor(Math.random() * length--);</span><br><span class="line">    temp = arr[length];</span><br><span class="line">    arr[length] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>



<h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul>
<li>arr&#x3D;[1,2,3,4,5,6,7,8,9,10]，求和</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">let sum = arr.reduce( (total,i) =&gt; total += i,0);</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<ul>
<li>arr&#x3D;[1,2,3,[[4,5],6],7,8,9]，求和</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var = arr=[1,2,3,[[4,5],6],7,8,9]</span><br><span class="line">let arr= arr.toString().split(&#x27;,&#x27;).reduce( (total,i) =&gt; total += Number(i),0);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>



<p>递归实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5, 6] </span><br><span class="line"></span><br><span class="line">function add(arr) &#123;</span><br><span class="line">    if (arr.length == 1) return arr[0] </span><br><span class="line">    return arr[0] + add(arr.slice(1)) </span><br><span class="line">&#125;</span><br><span class="line">console.log(add(arr)) // 21</span><br></pre></td></tr></table></figure>



<h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p>
<p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<p><strong>（2）reduce 函数迭代</strong></p>
<p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<p><strong>（3）扩展运算符实现</strong></p>
<p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<p><strong>（4）split 和 toString</strong></p>
<p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p>
<p><strong>（5）****ES6 中的 flat</strong></p>
<p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p>
<p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。</p>
<p><strong>（6）正则和 JSON 方法</strong></p>
<p>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>



<h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p>
<p>ES6方法（使用数据结构集合）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]</span><br></pre></td></tr></table></figure>



<p>ES5方法：使用map存储不重复的数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">uniqueArray(array); // [1, 2, 3, 5, 9, 8]</span><br><span class="line"></span><br><span class="line">function uniqueArray(array) &#123;</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  let res = [];</span><br><span class="line">  for(var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if(!map.hasOwnProperty([array[i]])) &#123;</span><br><span class="line">      map[array[i]] = 1;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function _flat(arr, depth) &#123;</span><br><span class="line">  if(!Array.isArray(arr) || depth &lt;= 0) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(cur)) &#123;</span><br><span class="line">      return prev.concat(_flat(cur, depth - 1))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return prev.concat(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">Array.prototype.push = function() &#123;</span><br><span class="line">    for( let i = 0 ; i &lt; arguments.length ; i++)&#123;</span><br><span class="line">        this[this.length] = arguments[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._filter = function(fn) &#123;</span><br><span class="line">    if (typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const res = [];</span><br><span class="line">    for (let i = 0, len = this.length; i &lt; len; i++) &#123;</span><br><span class="line">        fn(this[i]) &amp;&amp; res.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._map = function(fn) &#123;</span><br><span class="line">   if (typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">        throw Error(&#x27;参数必须是一个函数&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const res = [];</span><br><span class="line">    for (let i = 0, len = this.length; i &lt; len; i++) &#123;</span><br><span class="line">        res.push(fn(this[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function repeat(s, n) &#123;</span><br><span class="line">    return (new Array(n + 1)).join(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function repeat(s, n) &#123;</span><br><span class="line">    return (n &gt; 0) ? s.concat(repeat(s, --n)) : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String.prototype._reverse = function(a)&#123;</span><br><span class="line">    return a.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new String();</span><br><span class="line">var res = obj._reverse (&#x27;hello&#x27;);</span><br><span class="line">console.log(res);    // olleh</span><br></pre></td></tr></table></figure>



<p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p>
<h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let format = n =&gt; &#123;</span><br><span class="line">    let num = n.toString() // 转成字符串</span><br><span class="line">    let decimals = &#x27;&#x27;</span><br><span class="line">        // 判断是否有小数</span><br><span class="line">    num.indexOf(&#x27;.&#x27;) &gt; -1 ? decimals = num.split(&#x27;.&#x27;)[1] : decimals</span><br><span class="line">    let len = num.length</span><br><span class="line">    if (len &lt;= 3) &#123;</span><br><span class="line">        return num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let temp = &#x27;&#x27;</span><br><span class="line">        let remainder = len % 3</span><br><span class="line">        decimals ? temp = &#x27;.&#x27; + decimals : temp</span><br><span class="line">        if (remainder &gt; 0) &#123; // 不是3的整数倍</span><br><span class="line">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp</span><br><span class="line">        &#125; else &#123; // 是3的整数倍</span><br><span class="line">            return num.slice(0, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">format(12323.33)  // &#x27;12,323.33&#x27;</span><br></pre></td></tr></table></figure>



<p><strong>数字无小数版本：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let format = n =&gt; &#123;</span><br><span class="line">    let num = n.toString() </span><br><span class="line">    let len = num.length</span><br><span class="line">    if (len &lt;= 3) &#123;</span><br><span class="line">        return num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let remainder = len % 3</span><br><span class="line">        if (remainder &gt; 0) &#123; // 不是3的整数倍</span><br><span class="line">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) </span><br><span class="line">        &#125; else &#123; // 是3的整数倍</span><br><span class="line">            return num.slice(0, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">format(1232323)  // &#x27;1,232,323&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE // 1.7976931348623157e+308</span><br><span class="line">Number.MAX_SAFE_INTEGER // 9007199254740991</span><br><span class="line">Number.MIN_VALUE // 5e-324</span><br><span class="line">Number.MIN_SAFE_INTEGER // -9007199254740991</span><br></pre></td></tr></table></figure>



<p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p>
<p>实现一个算法进行大数的相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sumBigNumber(a, b) &#123;</span><br><span class="line">  let res = &#x27;&#x27;;</span><br><span class="line">  let temp = 0;</span><br><span class="line">  </span><br><span class="line">  a = a.split(&#x27;&#x27;);</span><br><span class="line">  b = b.split(&#x27;&#x27;);</span><br><span class="line">  </span><br><span class="line">  while (a.length || b.length || temp) &#123;</span><br><span class="line">    temp += ~~a.pop() + ~~b.pop();</span><br><span class="line">    res = (temp % 10) + res;</span><br><span class="line">    temp  = temp &gt; 9</span><br><span class="line">  &#125;</span><br><span class="line">  return res.replace(/^0+/, &#x27;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其主要的思路如下：</p>
<ul>
<li><p>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</p>
</li>
<li><p>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</p>
</li>
<li><p>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</p>
</li>
<li><p>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</p>
</li>
<li><p>重复上述操作，直至计算结束</p>
</li>
</ul>
<h3 id="13-实现-add-1-2-3"><a href="#13-实现-add-1-2-3" class="headerlink" title="13. 实现 add(1)(2)(3)"></a>13. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>1）粗暴版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add (a) &#123;</span><br><span class="line">return function (b) &#123;</span><br><span class="line">    return function (c) &#123;</span><br><span class="line">      return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1)(2)(3)); // 6</span><br></pre></td></tr></table></figure>



<p>2）柯里化解决方案</p>
<ul>
<li>参数长度固定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add = function (m) &#123;</span><br><span class="line">  var temp = function (n) &#123;</span><br><span class="line">    return add(m + n);</span><br><span class="line">  &#125;</span><br><span class="line">  temp.toString = function () &#123;</span><br><span class="line">    return m;</span><br><span class="line">  &#125;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(add(3)(4)(5)); // 12</span><br><span class="line">console.log(add(3)(6)(9)(25)); // 43</span><br></pre></td></tr></table></figure>



<p>对于add(3)(4)(5)，其执行过程如下：</p>
<ol>
<li><p>先执行add(3)，此时m&#x3D;3，并且返回temp函数；</p>
</li>
<li><p>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)&#x3D;add(3+4)&#x3D;add(7)，此时m&#x3D;7，并且返回temp函数</p>
</li>
<li><p>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)&#x3D;add(7+5)&#x3D;add(12)，此时m&#x3D;12，并且返回temp函数</p>
</li>
<li><p>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m&#x3D;12，所以返回值是12。</p>
</li>
</ol>
<ul>
<li>参数长度不固定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function add (...args) &#123;</span><br><span class="line">    //求和</span><br><span class="line">    return args.reduce((a, b) =&gt; a + b)</span><br><span class="line">&#125;</span><br><span class="line">function currying (fn) &#123;</span><br><span class="line">    let args = []</span><br><span class="line">    return function temp (...newArgs) &#123;</span><br><span class="line">        if (newArgs.length) &#123;</span><br><span class="line">            args = [</span><br><span class="line">                ...args,</span><br><span class="line">                ...newArgs</span><br><span class="line">            ]</span><br><span class="line">            return temp</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let val = fn.apply(this, args)</span><br><span class="line">            args = [] //保证再次调用时清空</span><br><span class="line">            return val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let addCurry = currying(add)</span><br><span class="line">console.log(addCurry(1)(2)(3)(4, 5)())  //15</span><br><span class="line">console.log(addCurry(1)(2)(3, 4, 5)())  //15</span><br><span class="line">console.log(addCurry(1)(2, 3, 4, 5)())  //15</span><br></pre></td></tr></table></figure>



<h3 id="14-实现类数组转化为数组"><a href="#14-实现类数组转化为数组" class="headerlink" title="14. 实现类数组转化为数组"></a>14. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>



<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br></pre></td></tr></table></figure>



<h3 id="15-使用-reduce-求和"><a href="#15-使用-reduce-求和" class="headerlink" title="15. 使用 reduce 求和"></a>15. 使用 reduce 求和</h3><p>arr &#x3D; [1,2,3,4,5,6,7,8,9,10]，求和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">arr.reduce((prev, cur) =&gt; &#123; return prev + cur &#125;, 0)</span><br></pre></td></tr></table></figure>



<p>arr &#x3D; [1,2,3,[[4,5],6],7,8,9]，求和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">arr.flat(Infinity).reduce((prev, cur) =&gt; &#123; return prev + cur &#125;, 0)</span><br></pre></td></tr></table></figure>



<p>arr &#x3D; [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123;a:9, b:3, c:4&#125;, &#123;a:1, b:3&#125;, &#123;a:3&#125;] </span><br><span class="line"></span><br><span class="line">arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">    return prev + cur[&quot;a&quot;];</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>



<h3 id="16-将js对象转化为树形结构"><a href="#16-将js对象转化为树形结构" class="headerlink" title="16. 将js对象转化为树形结构"></a>16. 将js对象转化为树形结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 转换前：</span><br><span class="line">source = [&#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            pid: 0,</span><br><span class="line">            name: &#x27;body&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 3,</span><br><span class="line">            pid: 2,</span><br><span class="line">            name: &#x27;div&#x27;</span><br><span class="line">          &#125;]</span><br><span class="line">// 转换为: </span><br><span class="line">tree = [&#123;</span><br><span class="line">          id: 1,</span><br><span class="line">          pid: 0,</span><br><span class="line">          name: &#x27;body&#x27;,</span><br><span class="line">          children: [&#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;,</span><br><span class="line">            children: [&#123;</span><br><span class="line">              id: 3,</span><br><span class="line">              pid: 1,</span><br><span class="line">              name: &#x27;div&#x27;</span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure>



<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function jsonToTree(data) &#123;</span><br><span class="line">  // 初始化结果数组，并判断输入数据的格式</span><br><span class="line">  let result = []</span><br><span class="line">  if(!Array.isArray(data)) &#123;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用map，将当前对象的id与当前对象对应存储起来</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    map[item.id] = item;</span><br><span class="line">  &#125;);</span><br><span class="line">  // </span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    let parent = map[item.pid];</span><br><span class="line">    if(parent) &#123;</span><br><span class="line">      (parent.children || (parent.children = [])).push(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-使用ES5和ES6求函数参数的和"><a href="#17-使用ES5和ES6求函数参数的和" class="headerlink" title="17. 使用ES5和ES6求函数参数的和"></a>17. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    Array.prototype.forEach.call(arguments, function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ES6：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(...nums) &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    nums.forEach(function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="18-解析-URL-Params-为对象"><a href="#18-解析-URL-Params-为对象" class="headerlink" title="18. 解析 URL Params 为对象"></a>18. 解析 URL Params 为对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;;</span><br><span class="line">parseParam(url)</span><br><span class="line">/* 结果</span><br><span class="line">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="line">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="line">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="line">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function parseParam(url) &#123;</span><br><span class="line">  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br><span class="line">  const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中</span><br><span class="line">  let paramsObj = &#123;&#125;;</span><br><span class="line">  // 将 params 存到对象中</span><br><span class="line">  paramsArr.forEach(param =&gt; &#123;</span><br><span class="line">    if (/=/.test(param)) &#123; // 处理有 value 的参数</span><br><span class="line">      let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value</span><br><span class="line">      val = decodeURIComponent(val); // 解码</span><br><span class="line">      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br><span class="line">      if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值</span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">      &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值</span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123; // 处理没有 value 的参数</span><br><span class="line">      paramsObj[param] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p>
<p>三个亮灯函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function red() &#123;</span><br><span class="line">    console.log(&#x27;red&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function green() &#123;</span><br><span class="line">    console.log(&#x27;green&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function yellow() &#123;</span><br><span class="line">    console.log(&#x27;yellow&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p>
<h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const task = (timer, light, callback) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        if (light === &#x27;red&#x27;) &#123;</span><br><span class="line">            red()</span><br><span class="line">        &#125;</span><br><span class="line">        else if (light === &#x27;green&#x27;) &#123;</span><br><span class="line">            green()</span><br><span class="line">        &#125;</span><br><span class="line">        else if (light === &#x27;yellow&#x27;) &#123;</span><br><span class="line">            yellow()</span><br><span class="line">        &#125;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">&#125;</span><br><span class="line">task(3000, &#x27;red&#x27;, () =&gt; &#123;</span><br><span class="line">    task(2000, &#x27;green&#x27;, () =&gt; &#123;</span><br><span class="line">        task(1000, &#x27;yellow&#x27;, Function.prototype)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p>
<p>上面提到过递归，可以递归亮灯的一个周期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const step = () =&gt; &#123;</span><br><span class="line">    task(3000, &#x27;red&#x27;, () =&gt; &#123;</span><br><span class="line">        task(2000, &#x27;green&#x27;, () =&gt; &#123;</span><br><span class="line">            task(1000, &#x27;yellow&#x27;, step)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br></pre></td></tr></table></figure>



<p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p>
<h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const task = (timer, light) =&gt; </span><br><span class="line">    new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            if (light === &#x27;red&#x27;) &#123;</span><br><span class="line">                red()</span><br><span class="line">            &#125;</span><br><span class="line">            else if (light === &#x27;green&#x27;) &#123;</span><br><span class="line">                green()</span><br><span class="line">            &#125;</span><br><span class="line">            else if (light === &#x27;yellow&#x27;) &#123;</span><br><span class="line">                yellow()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line">const step = () =&gt; &#123;</span><br><span class="line">    task(3000, &#x27;red&#x27;)</span><br><span class="line">        .then(() =&gt; task(2000, &#x27;green&#x27;))</span><br><span class="line">        .then(() =&gt; task(2100, &#x27;yellow&#x27;))</span><br><span class="line">        .then(step)</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br></pre></td></tr></table></figure>



<p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p>
<h4 id="（3）用-async-x2F-await-实现"><a href="#（3）用-async-x2F-await-实现" class="headerlink" title="（3）用 async&#x2F;await 实现"></a>（3）用 async&#x2F;await 实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const taskRunner =  async () =&gt; &#123;</span><br><span class="line">    await task(3000, &#x27;red&#x27;)</span><br><span class="line">    await task(2000, &#x27;green&#x27;)</span><br><span class="line">    await task(2100, &#x27;yellow&#x27;)</span><br><span class="line">    taskRunner()</span><br><span class="line">&#125;</span><br><span class="line">taskRunner()</span><br></pre></td></tr></table></figure>



<h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用闭包实现</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">// 使用 let 块级作用域</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function childNum(num, count)&#123;</span><br><span class="line">    let allplayer = [];    </span><br><span class="line">    for(let i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        allplayer[i] = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let exitCount = 0;    // 离开人数</span><br><span class="line">    let counter = 0;      // 记录报数</span><br><span class="line">    let curIndex = 0;     // 当前下标</span><br><span class="line">    </span><br><span class="line">    while(exitCount &lt; num - 1)&#123;</span><br><span class="line">        if(allplayer[curIndex] !== 0) counter++;    </span><br><span class="line">        </span><br><span class="line">        if(counter == count)&#123;</span><br><span class="line">            allplayer[curIndex] = 0;                 </span><br><span class="line">            counter = 0;</span><br><span class="line">            exitCount++;  </span><br><span class="line">        &#125;</span><br><span class="line">        curIndex++;</span><br><span class="line">        if(curIndex == num)&#123;</span><br><span class="line">            curIndex = 0               </span><br><span class="line">        &#125;;           </span><br><span class="line">    &#125;    </span><br><span class="line">    for(i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        if(allplayer[i] !== 0)&#123;</span><br><span class="line">            return allplayer[i]</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">childNum(30, 3)</span><br></pre></td></tr></table></figure>



<h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let imageAsync=(url)=&gt;&#123;</span><br><span class="line">            return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">                let img = new Image();</span><br><span class="line">                img.src = url;</span><br><span class="line">                img.οnlοad=()=&gt;&#123;</span><br><span class="line">                    console.log(`图片请求成功，此处进行通用操作`);</span><br><span class="line">                    resolve(image);</span><br><span class="line">                &#125;</span><br><span class="line">                img.οnerrοr=(err)=&gt;&#123;</span><br><span class="line">                    console.log(`失败，此处进行失败的通用操作`);</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">imageAsync(&quot;url&quot;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;加载成功&quot;);</span><br><span class="line">&#125;).catch((error)=&gt;&#123;</span><br><span class="line">    console.log(&quot;加载失败&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class EventCenter&#123;</span><br><span class="line">  // 1. 定义事件容器，用来装事件数组</span><br><span class="line">    let handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 2. 添加事件方法，参数：事件名 事件方法</span><br><span class="line">  addEventListener(type, handler) &#123;</span><br><span class="line">    // 创建新数组容器</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      this.handlers[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    // 存入事件</span><br><span class="line">    this.handlers[type].push(handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 3. 触发事件，参数：事件名 事件参数</span><br><span class="line">  dispatchEvent(type, params) &#123;</span><br><span class="line">    // 若没有注册该事件则抛出错误</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      return new Error(&#x27;该事件未注册&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 触发事件</span><br><span class="line">    this.handlers[type].forEach(handler =&gt; &#123;</span><br><span class="line">      handler(...params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span><br><span class="line">  removeEventListener(type, handler) &#123;</span><br><span class="line">    if (!this.handlers[type]) &#123;</span><br><span class="line">      return new Error(&#x27;事件无效&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!handler) &#123;</span><br><span class="line">      // 移除事件</span><br><span class="line">      delete this.handlers[type]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const index = this.handlers[type].findIndex(el =&gt; el === handler)</span><br><span class="line">      if (index === -1) &#123;</span><br><span class="line">        return new Error(&#x27;无该绑定事件&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      // 移除事件</span><br><span class="line">      this.handlers[type].splice(index, 1)</span><br><span class="line">      if (this.handlers[type].length === 0) &#123;</span><br><span class="line">        delete this.handlers[type]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function findMostWord(article) &#123;</span><br><span class="line">  // 合法性判断</span><br><span class="line">  if (!article) return;</span><br><span class="line">  // 参数处理</span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line">  let wordList = article.match(/[a-z]+/g),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = 0,</span><br><span class="line">    maxWord = &quot;&quot;;</span><br><span class="line">  article = &quot; &quot; + wordList.join(&quot;  &quot;) + &quot; &quot;;</span><br><span class="line">  // 遍历判断单词出现次数</span><br><span class="line">  wordList.forEach(function(item) &#123;</span><br><span class="line">    if (visited.indexOf(item) &lt; 0) &#123;</span><br><span class="line">      // 加入 visited </span><br><span class="line">      visited.push(item);</span><br><span class="line">      let word = new RegExp(&quot; &quot; + item + &quot; &quot;, &quot;g&quot;),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line">      if (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return maxWord + &quot;  &quot; + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">    class HttpRequestUtil &#123;</span><br><span class="line">        async get(url) &#123;</span><br><span class="line">            const res = await fetch(url);</span><br><span class="line">            const data = await res.json();</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">        async post(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;POST&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                body: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        async put(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;PUT&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                data: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        async delete(url, data) &#123;</span><br><span class="line">            const res = await fetch(url, &#123;</span><br><span class="line">                method: &#x27;DELETE&#x27;,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                data: JSON.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            const result = await res.json();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const httpRequestUtil = new HttpRequestUtil();</span><br><span class="line">    const res = await httpRequestUtil.get(&#x27;http://golderbrother.cn/&#x27;);</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//父方法</span><br><span class="line">function SupperFunction(flag1)&#123;</span><br><span class="line">    this.flag1 = flag1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子方法</span><br><span class="line">function SubFunction(flag2)&#123;</span><br><span class="line">    this.flag2 = flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//父实例</span><br><span class="line">var superInstance = new SupperFunction(true);</span><br><span class="line"></span><br><span class="line">//子继承父</span><br><span class="line">SubFunction.prototype = superInstance;</span><br><span class="line"></span><br><span class="line">//子实例</span><br><span class="line">var subInstance = new SubFunction(false);</span><br><span class="line">//子调用自己和父的属性</span><br><span class="line">subInstance.flag1;   // true</span><br><span class="line">subInstance.flag2;   // false</span><br></pre></td></tr></table></figure>



<h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">let input = document.getElementById(&#x27;input&#x27;)</span><br><span class="line">let span = document.getElementById(&#x27;span&#x27;)</span><br><span class="line">// 数据劫持</span><br><span class="line">Object.defineProperty(obj, &#x27;text&#x27;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#x27;获取数据了&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal) &#123;</span><br><span class="line">    console.log(&#x27;数据更新了&#x27;)</span><br><span class="line">    input.value = newVal</span><br><span class="line">    span.innerHTML = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 输入监听</span><br><span class="line">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class="line">  obj.text = e.target.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hash路由</span><br><span class="line">class Route&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 路由存储对象</span><br><span class="line">    this.routes = &#123;&#125;</span><br><span class="line">    // 当前hash</span><br><span class="line">    this.currentHash = &#x27;&#x27;</span><br><span class="line">    // 绑定this，避免监听时this指向改变</span><br><span class="line">    this.freshRoute = this.freshRoute.bind(this)</span><br><span class="line">    // 监听</span><br><span class="line">    window.addEventListener(&#x27;load&#x27;, this.freshRoute, false)</span><br><span class="line">    window.addEventListener(&#x27;hashchange&#x27;, this.freshRoute, false)</span><br><span class="line">  &#125;</span><br><span class="line">  // 存储</span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    this.routes[path] = cb || function () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    this.currentHash = location.hash.slice(1) || &#x27;/&#x27;</span><br><span class="line">    this.routes[this.currentHash]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">function fn (n)&#123;</span><br><span class="line">    if(n==0) return 0</span><br><span class="line">    if(n==1) return 1</span><br><span class="line">    return fn(n-2)+fn(n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 优化</span><br><span class="line">function fibonacci2(n) &#123;</span><br><span class="line">    const arr = [1, 1, 2];</span><br><span class="line">    const arrLen = arr.length;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= arrLen) &#123;</span><br><span class="line">        return arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = arrLen; i &lt; n; i++) &#123;</span><br><span class="line">        arr.push(arr[i - 1] + arr[ i - 2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr[arr.length - 1];</span><br><span class="line">&#125;</span><br><span class="line">// 非递归</span><br><span class="line">function fn(n) &#123;</span><br><span class="line">    let pre1 = 1;</span><br><span class="line">    let pre2 = 1;</span><br><span class="line">    let current = 2;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 2; i &lt; n; i++) &#123;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = current;</span><br><span class="line">        current = pre1 + pre2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function (s) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let i = -1</span><br><span class="line">    let res = 0</span><br><span class="line">    let n = s.length</span><br><span class="line">    for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        if (map.has(s[j])) &#123;</span><br><span class="line">            i = Math.max(i, map.get(s[j]))</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, j - i)</span><br><span class="line">        map.set(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
<p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function mySetInterval(fn, timeout) &#123;</span><br><span class="line">  // 控制器，控制定时器是否继续执行</span><br><span class="line">  var timer = &#123;</span><br><span class="line">    flag: true</span><br><span class="line">  &#125;;</span><br><span class="line">  // 设置递归函数，模拟定时器执行。</span><br><span class="line">  function interval() &#123;</span><br><span class="line">    if (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      setTimeout(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 启动定时器</span><br><span class="line">  setTimeout(interval, timeout);</span><br><span class="line">  // 返回控制器</span><br><span class="line">  return timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 动态的加载js文件</span><br><span class="line">function addScript(src) &#123;</span><br><span class="line">  const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.type = &quot;text/javascript&quot;;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">addScript(&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;);</span><br><span class="line">// 设置一个全局的callback函数来接收回调结果</span><br><span class="line">function handleRes(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;</span><br><span class="line">// 接口返回的数据格式</span><br><span class="line">handleRes(&#123;a: 1, b: 2&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p>
<p>下面方法可以用来判断一个对象中是否已存在循环引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const isCycleObject = (obj,parent) =&gt; &#123;</span><br><span class="line">    const parentArr = parent || [obj];</span><br><span class="line">    for(let i in obj) &#123;</span><br><span class="line">        if(typeof obj[i] === &#x27;object&#x27;) &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            parentArr.forEach((pObj) =&gt; &#123;</span><br><span class="line">                if(pObj === obj[i])&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            if(flag) return true;</span><br><span class="line">            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);</span><br><span class="line">            if(flag) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const a = 1;</span><br><span class="line">const b = &#123;a&#125;;</span><br><span class="line">const c = &#123;b&#125;;</span><br><span class="line">const o = &#123;d:&#123;a:3&#125;,c&#125;</span><br><span class="line">o.c.b.aa = a;</span><br><span class="line"></span><br><span class="line">console.log(isCycleObject(o)</span><br></pre></td></tr></table></figure>



<p>查找有序二维数组的目标值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var findNumberIn2DArray = function(matrix, target) &#123;</span><br><span class="line">    if (matrix == null || matrix.length == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let row = 0;</span><br><span class="line">    let column = matrix[0].length - 1;</span><br><span class="line">    while (row &lt; matrix.length &amp;&amp; column &gt;= 0) &#123;</span><br><span class="line">        if (matrix[row][column] == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (matrix[row][column] &gt; target) &#123;</span><br><span class="line">            column--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>二维数组斜向打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function printMatrix(arr)&#123;</span><br><span class="line">  let m = arr.length, n = arr[0].length</span><br><span class="line">    let res = []</span><br><span class="line">  </span><br><span class="line">  // 左上角，从0 到 n - 1 列进行打印</span><br><span class="line">  for (let k = 0; k &lt; n; k++) &#123;</span><br><span class="line">    for (let i = 0, j = k; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) &#123;</span><br><span class="line">      res.push(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 右下角，从1 到 n - 1 行进行打印</span><br><span class="line">  for (let k = 1; k &lt; m; k++) &#123;</span><br><span class="line">    for (let i = k, j = n - 1; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) &#123;</span><br><span class="line">      res.push(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/03/06/%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p><img src="/../images/image-20240306102805549.png" alt="image-20240306102805549"></p>
<p><img src="/../images/image-20240306104151653.png" alt="image-20240306104151653"></p>
<p><img src="/../images/image-20240306105535785.png" alt="image-20240306105535785"></p>
<img src="../images/image-20240306105425702.png" alt="image-20240306105425702" style="zoom:80%;" />]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[项目表达]]></title>
      <url>/2024/03/05/%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>可视化</p>
<ul>
<li><strong>灵活的数据筛选</strong>：允许用户通过交互操作筛选和查看不同维度的数据。</li>
<li><strong>深入的数据探索</strong>：提供工具提示、数据视图切换等功能，帮助用户深入探索数据。</li>
</ul>
<p>性能优化：处理大量数据可能导致性能问题，如何优化数据加载和渲染速度是一个技术难点</p>
<ol>
<li><p>高效的技术实现</p>
<ul>
<li><strong>性能优化</strong>：通过技术手段实现快速加载、流畅渲染和低内存占用。</li>
<li><strong>可扩展性</strong>：采用模块化设计和可扩展的架构，方便未来功能的扩展和维护。</li>
</ul>
</li>
</ol>
<p>处理大量数据时，性能优化是一个关键的技术挑战。以下是一些可行的方案来优化数据加载和渲染速度：</p>
<ol>
<li><p>数据分块加载</p>
<ul>
<li>将大数据集拆分成小块，并按需加载。这可以通过异步请求或分页加载来实现，以减少初始加载时间。</li>
<li>仅加载和渲染当前视窗内需要的数据，当用户滚动或缩放时，再加载更多数据。</li>
</ul>
</li>
<li><p>懒加载与虚拟滚动</p>
<p>：</p>
<ul>
<li>懒加载意味着延迟加载不在视窗内的数据。例如，在滚动列表中，只有当用户滚动到某个位置时，才加载那个位置的数据。</li>
<li>虚拟滚动是一种技术，它只渲染视窗内的数据项，而不是整个列表。当用户滚动时，会更新视窗内的数据项。</li>
</ul>
</li>
<li><p>使用数据缓存</p>
<p>：</p>
<ul>
<li>对于不经常变化的数据，可以使用缓存来存储数据，避免频繁从服务器请求。</li>
<li>缓存可以是本地存储（如localStorage、sessionStorage）或内存缓存（如Redis）。</li>
</ul>
</li>
<li><p>数据压缩与传输优化</p>
<p>：</p>
<ul>
<li>在发送到前端之前，对数据进行压缩，以减少网络传输的数据量。</li>
<li>使用合适的数据格式（如JSONP、GZip等）进行数据传输。</li>
</ul>
</li>
<li><p>使用Web Workers进行后台处理</p>
<p>：</p>
<ul>
<li>将数据处理逻辑放在Web Workers中运行，避免阻塞主线程，从而提高页面性能。</li>
<li>Web Workers可以在后台线程中执行计算密集型任务，如数据清洗、转换和聚合。</li>
</ul>
</li>
<li><p>优化数据结构和算法</p>
<p>：</p>
<ul>
<li>选择合适的数据结构（如数组、对象、Map、Set等）和算法来高效处理数据。</li>
<li>避免使用低效的遍历方法和复杂的嵌套循环。</li>
</ul>
</li>
<li><p>减少DOM操作</p>
<p>：</p>
<ul>
<li>尽量减少不必要的DOM操作，因为它们可能会导致性能下降。</li>
<li>使用文档片段（Document Fragments）或虚拟DOM库（如React、Vue）来减少DOM更新次数。</li>
</ul>
</li>
<li><p>使用请求合并与批量处理</p>
<p>：</p>
<ul>
<li>如果多个数据请求可以合并成一个，那么合并请求可以减少网络往返时间。</li>
<li>对于批量数据更新，可以考虑一次性发送多个数据项，而不是逐一发送。</li>
</ul>
</li>
<li><p>异步渲染与渲染优化</p>
<p>：</p>
<ul>
<li>使用异步渲染技术，如WebGL或Canvas，来加速复杂图形的渲染。</li>
<li>避免在渲染过程中执行昂贵的计算任务，可以将它们放在Web Workers中处理。</li>
</ul>
</li>
<li><p>使用数据可视化库的优化功能</p>
<p>：</p>
<ul>
<li>选择经过优化的数据可视化库，如ECharts、D3等，它们通常提供了内置的性能优化功能。</li>
<li>根据库的文档和最佳实践配置图表选项，以最大化渲染性能。</li>
</ul>
</li>
<li><p>利用浏览器的缓存机制</p>
<p>：</p>
<ul>
<li>利用浏览器的HTTP缓存机制，通过设置合适的缓存头（如Cache-Control、Expires），让浏览器缓存静态资源。</li>
</ul>
</li>
<li><p>分页与数据筛选</p>
<p>：</p>
<ul>
<li>提供分页功能，允许用户按需加载数据。</li>
<li>提供数据筛选功能，减少渲染的数据量。</li>
</ul>
</li>
</ol>
<p>在实施这些优化方案时，需要权衡各种因素，如用户体验、数据准确性、开发成本等。同时，持续监控和性能测试也是关键，以确保优化措施的实际效果符合预期。</p>
<p><strong>（1）代码层面的优化</strong></p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch  区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p><strong>（2）Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>（3）基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h2 id="4：脚本非阻塞异步加载"><a href="#4：脚本非阻塞异步加载" class="headerlink" title="4：脚本非阻塞异步加载"></a>4：脚本非阻塞异步加载</h2><h3 id="4-1：介绍"><a href="#4-1：介绍" class="headerlink" title="4.1：介绍"></a>4.1：介绍</h3><p>异步无阻塞加载 JavaScript 脚本是一种优化网页性能的技术，它可以在不阻塞页面渲染的情况下加载脚本文件，并在加载完成后立即执行。这种方式可以提高页面的加载速度和用户体验。</p>
<p>在 HTML 中，我们可以通过 <code>&lt;script&gt;</code> 标签的 <code>async</code> 和 <code>defer</code> 属性来实现异步加载脚本：</p>
<ol>
<li><strong>async 属性</strong>：</li>
</ol>
<ul>
<li><code>async</code> 属性表示脚本的异步加载，它告诉浏览器立即开始下载脚本，但不会阻塞页面的解析和渲染。当脚本下载完成后，会立即执行，不管其他脚本是否已经下载完成。这意味着脚本的执行顺序不受控制，可能会与其在页面中的顺序不一致。</li>
<li>使用 <code>async</code> 属性加载的脚本适用于独立、互相之间无依赖关系的脚本，例如用于分析、广告或跟踪的脚本。</li>
</ul>
<ol>
<li><strong>defer 属性</strong>：</li>
</ol>
<ul>
<li><code>defer</code> 属性表示脚本的延迟加载，它告诉浏览器立即开始下载脚本，但会延迟执行直到页面解析完成后、<code>DOMContentLoaded</code> 事件触发之前。多个 <code>defer</code> 脚本会按照它们在页面中出现的顺序依次执行，保证了执行顺序。</li>
<li>使用 <code>defer</code> 属性加载的脚本适用于页面初始化时需要执行的脚本，例如用于初始化页面内容或绑定事件处理程序的脚本。</li>
</ul>
<p>我们总结一下：</p>
<ul>
<li>使用 <code>async</code> 属性加载的脚本是异步的，可能会在页面解析过程中执行，不保证执行顺序（测试过多次其实也能按照顺序执行，可能在更复杂的环境下会出现）。</li>
<li>使用 <code>defer</code> 属性加载的脚本是延迟加载的，会在页面解析完成后按照顺序执行。</li>
</ul>
<h3 id="4-2：使用"><a href="#4-2：使用" class="headerlink" title="4.2：使用"></a>4.2：使用</h3><p><strong>（1）异步加载第三方脚本</strong>： 如果你需要在页面中加载第三方脚本，并且这些脚本不依赖于页面的其他内容，你可以使用 <code>async</code> 属性来异步加载它们。</p>
<p>例如，在 Vue 组件中的 <code>mounted</code> 钩子函数中动态创建 <code>&lt;script&gt;</code> 标签并设置 <code>async</code> 属性来加载第三方脚本。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">&#x27;https://xxx.js&#x27;</span>;</span><br><span class="line">    script.<span class="property">async</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）延迟加载初始化脚本</strong>： 如果你有一些初始化脚本需要在页面加载完成后执行，但又不想阻塞页面渲染，你可以使用 <code>defer</code> 属性来延迟加载这些脚本。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在根组件的 mounted 钩子函数中延迟加载初始化脚本</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> initScript = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">initScript.<span class="property">src</span> = <span class="string">&#x27;xxx.js&#x27;</span>;</span><br><span class="line">initScript.<span class="property">defer</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(initScript);</span><br></pre></td></tr></table></figure>

<p>这样可以确保初始化脚本在页面加载完成后执行，而不会阻塞页面的渲染。在使用 <code>async</code> 和 <code>defer</code> 属性加载脚本时，需要注意脚本的加载和执行顺序以及对页面的影响。确保选择适当的加载方式来优化页面加载性能和用户体验。</p>
<h1 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h1><h3 id="问题2：如何保证错误上报的实时性和准确性？"><a href="#问题2：如何保证错误上报的实时性和准确性？" class="headerlink" title="问题2：如何保证错误上报的实时性和准确性？"></a>问题2：如何保证错误上报的实时性和准确性？</h3><p><strong>回答</strong>：<br>我们的系统通过结合实时上报和批量上报两种策略来平衡实时性和准确性。对于关键错误或紧急情况，系统会立即将错误信息上传到服务器，以确保能够迅速响应。同时，对于非关键错误或在网络不佳的情况下，系统会将错误信息存储在IndexedDB中，并在合适的时机（如网络恢复或达到一定的数据量）进行批量上传。此外，我们还会对上报的错误信息进行校验和去重处理，以提高数据的准确性。</p>
<p>Error：错误的基类，其他错误都继承自该类型</p>
<p>EvalError：Eval 函数执行异常</p>
<p>RangeError：数组越界</p>
<p>ReferenceError：尝试引用一个未被定义的变量时，将会抛出此异常</p>
<p>SyntaxError：语法解析不合理</p>
<p>TypeError：类型错误，用来表示值的类型非预期类型时发生的错误</p>
<p>URIError：以一种错误的方式使用全局 URI 处理函数而产生的错误</p>
<h3 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h3><p>异常一共七大类，处理时需分清是致命错误还是非致命错误。</p>
<ul>
<li>可疑区域增加 <code>try-catch</code></li>
<li>全局监控 <code>JS</code> 异常 <code>window.onerror</code></li>
<li>全局监控静态资源异常 <code>window.addEventListener</code></li>
<li>捕获没有 <code>catch</code> 的 <code>Promise</code> 异常用 <code>unhandledrejection</code></li>
<li><code>Axios</code> 请求统一异常处理用拦截器 <code>interceptors</code></li>
<li>使用日志监控服务收集用户错误信息</li>
</ul>
<h2 id="面试官可能会针对错误监控上报系统的不同方面继续提问，以深入了解你的设计思路和实现细节。以下是一些可能的问题以及相应的回答建议："><a href="#面试官可能会针对错误监控上报系统的不同方面继续提问，以深入了解你的设计思路和实现细节。以下是一些可能的问题以及相应的回答建议：" class="headerlink" title="面试官可能会针对错误监控上报系统的不同方面继续提问，以深入了解你的设计思路和实现细节。以下是一些可能的问题以及相应的回答建议："></a><strong>面试官可能会针对错误监控上报系统的不同方面继续提问，以深入了解你的设计思路和实现细节</strong>。以下是一些可能的问题以及相应的回答建议：</h2><h3 id="问题1：如何处理错误信息的隐私和安全性？"><a href="#问题1：如何处理错误信息的隐私和安全性？" class="headerlink" title="问题1：如何处理错误信息的隐私和安全性？"></a>问题1：如何处理错误信息的隐私和安全性？</h3><p><strong>回答</strong>：<br>在错误监控上报系统中，我们非常重视错误信息的隐私和安全性。首先，所有敏感信息，如用户身份验证数据或个人可识别信息（PII），都会在客户端进行脱敏处理，确保不会上传到服务器。其次，我们使用HTTPS等安全协议来传输数据，以防止在传输过程中被截获或篡改。此外，服务器端也会实施严格的安全措施，包括访问控制、数据加密和定期的安全审计，以确保存储的错误信息的安全性。</p>
<h3 id="问题2：如何保证错误上报的实时性和准确性？-1"><a href="#问题2：如何保证错误上报的实时性和准确性？-1" class="headerlink" title="问题2：如何保证错误上报的实时性和准确性？"></a>问题2：如何保证错误上报的实时性和准确性？</h3><p><strong>回答</strong>：<br>我们的系统通过结合实时上报和批量上报两种策略来平衡实时性和准确性。对于关键错误或紧急情况，系统会立即将错误信息上传到服务器，以确保能够迅速响应。同时，对于非关键错误或在网络不佳的情况下，系统会将错误信息存储在IndexedDB中，并在合适的时机（如网络恢复或达到一定的数据量）进行批量上传。此外，我们还会对上报的错误信息进行校验和去重处理，以提高数据的准确性。</p>
<h3 id="问题3：如何处理大量的错误信息存储和检索？"><a href="#问题3：如何处理大量的错误信息存储和检索？" class="headerlink" title="问题3：如何处理大量的错误信息存储和检索？"></a>问题3：如何处理大量的错误信息存储和检索？</h3><p><strong>回答</strong>：<br>IndexedDB设计为能够高效地存储和检索大量结构化数据。我们会对错误信息进行合理的索引和分区存储，以便能够快速检索和查询。同时，我们也会定期清理过时的或不再需要的错误信息，以保持数据库的性能和可管理性。在需要时，我们还可以使用IndexedDB的游标功能进行更复杂的查询和数据分析。</p>
<h3 id="问题4：如何确保Web-Worker在处理错误数据时的性能和稳定性？"><a href="#问题4：如何确保Web-Worker在处理错误数据时的性能和稳定性？" class="headerlink" title="问题4：如何确保Web Worker在处理错误数据时的性能和稳定性？"></a>问题4：如何确保Web Worker在处理错误数据时的性能和稳定性？</h3><p><strong>回答</strong>：<br>Web Worker运行在独立的线程中，不会阻塞主线程的执行。为了确保Web Worker的性能和稳定性，我们会合理分配和限制其处理任务的数量和大小。同时，我们也会监控Web Worker的运行状态和资源使用情况，并在必要时进行调整或优化。此外，我们还会为Web Worker编写健壮的错误处理逻辑，以确保其在遇到问题时能够优雅地处理并恢复。</p>
<h3 id="问题5：如何与后端服务进行集成和协作？"><a href="#问题5：如何与后端服务进行集成和协作？" class="headerlink" title="问题5：如何与后端服务进行集成和协作？"></a>问题5：如何与后端服务进行集成和协作？</h3><p><strong>回答</strong>：<br>我们的错误监控上报系统设计了灵活的后端集成接口。通过定义清晰的API和数据格式，我们可以与后端服务进行无缝对接。后端服务负责接收、存储和分析上报的错误信息，并提供相应的监控和报警功能。我们还会与后端团队密切合作，共同定义和优化错误处理流程，以确保整个系统的协同工作和高效运行。</p>
<h2 id="当面试官问及为什么要使用IndexedDB而不是直接传输信息时，你可以这样回答："><a href="#当面试官问及为什么要使用IndexedDB而不是直接传输信息时，你可以这样回答：" class="headerlink" title="当面试官问及为什么要使用IndexedDB而不是直接传输信息时，你可以这样回答："></a>当面试官问及为什么要使用IndexedDB而不是直接传输信息时，你可以这样回答：</h2><p>使用IndexedDB存储错误信息而不是直接传输，主要是出于以下几个考虑：</p>
<ol>
<li><strong>离线存储与可靠性</strong>：IndexedDB允许我们在客户端本地存储数据，这意味着即使在网络不可用或不稳定的情况下，我们也能可靠地保存错误信息。当网络恢复时，我们可以从IndexedDB中检索这些数据并将其传输到服务器。这种离线存储能力对于确保数据不丢失至关重要，尤其是在移动或网络环境不佳的场景中。</li>
<li><strong>减少即时传输的压力</strong>：如果应用程序在短时间内产生大量错误信息，直接将这些信息实时传输到服务器可能会对网络带宽和服务器造成压力。通过使用IndexedDB作为中间缓存层，我们可以实现错误信息的批量上传，从而有效管理网络负载并避免对服务器造成冲击。</li>
<li><strong>数据预处理与优化</strong>：将错误信息先存储在IndexedDB中，给我们提供了在数据上传之前进行预处理的机会。我们可以在客户端进行数据的清洗、去重、压缩或加密等操作，以确保上传到服务器的数据质量更高、体积更小且安全性更强。这不仅优化了数据传输效率，还减轻了服务器端的处理负担。</li>
<li><strong>用户体验与主线程性能</strong>：通过Web Worker在后台处理IndexedDB中的数据，我们可以避免在主线程上执行这些操作，从而确保应用程序的响应性和用户体验不受影响。这种异步处理方式使得错误监控上报系统的运行更加平滑，不会干扰到用户与应用程序的交互。</li>
</ol>
<p>综上所述，使用IndexedDB作为错误监控上报系统的一部分，可以提高数据的可靠性、优化网络传输、提升数据质量、减轻服务器负担，并且保证用户体验的顺畅。这是一种更为成熟和全面的错误处理策略。</p>
<h2 id="vue在关闭页面前上报错误信息"><a href="#vue在关闭页面前上报错误信息" class="headerlink" title="vue在关闭页面前上报错误信息"></a>vue在关闭页面前上报错误信息</h2><p>在Vue中，如果你想在关闭页面之前上传存储的错误数据，你可以使用<code>beforeunload</code>事件来实现。这个事件在浏览器即将卸载页面之前触发，可以给你一个机会执行一些清理或保存操作</p>
<ul>
<li>浏览器可能会忽略你为<code>beforeunload</code>事件设置的自定义消息，并显示其自己的默认消息。这是出于安全和用户体验的考虑。</li>
<li>例子  <strong>Google Chrome</strong>：Chrome浏览器在触发<code>beforeunload</code>事件时，通常会显示一个标准的对话框，提示用户他们即将离开页面，并且可能丢失未保存的数据。这个对话框的内容是由浏览器控制的，而不是由网页的JavaScript代码控制的。</li>
</ul>
<h4 id="使用Service-Worker来在用户退出网页前上报信息是一个很好的策略，因为它允许你在页面卸载后继续执行后台任务。以下是如何实现这一功能的步骤："><a href="#使用Service-Worker来在用户退出网页前上报信息是一个很好的策略，因为它允许你在页面卸载后继续执行后台任务。以下是如何实现这一功能的步骤：" class="headerlink" title="使用Service Worker来在用户退出网页前上报信息是一个很好的策略，因为它允许你在页面卸载后继续执行后台任务。以下是如何实现这一功能的步骤："></a>使用Service Worker来在用户退出网页前上报信息是一个很好的策略，因为它允许你在页面卸载后继续执行后台任务。以下是如何实现这一功能的步骤：</h4><ol>
<li><strong>注册Service Worker</strong></li>
</ol>
<p>在你的Vue应用中，首先需要注册一个Service Worker。这通常在主JavaScript文件中完成，例如在<code>main.js</code>或<code>app.js</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;  </span><br><span class="line">  navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/service-worker.js&#x27;</span>)  </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service Worker Registered&#x27;</span>))  </span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service Worker Registration Failed: &#x27;</span>, err));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保你的项目目录中有一个名为<code>service-worker.js</code>的文件，该文件将包含Service Worker的逻辑。</p>
<ol>
<li><strong>在Service Worker中监听消息</strong></li>
</ol>
<p>在<code>service-worker.js</code>中，你可以监听从页面发送来的消息，并处理这些消息，比如上传数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = event;  </span><br><span class="line">  <span class="comment">// 处理数据上传逻辑  </span></span><br><span class="line">  self.<span class="title function_">uploadErrorData</span>(data);  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">self.<span class="property">uploadErrorData</span> = <span class="keyword">async</span> data =&gt; &#123;  </span><br><span class="line">  <span class="comment">// 使用fetch API或其他方式发送数据到服务器  </span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/upload-error-data&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span><br><span class="line">    <span class="attr">headers</span>: &#123;  </span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)  </span><br><span class="line">  &#125;);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;  </span><br><span class="line">    <span class="comment">// 处理错误情况  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error uploading data:&#x27;</span>, response.<span class="property">statusText</span>);  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Data uploaded successfully&#x27;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在页面卸载前发送消息</strong></li>
</ol>
<p>在你的Vue组件或实例中，当页面即将卸载时，你可以向Service Worker发送消息，通知它上传数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="comment">// 检查Service Worker是否注册成功  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;  </span><br><span class="line">      navigator.<span class="property">serviceWorker</span>.<span class="property">controllers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">controller</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="comment">// 发送消息给Service Worker  </span></span><br><span class="line">        controller.<span class="title function_">postMessage</span>(&#123; <span class="attr">errorData</span>: <span class="variable language_">this</span>.<span class="property">errorData</span> &#125;);  </span><br><span class="line">      &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">      <span class="attr">errorData</span>: [] <span class="comment">// 假设这是你要上传的错误数据数组  </span></span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// ... 其他选项和方法  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>处理页面刷新或关闭</strong></li>
</ol>
<p>如果你还希望在用户刷新页面或关闭浏览器标签页时上传数据，你可以在<code>beforeunload</code>事件中发送消息给Service Worker。但是，请注意，<code>beforeunload</code>事件通常不允许执行长时间的异步操作。因此，最好的做法是在<code>beforeDestroy</code>钩子中发送消息，因为Vue会在组件销毁之前调用这个钩子。</p>
<ol>
<li><strong>确保Service Worker可以通信</strong></li>
</ol>
<p>由于浏览器的安全限制，Service Worker和页面之间的通信必须遵循同源策略。确保你的Service Worker文件和Vue应用位于相同的源（即协议、域名和端口都相同）。</p>
<ol>
<li><strong>处理Service Worker的生命周期</strong></li>
</ol>
<p>Service Worker有自己的生命周期，并且可能在浏览器关闭后仍然存活。确保你理解Service Worker的生命周期，并适当管理其注册、更新和卸载。</p>
<p>通过这种方法，你可以确保即使用户关闭或刷新页面，Service Worker也能继续运行并上传错误数据。这为用户提供了更好的体验，同时确保重要数据得到保存。</p>
<p>。</p>
<h4 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h4><p>Service Worker 对离线状态的支持主要通过其缓存和拦截网络请求的能力实现。当应用程序尝试发起网络请求时，Service Worker 会拦截这些请求，并根据其缓存策略来处理它们。</p>
<p>具体来说，当应用程序在在线状态下尝试上传数据时，Service Worker 会接收到这个请求。如果数据上传成功，那么自然无需进行任何额外操作。但如果上传失败（例如，由于网络问题），Service Worker 可以将待上传的数据缓存起来。这通常是通过将数据存储在 IndexedDB、Cache API 或其他浏览器提供的存储机制中实现的。</p>
<p>一旦应用程序进入离线状态，任何尝试上传数据的请求都会被 Service Worker 拦截。由于此时无法连接到服务器，Service Worker 不会尝试立即上传这些数据，而是将它们保留在缓存中。</p>
<p>当网络连接恢复时，Service Worker 会检测到这一变化，并自动尝试将缓存中的待上传数据发送到服务器。这通常是通过监听网络状态变化事件或使用某种轮询机制来实现的。一旦数据成功上传，Service Worker 会从缓存中删除这些数据，以确保不会重复上传。</p>
<p>通过这种方式，Service Worker 能够在应用程序处于离线状态时缓存待上传的数据，并在网络连接恢复后自动进行上传。这不仅提高了应用程序的可靠性，还为用户提供了更好的体验，因为他们无需担心在网络不稳定时数据丢失或无法上传的问题。</p>
<p>需要注意的是，为了实现这一功能，开发者需要在 Service Worker 的脚本中编写相应的逻辑来处理缓存、拦截请求以及监听网络状态变化等事件。此外，还需要考虑缓存策略的设计，以确保在适当的时候上传数据并清理缓存，避免数据积压或浪费存储空间。</p>
<h4 id="WebSocket心跳机制的作用主要有以下几点："><a href="#WebSocket心跳机制的作用主要有以下几点：" class="headerlink" title="WebSocket心跳机制的作用主要有以下几点："></a>WebSocket心跳机制的作用主要有以下几点：</h4><ol>
<li>保持WebSocket连接不被断开。<br>检测WebSocket连接状态，及时处理异常情况。<br>减少WebSocket连接及服务器资源的消耗。</li>
</ol>
<h3 id="2、v-if-与-v-for-的优先级问题？"><a href="#2、v-if-与-v-for-的优先级问题？" class="headerlink" title="2、v-if 与 v-for 的优先级问题？"></a>2、v-if 与 v-for 的优先级问题？</h3><ul>
<li>vue2 中 v-for 优先级大于 v-if</li>
<li>vue3 中 v-if 优先级大于 v-for</li>
</ul>
<p>因为 Vue3 编译后的写法跟 Vue2 不一样了</p>
<h4 id="如果面试官问这些表单输入值-为什么不能在提交前用一些提示来规范用户的输入-为何要收集错误dom"><a href="#如果面试官问这些表单输入值-为什么不能在提交前用一些提示来规范用户的输入-为何要收集错误dom" class="headerlink" title="如果面试官问这些表单输入值 为什么不能在提交前用一些提示来规范用户的输入  为何要收集错误dom"></a>如果面试官问这些表单输入值 为什么不能在提交前用一些提示来规范用户的输入  为何要收集错误dom</h4><ol>
<li><p><strong>错误定位与诊断</strong>：尽管实时提示对于用户输入验证至关重要，但有时候用户可能会忽略这些提示，或者由于某些原因（如网络延迟、页面加载问题等）未能及时看到提示 ，使用DOM收集错误发生时的表单状态，有助于更准确地定位问题所在。有时，错误可能源于复杂的逻辑或难以预见的用户行为，这些在实时提示中可能难以覆盖。收集DOM信息可以帮助开发者深入了解问题的根源，从而进行更有效的修复。</p>
</li>
<li><p><strong>调试与问题定位</strong>：收集DOM元素的信息可以帮助开发者更准确地定位问题。在表单提交的过程中，如果发生错误，知道哪个具体的DOM元素引起了问题（比如哪个输入框的值不符合要求、哪个按钮的点击事件没有正确处理等）可以大大加速调试过程。</p>
</li>
<li><p><strong>用户反馈与体验</strong>：收集DOM元素信息有助于更具体地了解用户的行为和输入情况。当表单提交失败时，可以根据收集到的DOM信息提供更加精确的错误提示，指导用户如何修正输入，从而改善用户体验。</p>
</li>
<li><p><strong>错误重现与复现</strong>：在某些情况下，错误可能难以复现，特别是当错误发生在特定用户或特定操作条件下时。收集DOM信息可以帮助开发人员在后续开发中重现错误，从而更好地分析和解决问题。</p>
</li>
</ol>
<p><img src="/../images/image-20240411184548824.png" alt="image-20240411184548824"></p>
<h4 id="中风智能可视化与预测平台"><a href="#中风智能可视化与预测平台" class="headerlink" title="中风智能可视化与预测平台"></a><strong>中风智能可视化与预测平台</strong></h4><p>Vue2+ Vuex + Vue-router + ElementUI + Echarts</p>
<p><strong>地址 ：</strong><a href="http://43.138.22.74/">http://43.138.22.74:80</a></p>
<p><strong>内容 ：</strong>该平台基于大数据分析、机器学习等技术配合web前端技术 ，实现让群众去了解中⻛以及自我评测中⻛概</p>
<p>况的一个web开发应用 ，从中⻛整体情况、成因探究、预测与建议、治疗与医院以及中⻛小贴士五个方面展开。</p>
<p><strong>项目职责 ：</strong></p>
<p>1负责整个项目前端生产环境的整体搭建(项目搭建、部署发布)以及项目管理</p>
<p>2利用Vue2 + Vue-router构建项目以及页面跳转 ，利用 Vue-router 路由钩子函数实现系统角色权限控制 ，并且</p>
<p>统一了前端路由的交互模式</p>
<p>3利用Css的flex布局以及flexible脚本实现大屏响应式布局</p>
<p>4利用Echart绘制可视化图表 ，更好呈现数据并为各种问题提供解决方案 ，如数据动态更新、 图表配置或样式调整困难</p>
<p><strong>困难：</strong></p>
<p>1项目体积过大，打包速度慢影响开发体验，渲染性能差，首屏渲染时间缓慢，影响用户使用</p>
<p>2数据无法实时更新，必须需要前端不停往后端发送请求获取数据，对服务器压力过大</p>
<p><strong>成果：</strong></p>
<p>1使用Webpack Bundle,lighthouse等工具分析项目性能 ，打包体积大小 ，采用懒加载、Gzip压缩、cdn等技术使</p>
<p>包体积压缩<strong>42%</strong> ，打包速度提升<strong>54%</strong> ，首屏渲染时长提高<strong>60%</strong></p>
<p>2集成WebSocket技术 ，实现了前后端数据的实时同步更新。提高了医疗数据的实时性和准确性 ，也为用户决策</p>
<p>提供了有力的数据支持。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[备战资料]]></title>
      <url>/2024/03/02/%E5%A4%87%E6%88%98%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<p>大厂平时做什么？ 特别专题—阿里前端专家带你体验大厂618的一天-澄怀 <a href="https://dnlqa.xetslk.com/sl/11xUWQ">https://dnlqa.xetslk.com/sl/11xUWQ</a><br>【双11专场】教你如何学透前端框架编译实现——澄怀 <a href="https://dnlqa.h5.xeknow.com/sl/RKDQW">https://dnlqa.h5.xeknow.com/sl/RKDQW</a><br>不知道面试难度 阿里面试官现场深度模拟P6级面试-澄怀 <a href="https://dnlqa.xetslk.com/sl/3O2WEg">https://dnlqa.xetslk.com/sl/3O2WEg</a><br>简历不行 P8大佬直播修改真实用户脱敏简历——澄怀 <a href="https://dnlqa.xetslk.com/sl/4z5i2P">https://dnlqa.xetslk.com/sl/4z5i2P</a><br>大厂直通车之阿里面试（简历+函数式编程） <a href="https://dnlqa.xetslk.com/s/3BlClb">https://dnlqa.xetslk.com/s/3BlClb</a><br>工程化不行 前端工程化与构建工具原理深度剖析-澄怀 <a href="https://dnlqa.xetslk.com/sl/2m6h7N">https://dnlqa.xetslk.com/sl/2m6h7N</a><br>手写不行 阿里P8直播从0~1手写一个完整的babel plugin-澄怀 <a href="https://dnlqa.xetslk.com/sl/ufpz3">https://dnlqa.xetslk.com/sl/ufpz3</a><br>大厂面试真题讲解 2023大厂Vue3 深度 核心高频原题-澄怀（Vue3） <a href="https://dnlqa.xetslk.com/sl/47EsRp">https://dnlqa.xetslk.com/sl/47EsRp</a><br>React面试真题只看这个就够啦-澄怀（React） <a href="https://dnlqa.xetslk.com/sl/lEqgI">https://dnlqa.xetslk.com/sl/lEqgI</a><br>一个小时搞懂JavaScript运行机制&amp;垃圾回收-合一（JS） <a href="https://dnlqa.xetslk.com/sl/3c8drd">https://dnlqa.xetslk.com/sl/3c8drd</a><br>大厂前端算法面试指南-潇然（算法） <a href="https://dnlqa.xetslk.com/sl/1apPmF">https://dnlqa.xetslk.com/sl/1apPmF</a><br>前端简历指导&amp;大厂前端面试真题剖析-澄怀（简历） <a href="https://dnlqa.xetslk.com/sl/2Db6sz">https://dnlqa.xetslk.com/sl/2Db6sz</a><br>9月最新大厂二三面真题精讲（最新题） <a href="https://dnlqa.h5.xeknow.com/sl/2G2a0D">https://dnlqa.h5.xeknow.com/sl/2G2a0D</a><br>“金九”已过大半，“银十”前端offer收割指南（方法论） <a href="https://dnlqa.xetslk.com/sl/2Db6sz">https://dnlqa.xetslk.com/sl/2Db6sz</a><br>职业生涯规划不清晰 普通前端如何度过22岁到35岁这13年—澄怀 <a href="https://dnlqa.h5.xeknow.com/sl/3MpJ5Z">https://dnlqa.h5.xeknow.com/sl/3MpJ5Z</a><br>特别专题-阿里P8级前端专家现场职业规划-澄怀 <a href="https://dnlqa.h5.xeknow.com/sl/9BZq6">https://dnlqa.h5.xeknow.com/sl/9BZq6</a> </p>
<h3 id="项目难点-选一个深入了解"><a href="#项目难点-选一个深入了解" class="headerlink" title="项目难点 选一个深入了解"></a>项目难点 选一个深入了解</h3><p><a href="https://nwy3y7fy8w5.feishu.cn/docx/OEVrdpoJvoogDexs86rc5ftJnMf">https://nwy3y7fy8w5.feishu.cn/docx/OEVrdpoJvoogDexs86rc5ftJnMf</a></p>
<h3 id="稳定资源监控"><a href="#稳定资源监控" class="headerlink" title="稳定资源监控"></a>稳定资源监控</h3><p><a href="https://nwy3y7fy8w5.feishu.cn/docx/Kb19d5sOYoSavtxKKuGcvc0Fngf">https://nwy3y7fy8w5.feishu.cn/docx/Kb19d5sOYoSavtxKKuGcvc0Fngf</a></p>
<h3 id="军哥八股"><a href="#军哥八股" class="headerlink" title="军哥八股"></a>军哥八股</h3><p><a href="https://www.yuque.com/cuggz/interview">https://www.yuque.com/cuggz/interview</a></p>
<h3 id="招聘信息汇总"><a href="#招聘信息汇总" class="headerlink" title="招聘信息汇总"></a>招聘信息汇总</h3><p><a href="https://docs.qq.com/sheet/DTlpqbmRqWnBiSmVL?u=ac05b2502577441da3df57c9f78d10a8&amp;tab=BB08J2&amp;groupUin=d%25252B5xbqwvFUppXwCPYYeqOA%25253D%25253D&amp;ADUIN=1781163853&amp;ADSESSION=1712639627&amp;ADTAG=CLIENT.QQ.6061_.0&amp;ADPUBNO=27411&amp;jumpuin=1781163853">https://docs.qq.com/sheet/DTlpqbmRqWnBiSmVL?u=ac05b2502577441da3df57c9f78d10a8&amp;tab=BB08J2&amp;groupUin=d%25252B5xbqwvFUppXwCPYYeqOA%25253D%25253D&amp;ADUIN=1781163853&amp;ADSESSION=1712639627&amp;ADTAG=CLIENT.QQ.6061_.0&amp;ADPUBNO=27411&amp;jumpuin=1781163853</a></p>
<h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p>leetcode 100</p>
<p><a href="https://leetcode.cn/studyplan/top-100-liked/">https://leetcode.cn/studyplan/top-100-liked/</a></p>
<p>代码随想录 </p>
<p><a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
<h3 id="短视频播主推荐"><a href="#短视频播主推荐" class="headerlink" title="短视频播主推荐"></a>短视频播主推荐</h3><p>抖音：<strong>渡一</strong>      <strong>哲轩前端</strong>          九剑         大伟前端</p>
<p>微信公众号：前端之神   程序员sunday   前端充电宝</p>
<p>前端知识图谱</p>
<p><a href="https://f2e.tech/mindmap">https://f2e.tech/mindmap</a>? </p>
<p>免费课合集：<a href="https://qmdqi.xetlk.com/s/376rbn">https://qmdqi.xetlk.com/s/376rbn</a> </p>
<p>《前端场景题》飞书文档：<a href="https://u19tul1sz9g.feishu.cn/docx/CH7zd26fOonN5ixEEtxcBpSNnvc?from=from_copylink">https://u19tul1sz9g.feishu.cn/docx/CH7zd26fOonN5ixEEtxcBpSNnvc?from=from_copylink</a></p>
<p>工程化面试题：<a href="https://u19tul1sz9g.feishu.cn/docx/IBaXdgmAio5hWPxXr4fcndVNnIb?from=from_copylink">https://u19tul1sz9g.feishu.cn/docx/IBaXdgmAio5hWPxXr4fcndVNnIb?from=from_copylink</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[调用对象基本方法]]></title>
      <url>/2024/02/29/js%E9%AB%98%E7%BA%A7/Reflect/</url>
      <content type="html"><![CDATA[<p>在 JavaScript 的 <code>Reflect.get()</code> 方法中，<code>receiver</code> 参数是用来指定在获取属性时 <code>this</code> 应该绑定到哪个对象上的。这在处理 getter 函数或对象原型链时尤其重要，因为 <code>this</code> 的值决定了 getter 函数内部如何访问其他属性或执行其他操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;  </span><br><span class="line"> <span class="attr">_name</span>: <span class="string">&#x27;John&#x27;</span>,  </span><br><span class="line"> <span class="attr">age</span>: <span class="number">30</span>,  </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="variable language_">this</span>*.<span class="property">_name</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;  </span><br><span class="line"> <span class="title function_">get</span>(<span class="params">*target*, *prop*, *receiver*</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(*receiver*);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(*target*, *prop*,  *receiver*)  </span><br><span class="line">     <span class="comment">//return target[prop]//如果此刻使用这种方式 this会自动绑定target cong&#x27;er&#x27;shi</span></span><br><span class="line"> &#125;,  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 创建代理对象  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = **<span class="keyword">new</span>** *<span class="title class_">Proxy</span>*(target, handler);  </span><br><span class="line"><span class="keyword">let</span> target1=&#123;</span><br><span class="line"> <span class="attr">_name</span>:<span class="string">&quot;111&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"> target1.<span class="property">__proto__</span>=proxy</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(target1.<span class="property">name</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[动态路由结构 后端传来的]]></title>
      <url>/2024/02/28/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>“data”: {<br>        “1”: [<br>            {<br>                “name”: “&#x2F;Evaluation”,<br>                “title”: “资产管理”,<br>                “path”: “&#x2F;assetManagement”,<br>                “component”: “Layout”,<br>                “orderNum”: 1,<br>                “parentId”: 0,<br>                “icon”: “component”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: null,<br>                        “title”: “地图”,<br>                        “path”: “map”,<br>                        “component”: “assetManagement&#x2F;map&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 1,<br>                        “icon”: “color”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “车辆”,<br>                        “path”: “car”,<br>                        “component”: “assetManagement&#x2F;car&#x2F;index”,<br>                        “orderNum”: 3,<br>                        “parentId”: 1,<br>                        “icon”: “size”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “交通标志”,<br>                        “path”: “trafficLights”,<br>                        “component”: “assetManagement&#x2F;trafficLights&#x2F;index”,<br>                        “orderNum”: 5,<br>                        “parentId”: 1,<br>                        “icon”: “cascader”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “数据集”,<br>                        “path”: “data”,<br>                        “component”: “assetManagement&#x2F;data&#x2F;index”,<br>                        “orderNum”: 5,<br>                        “parentId”: 1,<br>                        “icon”: “form”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “车道线”,<br>                        “path”: “laneLine”,<br>                        “component”: “assetManagement&#x2F;laneLine&#x2F;index”,<br>                        “orderNum”: 7,<br>                        “parentId”: 1,<br>                        “icon”: “chart”,<br>                        “auth”: null<br>                    }<br>                ]<br>            },<br>            {<br>                “name”: “Largemodel”,<br>                “title”: “模型管理”,<br>                “path”: “&#x2F;modelManagement”,<br>                “component”: “Layout”,<br>                “orderNum”: 2,<br>                “parentId”: 0,<br>                “icon”: “table”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: null,<br>                        “title”: “模型管理”,<br>                        “path”: “index”,<br>                        “component”: “modelManagement&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 6,<br>                        “icon”: “table”,<br>                        “auth”: null<br>                    }<br>                ]<br>            },<br>            {<br>                “name”: “&#x2F;Case”,<br>                “title”: “自动驾驶任务评测”,<br>                “path”: “&#x2F;autoDriveEvaluation”,<br>                “component”: “Layout”,<br>                “orderNum”: 5,<br>                “parentId”: 0,<br>                “icon”: “example”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: “Case”,<br>                        “title”: “自动驾驶任务评测”,<br>                        “path”: “index”,<br>                        “component”: “autoDriveEvaluation&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 4,<br>                        “icon”: “example”,<br>                        “auth”: null<br>                    }<br>                ]<br>            }<br>        ],<br>        “2”: [<br>            {<br>                “name”: “SystemManage”,<br>                “title”: “系统管理”,<br>                “path”: “system”,<br>                “component”: “Layout”,<br>                “orderNum”: 1,<br>                “parentId”: 0,<br>                “icon”: “system”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: “”,<br>                        “title”: “用户管理”,<br>                        “path”: “user”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;user&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 13,<br>                        “icon”: “user”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: “RolesManager”,<br>                        “title”: “角色管理”,<br>                        “path”: “roles”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;role&#x2F;index”,<br>                        “orderNum”: 2,<br>                        “parentId”: 13,<br>                        “icon”: “peoples”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “用户组管理”,<br>                        “path”: “usergroup”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;userGroup&#x2F;index”,<br>                        “orderNum”: 3,<br>                        “parentId”: 13,<br>                        “icon”: “cascader”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: “Menumanager”,<br>                        “title”: “菜单管理”,<br>                        “path”: “menu”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;menu&#x2F;index”,<br>                        “orderNum”: 7,<br>                        “parentId”: 13,<br>                        “icon”: “dashboard”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: “DictManager”,<br>                        “title”: “字典管理”,<br>                        “path”: “dict”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;dict&#x2F;index”,<br>                        “orderNum”: 9,<br>                        “parentId”: 13,<br>                        “icon”: “dict”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: “FileManager”,<br>                        “title”: “文件管理”,<br>                        “path”: “file”,<br>                        “component”: “managementCenter&#x2F;system&#x2F;file&#x2F;index”,<br>                        “orderNum”: 11,<br>                        “parentId”: 13,<br>                        “icon”: “education”,<br>                        “auth”: null<br>                    }<br>                ]<br>            },<br>            {<br>                “name”: null,<br>                “title”: “数据管理”,<br>                “path”: “dataManagement”,<br>                “component”: “Layout”,<br>                “orderNum”: 3,<br>                “parentId”: 0,<br>                “icon”: “edit”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: null,<br>                        “title”: “数据集管理”,<br>                        “path”: “dataset”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;dataset&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 54,<br>                        “icon”: “component”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “地图管理”,<br>                        “path”: “manageMap”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;mapManagement&#x2F;index”,<br>                        “orderNum”: 3,<br>                        “parentId”: 54,<br>                        “icon”: “button”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “地图线路管理”,<br>                        “path”: “mapRoute”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;mapRouteManagement&#x2F;index”,<br>                        “orderNum”: 5,<br>                        “parentId”: 54,<br>                        “icon”: “druid”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “车辆管理”,<br>                        “path”: “manageCar”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;carManagement&#x2F;index”,<br>                        “orderNum”: 7,<br>                        “parentId”: 54,<br>                        “icon”: “dashboard”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “交通标志管理”,<br>                        “path”: “manageTraffic”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;trafficManagement&#x2F;index”,<br>                        “orderNum”: 7,<br>                        “parentId”: 54,<br>                        “icon”: “build”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “感知模型”,<br>                        “path”: “perceptualModel”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;perceptualModel&#x2F;index”,<br>                        “orderNum”: 9,<br>                        “parentId”: 54,<br>                        “icon”: “example”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “仿真资产”,<br>                        “path”: “simulationAsset”,<br>                        “component”: “managementCenter&#x2F;dataManagement&#x2F;simulationAsset&#x2F;index”,<br>                        “orderNum”: 11,<br>                        “parentId”: 54,<br>                        “icon”: “bug”,<br>                        “auth”: null<br>                    }<br>                ]<br>            },<br>            {<br>                “name”: “&#x2F;Data”,<br>                “title”: “算法管理”,<br>                “path”: “algorithm”,<br>                “component”: “Layout”,<br>                “orderNum”: 9,<br>                “parentId”: 0,<br>                “icon”: “form”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: null,<br>                        “title”: “待发布”,<br>                        “path”: “toPublish”,<br>                        “component”: “managementCenter&#x2F;algorithm&#x2F;topublish&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 16,<br>                        “icon”: “list”,<br>                        “auth”: null<br>                    },<br>                    {<br>                        “name”: null,<br>                        “title”: “已发布”,<br>                        “path”: “publish”,<br>                        “component”: “managementCenter&#x2F;algorithm&#x2F;publish&#x2F;index”,<br>                        “orderNum”: 2,<br>                        “parentId”: 16,<br>                        “icon”: “guide”,<br>                        “auth”: null<br>                    }<br>                ]<br>            },<br>            {<br>                “name”: “&#x2F;Scene”,<br>                “title”: “场景管理”,<br>                “path”: “scene”,<br>                “component”: “Layout”,<br>                “orderNum”: 11,<br>                “parentId”: 0,<br>                “icon”: “clipboard”,<br>                “auth”: null,<br>                “children”: [<br>                    {<br>                        “name”: “Edit”,<br>                        “title”: “场景管理”,<br>                        “path”: “index”,<br>                        “component”: “managementCenter&#x2F;scene&#x2F;index”,<br>                        “orderNum”: 1,<br>                        “parentId”: 17,<br>                        “icon”: “nested”,<br>                        “auth”: null<br>                    }<br>                ]<br>            }<br>        ]<br>    },</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[笔试题]]></title>
      <url>/2024/02/27/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="string">``</span><span class="attr">name</span>: <span class="string">``</span><span class="string">&#x27;张三&#x27;</span><span class="string">``</span>,</span><br><span class="line">  <span class="string">``</span><span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span><span class="variable language_">this</span><span class="string">``</span>.<span class="property">name</span>;</span><br><span class="line">  <span class="string">``</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="string">``</span><span class="attr">name</span>: <span class="string">``</span><span class="string">&#x27;李四&#x27;</span><span class="string">``</span>,</span><br><span class="line">  <span class="string">``</span><span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span><span class="variable language_">super</span><span class="string">``</span>.<span class="title function_">getName</span>();</span><br><span class="line">  <span class="string">``</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj2, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure>

<p>答  在 JavaScript 中，<code>super</code> 关键字主要用于访问对象的原型对象中的属性或方法，而不是用于访问父类的属性或方法。在原型链中，一个对象的原型对象并不一定是它的父类，而是它所继承的对象。</p>
<p>当我们使用 <code>Object.setPrototypeOf(obj2, obj1)</code> 将 <code>obj1</code> 设置为 <code>obj2</code> 的原型时，<code>obj2</code> 实际上是继承了 <code>obj1</code> 对象的属性和方法，而不是从一个类继承而来。因此，在这个情况下，<code>super</code> 所指向的是 <code>obj1</code> 这个原型对象，而不是父类。</p>
<p>在 JavaScript 中，类（class）和原型（prototype）是两种不同的面向对象编程的机制。在 ES6 中引入了类的概念，但本质上 JavaScript 还是基于原型继承的。所以在这个上下文中，<code>super</code> 关键字指向对象的原型，而不是类的父类。 <strong>super指向父类</strong></p>
<h5 id="2下列关于SSL说法错误的是-。"><a href="#2下列关于SSL说法错误的是-。" class="headerlink" title="2下列关于SSL说法错误的是__。"></a>2下列关于SSL说法错误的是__。</h5><p>A</p>
<p>SSL是TCP加强版本。</p>
<p>B</p>
<p>SSL通过采用机密性、数据完整性、服务器鉴别和客户鉴别来强化TCP。 🐕</p>
<p>C</p>
<p>SSL强制网络两端的用户使用特定的对称密钥算法。</p>
<p>D</p>
<p>SSL记录由类型字段，版本字段，长度字段，数据字段，MAC字段组成。</p>
<p>＋号的优先级优于问好</p>
<p>http  通过开启Keep-Alive，可以保持连接特性</p>
<h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span> = &#123;&#125; <span class="comment">// &#x27;run&#x27;:[fn] </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">type, cb</span>) &#123; <span class="comment">// 添加订阅事件与对应回调函数的记录</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">event</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[type] = [cb]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[type].<span class="title function_">push</span>(cb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">once</span>(<span class="params">type, cb</span>) &#123; <span class="comment">// 添加订阅一次事件 在事件触发后取消订阅</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">            <span class="title function_">cb</span>(...args)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">off</span>(type, fn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">on</span>(type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123; <span class="comment">// 负责调用事件对应的回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">event</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">cb</span>(...args)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">off</span>(<span class="params">type,cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">event</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[type] = <span class="variable language_">this</span>.<span class="property">event</span>[type].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== cb) <span class="comment">// 过滤掉 cb 并以新的数组形式返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ev = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...args,<span class="string">&#x27;有人调用了fn1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...args,<span class="string">&#x27;有人调用了fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn3</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...args,<span class="string">&#x27;有人调用了fn3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev.<span class="title function_">on</span>(<span class="string">&#x27;run&#x27;</span>, fn1) <span class="comment">// 订阅 run 事件 并且执行fn1函数</span></span><br><span class="line">ev.<span class="title function_">once</span>(<span class="string">&#x27;run&#x27;</span>, fn2) <span class="comment">// 只订阅一次 run 事件 并且执行fn2函数</span></span><br><span class="line"></span><br><span class="line">ev.<span class="title function_">on</span>(<span class="string">&#x27;run&#x27;</span>, fn3)</span><br><span class="line">ev.<span class="title function_">off</span>(<span class="string">&#x27;run&#x27;</span>,fn3) <span class="comment">// 取消订阅run事件</span></span><br><span class="line"></span><br><span class="line">ev.<span class="title function_">emit</span>(<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;这是第一次派发事件&#x27;</span>)</span><br><span class="line">ev.<span class="title function_">emit</span>(<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;这是第二次派发事件&#x27;</span>)</span><br><span class="line">ev.<span class="title function_">emit</span>(<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;这是第三次派发事件&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/02/25/js%E9%AB%98%E7%BA%A7/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20240225171101183.png" alt="image-20240225171101183"></p>
<p><img src="/../../images/image-20240225171716395.png" alt="image-20240225171716395"></p>
<p>循环引用：对象a的指针指向对象b 相反 对象b指向a</p>
<p>这样就意味着他们的引用数都为2</p>
<p>标记清理不存在这个问题 因为函数结束后 两个对象都不在作用域中了</p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>这是目前浏览器大多基于标记清除法。我们可以分为两个阶段：</p>
<ul>
<li><strong>标记</strong>：从根节点遍历为每个可以访问到的对象都打上一个标记，表示该对象可达。</li>
<li><strong>清除</strong>：在没有可用分块时，对堆内存遍历，若没有被标记为可达对象就将其回收。</li>
</ul>
<h4 id="v8引擎内存管理"><a href="#v8引擎内存管理" class="headerlink" title="v8引擎内存管理"></a>v8引擎内存管理</h4><p><img src="/../../images/image-20240225173421688.png" alt="image-20240225173421688"></p>
<p><img src="/../../images/image-20240225173503649.png" alt="image-20240225173503649"></p>
<p><img src="/../../images/image-20240225204250184.png" alt="image-20240225204250184"></p>
<p><img src="/../../images/image-20240225204316549.png" alt="image-20240225204316549"></p>
<p><img src="/../../images/image-20240225204328478.png" alt="image-20240225204328478"></p>
<p><img src="/../../images/image-20240225204426530.png" alt="image-20240225204426530"></p>
<p><img src="/../../images/image-20240225204543096.png" alt="image-20240225204543096"></p>
<h3 id="五、分代式垃圾回收机制"><a href="#五、分代式垃圾回收机制" class="headerlink" title="五、分代式垃圾回收机制"></a>五、分代式垃圾回收机制</h3><p>把分代式垃圾回收机制单独拎出来是因为涉及内容较多，容易混淆。v8中将内存分成了两个区，新生代和老生代。新生代对象存活时间较短，内存通常支持1~8MB。而老生代存储存活时间较长或常驻内存的对象。对于新老两块内存区域的垃圾回收频率不同，所以V8 采用了两个垃圾回收器来管控。<br>视图如下：</p>
<h5 id="1、-新生代垃圾回收"><a href="#1、-新生代垃圾回收" class="headerlink" title="1、 新生代垃圾回收"></a>1、 新生代垃圾回收</h5><p>新生代垃圾回收通过Scavenge策略进行垃圾回收，在具体实现中，主要采用了一种复制式的方法Cheney算法。Cheney算法将堆内存也分为两个区，一个使用状态的空间我们称为使用区。一个处于闲置状态的空间称为空闲区。新加入的对象都会被存放到使用区，当使用区快被写满时，就执行一次垃圾回收操作。</p>
<p>（1）垃圾回收流程<br>先对使用区中的活动做标记<br>标记完成后，将使用区的活动对象复制进空闲区并进行排序<br>将原先使用区对象占用的空间释放<br>最后进行角色互换，把空闲区变为使用区，使用区变为空闲区<br>（2）新生代对象何时会到老生代？<br>第一种情况：经过多次复制后依然存活的对象会被认为是生命周期较强的对象，会被移到老生代管理。<br>第二种情况：如果复制一个对象到空闲区时，空闲区空间占用超过25%，那么这个对象将被移到老生代区域。原因是，当完成Scavenge回收后，空闲区转变成使用区，需继续进行内存分配，若占比过大，将会影响后续内存的分配。</p>
<p>（3）并行回收<br>Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。那1·此V8引入了并行回收机制。<br>新生代对象空间就采用并行策略。在垃圾回收过程中，启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空闲区。由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。</p>
<h5 id="2、老生代垃圾回收"><a href="#2、老生代垃圾回收" class="headerlink" title="2、老生代垃圾回收"></a>2、老生代垃圾回收</h5><p>老生代数据大多是存活的对象，不需要时常清除更新，所以采用上面提到的标记清除法来进行垃圾回收。因为上面也提到标记清除后会产生大量内存碎片，所以V8就采用了上文所说的标记整理法来解决这个问题。</p>
<p>（1）增量标记<br>并行策略虽然可以增加垃圾回收的效率，对于新生代这样存放较小对象的回收器能有很好的优化，但其实还是全停顿式的。对于存放较大对象的老生代来说，这些较大对象GC时哪怕使用并行策略依旧会消耗大量时间。所以V8对老生代进行了优化，从全停顿标记切换到了增量标记。<br>增量标记：就是将一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。<br>问题来了，小GC标记执行完后是如何暂停执行JS任务，而后又是如何进行下一次小GC 标记？如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？V8解决这两个问题的方法分别是三色标记法和写屏障。</p>
<p>1）解决问题一：三色标记法<br>标记清理法区分是通过非黑即白的策略，但这样便会出现在增量标记时，内存中黑白都有，我们无法区分下一步是什么？所以采用了三色标记法，使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：黑（11），白（00），灰（10）。</p>
<p>黑色表示对象自身及对象的引用都被标记（已检查状态）<br>白色表示未被标记的对象（初始状态）<br>灰色表示自身被标记，自身的引用未被标记（待检查状态）<br>执行流程如下：</p>
<p>初始将所有对象都是白色<br>从root对象开始，先将root对象标记为灰色并推入标记工作表中<br>当收集器从标记工作表中弹出对象并访问他的所有引用对象时，自身灰色就会变成黑色。<br>将自身的下一个引用对象标记为灰色<br>一直这样执行下去，直到没有可以被标记为灰色的对象时，剩下的白色对象都是不可达的，进入清理阶段。恢复时从灰色标记对象开始执行。<br>2）解决问题二：写屏障<br>为了解决黑色对象在程序执行中被新添加引用或已经标记黑色的被引用对象不再被引用了。写屏障就有了以下两个变化：</p>
<p>不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。<br>Write-barrier 机制强制不变黑的对象指向白色对象。这个也被称作强三色不变性。所以一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记。</p>
<p>举个例子来说，假设我们有一个对象A，它原本引用了一个对象B。在并发标记的过程中，A被标记为了黑色，B被标记为了灰色。然而，在某个时刻，A的引用关系发生了变化，它不再引用B，而是引用了一个新的对象C。如果没有写屏障，垃圾回收器可能无法及时感知到这个变化，导致B成为了浮动垃圾。</p>
<p>但是，如果我们使用了写屏障，那么在A的引用关系发生变化时，写屏障会被触发。它可以记录下这个变化，或者在适当的时候重新标记B为白色，使其在下一次垃圾回收时被正确回收。这样，我们就避免了浮动垃圾的产生，提高了垃圾回收的效率和准确性</p>
<p>（2）懒性清理<br>增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。</p>
<p>并发回收<br>并发主要发生在工作线程上。当在工作线程（辅助线程）执行GC是，应用程序可以继续在主线程运行并不会被挂起。<br>这也是有问题的，因为GC也在进行，应用程序也在执行，此时对象的引用关系随时都有可能变化，所以之前做的一些标记就需要改变，所以需要读写锁机制来控制这一点。</p>
<h3 id="四，垃圾回收算法"><a href="#四，垃圾回收算法" class="headerlink" title="四，垃圾回收算法"></a>四，垃圾回收算法</h3><p>V8使用了一种高效的垃圾回收机制来管理内存。它主要使用了<code>分代垃圾回收</code>策略，将对象分为新生代和老生代，分别使用不同的算法来进行内存回收，如副垃圾回收器（Scavenger）处理新生代对象的回收，而标记-清除（Mark-Sweep）、标记-压缩（Mark-Compact）算法则用于老生代对象。</p>
<h4 id="闭包如何导致内存泄露"><a href="#闭包如何导致内存泄露" class="headerlink" title="闭包如何导致内存泄露"></a>闭包如何导致内存泄露</h4><p><img src="/../../images/image-20240401210941510.png" alt="image-20240401210941510"></p>
<p><img src="/../../images/image-20240401211155173.png" alt="image-20240401211155173"></p>
<p><img src="/../../images/image-20240401211806803.png" alt="image-20240401211806803"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[async和awiat原理]]></title>
      <url>/2024/02/25/js%E9%AB%98%E7%BA%A7/async%E5%92%8Cawiat%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="async和await语法"><a href="#async和await语法" class="headerlink" title="async和await语法"></a>async和await语法</h3><p>1.<code>async</code>函数返回一个 Promise 对象，<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。<br> \2. 只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。<br> 3.<code>await</code> 后面跟的是一个 <code>Promise</code> 对象，如果不是,则会包裹一层 <code>Promise.resolve()</code></p>
<h3 id="async函数实现原理"><a href="#async函数实现原理" class="headerlink" title="async函数实现原理"></a>async函数实现原理</h3><h4 id="async-函数的实现原理，就是将-Generator-函数和自动执行器，包装在一个函数里，简而言之-就是-Generator-函数的语法糖。"><a href="#async-函数的实现原理，就是将-Generator-函数和自动执行器，包装在一个函数里，简而言之-就是-Generator-函数的语法糖。" class="headerlink" title="async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里，简而言之,就是 Generator 函数的语法糖。"></a>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里，简而言之,就是 Generator 函数的语法糖。</h4><p><code>Generator</code>函数?<br> <code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态<br> Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// generator函数基本用法</span><br><span class="line">function* generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  return 4;</span><br><span class="line">&#125;</span><br><span class="line">const self = generator();</span><br><span class="line">console.log(self.next()); //&#123; value: 1, done: false &#125;</span><br><span class="line">console.log(self.next()); //&#123; value: 2, done: false &#125;</span><br><span class="line">console.log(self.next()); //&#123; value: 3, done: false &#125;</span><br><span class="line">console.log(self.next()); //&#123; value: 4, done: true  &#125;</span><br><span class="line">//如果不写return 则调用第四次self.next()为&#123; value: undefined, done: true&#125;</span><br><span class="line">//generator+promise使用</span><br><span class="line">function* generator() &#123;</span><br><span class="line">  yield Promise.resolve(&quot;1&quot;);</span><br><span class="line">  yield Promise.resolve(&quot;2&quot;);</span><br><span class="line">  yield Promise.resolve(&quot;3&quot;);</span><br><span class="line">  return Promise.resolve(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const self = generator();</span><br><span class="line">const next1 = self.next();</span><br><span class="line">next1.value.then((res1) =&gt; &#123;</span><br><span class="line">  console.log(res1);</span><br><span class="line">  const next2 = self.next();</span><br><span class="line">  next2.value.then((res2) =&gt; &#123;</span><br><span class="line">    console.log(res2);</span><br><span class="line">    //...往下推</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//1,2</span><br></pre></td></tr></table></figure>

<p>接下来是原理实现 <code>spawn</code>函数就是自动执行器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于下面代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genFn</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> gen = <span class="title function_">genFn</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextFn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      next = <span class="title function_">nextFn</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> gen.<span class="title function_">next</span>(v);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/02/22/%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：一些开发小工具"><a href="#title：一些开发小工具" class="headerlink" title="title：一些开发小工具"></a>title：一些开发小工具</h2><p>随机图片<img src="/../images/image-20240222172856180.png" alt="image-20240222172856180"></p>
<p><a href="https://picsum.photos/200/300">https://picsum.photos/200/300</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端]]></title>
      <url>/2024/01/29/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p><strong>5 移动端</strong> 开发的必不可少的一个环节就是 <strong>移动端网页的适配</strong>，因为 <strong>UI</strong> 通常只会提供 <strong>大小固定的设计稿</strong>，而各种不同移动设备具有不同的页面分辨率和大小，所以适配的目的就是让一份设计稿在不同移动设备上表现出一致性。</p>
<p>虽然现如今各种插件都可以帮助我们快速配置完成，例如 <a href="https://link.juejin.cn/?target=https://github.com/amfe/lib-flexible/blob/master/src/flexible.js"><strong><code>lib-flexible</code></strong></a>、<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/postcss-pxtorem"><strong><code>postcss-pxtorem</code></strong></a>、<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/postcss-px-to-viewport"><strong><code>postcss-px-to-viewport</code></strong></a> 等等，但不少小伙伴在被问及相关原理时却很难说清楚，那么本篇文章我们就一起来探究一下其中原理吧！！！</p>
<p><img src="/../../images/bb2e443a407c4ab9942a98cd82c29106tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="2916D818.gif"></p>
<p><strong>文中有不当之处，欢迎在评论区指正！！！</strong></p>
<h1 id="CSS-中的尺寸单位"><a href="#CSS-中的尺寸单位" class="headerlink" title="CSS 中的尺寸单位"></a>CSS 中的尺寸单位</h1><p>在了解具体的适配方案之前，我们先把 <strong>CSS</strong> 中适配会涉及到的相关尺寸单位进行一个了解吧，总结起来就是一句话：<strong>CSS 中的尺寸单位都是 <code>相对长度单位</code>，只是相对的目标不同</strong>。</p>
<h2 id="px-像素单位"><a href="#px-像素单位" class="headerlink" title="px 像素单位"></a>px 像素单位</h2><p><strong>px</strong> 全称为 <strong>pixel（<code>像素</code>）</strong>，它是相对于 <strong>屏幕显示器分辨率（<code>桌面设定的分辨率，不是显示器的物理分辨率</code>）</strong> 而言的，在 <strong>相同&#x2F;不同</strong> 的设备上 <strong>1px</strong> 表示多个 <strong>设备像素</strong>。</p>
<p>当 <strong>一个像素点越大</strong> 时, 呈现的图像就会 <strong>越模糊</strong>；当一个像素点越小时, 像素点就会 <strong>越密集</strong>, 呈现的图像就会 <strong>越清晰</strong>。</p>
<p><img src="/../../images/a0195f1abf08479ab7d2df286e7c449etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<h2 id="em-相对单位"><a href="#em-相对单位" class="headerlink" title="em 相对单位"></a>em 相对单位</h2><p>好多人都认为 <strong>em</strong> 就是相对于 <strong>父元素 font-size</strong>，实际上在不同的 <strong>CSS</strong> 属性当中使用 <strong>em</strong> 其相对的目标也是不同，如下：</p>
<ul>
<li><p>用于 <strong>font-size</strong> 中则是相对于 <strong>父元素 font-size</strong> 大小</p>
<p><img src="/../../images/ff5b693b1c894670b42c40d785a17abetplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
<li><p>用于 <strong>其他属性（如 width，height）</strong> 中使用是相对于 <strong>自身 font-size</strong> 大小</p>
<p><img src="/../../images/eb698b9310934dbaa7a4c0c77d2899f5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
</ul>
<p>值得注意的是，若 <strong>当前元素&#x2F;父元素</strong> 的 <strong>font-size</strong> 未设置，由于 <strong>font-size</strong> 属性值可被继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小，即 <strong>font-size &#x3D; 16px</strong>。</p>
<h2 id="rem-root-em-相对单位"><a href="#rem-root-em-相对单位" class="headerlink" title="rem (root em) 相对单位"></a>rem (root em) 相对单位</h2><p><strong>rem</strong> 是 <strong>CSS3</strong> 新增的一个相对单位，它只相对于 <strong>根元素 html</strong> 的 <strong>font-size</strong> 字体大小，<strong>rem</strong> 与 <strong>em</strong> 的区别在于：</p>
<ul>
<li><p><strong><code>rem</code></strong> 相对于 <strong><code>html</code></strong> 根元素的，因此在 <strong><code>body</code></strong> 标签里面设置 <strong><code>font-size</code></strong> 是不起作用的</p>
</li>
<li><p>因此 <strong><code>rem</code></strong> 就可做到 <strong>目标元素</strong> 与 <strong>根元素</strong> 间保持 <strong>成比例</strong> 的大小关系，又可以避免字体大小逐层复合的连锁反应等，例如公共的字体大小可以在 <strong><code>body</code></strong> 中设置即可</p>
<p><img src="/../../images/e0186693a58a4b82bbfe16843ad09b6atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
</ul>
<p><img src="/../../images/3191d4ddd20e46cb8d01ae11dca86cc3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<h2 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h2><p><strong>vw</strong> 全称是 <strong>viewport width</strong>，代表的是 <strong>视口的宽度</strong>，相对于 <strong>视口 viewport 的 宽度</strong></p>
<p><strong>vh</strong> 全称是 <strong>viewport height</strong>，代表的是 <strong>视口的高度</strong>，相对于 <strong>视口 viewport 的 高度</strong></p>
<p><strong>vw</strong> 和 <strong>vh</strong> 是将 <strong>视口 宽&#x2F;高</strong> 都分成 <strong>100 份</strong>，因此 <strong><code>100vw = 视口宽</code>、<code>100vh = 视口高</code></strong></p>
<blockquote>
<p><strong>与之相关的还有 <code>vmin</code> 和 <code>vmax</code> 两个单位</strong></p>
</blockquote>
<ul>
<li><strong>vmin</strong> 和 <strong>vmax</strong> 代表的是 <strong>视口宽度</strong> 和 <strong>视口高度</strong> 中的 <strong>最小值</strong> 和 <strong>最大值</strong></li>
<li><strong><code>vmin</code> &#x3D; 视口高度 <code>vh</code> 和 宽度 <code>vw</code> 间的最小值</strong></li>
<li><strong><code>vmax</code> &#x3D; 视口高度 <code>vh</code> 和 宽度 <code>vw</code> 间的最大值</strong></li>
</ul>
<p><img src="/../../images/59eaf1d1faec4099ad553165946f1a61tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<h1 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h1><h2 id="rem-适配（等比适配）"><a href="#rem-适配（等比适配）" class="headerlink" title="rem 适配（等比适配）"></a>rem 适配（等比适配）</h2><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li><p>将 </p>
<p>设备视口</p>
<p> 划分成 </p>
<p>n 份</p>
<p>， </p>
<p>n</p>
<p> 可以是 </p>
<p>任何正确的值（如 <code>flexible.js</code> 中的 <code>n = 10</code>）</p>
<ul>
<li>设置 <strong>设备视口 <code>根元素 html</code></strong> 的 **<code>font-size = 设备视口宽 ÷ 份数 n</code>**，即得到 <strong>设备视口 <code>1</code> rem</strong> 到底表示 <strong>多少设备视口 px</strong></li>
</ul>
</li>
<li><p>将 </p>
<p>设计稿</p>
<p> 也同样划分成 </p>
<p>n 份</p>
<p>，此时 </p>
<p>设计稿中的 <code>a</code> px</p>
<p> 对应 </p>
<p>设备视口 <code>b</code> rem</p>
<p> 的计算方式为</p>
<ul>
<li><strong>设备视口 <code>b</code> rem &#x3D; 设计稿 <code>a</code> px ÷ (设计稿 <code>宽</code> ÷ <code>n</code> 份)</strong></li>
</ul>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><h4 id="设备视口宽为-375px"><a href="#设备视口宽为-375px" class="headerlink" title="设备视口宽为 375px"></a>设备视口宽为 375px</h4><p><img src="/../../images/380624e487a64c978f3742743a9d0dectplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<ul>
<li><p><strong>将设备视口分成 10 份，设置 <code>根元素 html 的 font-size</code> &#x3D; <code>375</code> ÷ <code>10</code> &#x3D; <code>37.5</code> px，即 <code>1</code> rem &#x3D; <code>37.5</code> px</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js复制代码(<span class="keyword">function</span> (<span class="params">n = <span class="number">10</span></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setRem</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> rem = dEl.<span class="property">clientWidth</span> / n;</span><br><span class="line">        dEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem  + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化执行</span></span><br><span class="line">    <span class="title function_">setRem</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视口大小变动时执行</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onresize</span> = setRem</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="设计稿宽为-750px"><a href="#设计稿宽为-750px" class="headerlink" title="设计稿宽为 750px"></a>设计稿宽为 750px</h4><p><img src="/../../images/9e057ee41eff463b839df0f91c67c190tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<ul>
<li><p><strong>将 设计稿 也分成 10 份，每份大小 &#x3D; <code>750</code> ÷ <code>10</code> &#x3D; <code>75</code> px</strong></p>
</li>
<li><p><strong>此时 <code>设计稿</code> 上的 <code>&quot;点我拍照&quot;（font-size: 34px）</code> 的文案转换成符合 <code>设备视口</code> 对应的 <code>rem</code></strong> 就为：</p>
<p><img src="/../../images/06925e60473f4fc0a1244f2a03e90117tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<ul>
<li><strong>设备视口 中 <code>文字 font-size</code> &#x3D; <code>34 ÷ 75</code> &#x3D; <code>0.4533333333333333</code> rem ≈ <code>0.45</code> rem</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>【<code>注意</code>】 一般计算结果（<code>人为计算、插件自动化自动化计算</code>）都不会使用这么长的小数位，比如 <code>0.4533333333333333</code> rem ≈ <code>0.45</code> rem，此时：</strong></p>
<ul>
<li><strong>原始值 <code>0.4533333333333333</code> rem &#x3D; <code>0.4533333333333333</code> * <code>37.5</code> &#x3D; <code>17</code> px</strong></li>
<li><strong>保留两位小数后的值 <code>0.45</code> rem &#x3D; <code>0.45</code> * <code>37.5</code> &#x3D; <code>16.875</code> px</strong></li>
</ul>
<p><strong>而在肉眼观察下 <code>16.875</code> px 和 <code>17</code> px 是没有差别的，因此可以忽略不计</strong></p>
</blockquote>
<h3 id="用-amfe-flexible-和-postcss-pxtorem-验证"><a href="#用-amfe-flexible-和-postcss-pxtorem-验证" class="headerlink" title="用 amfe-flexible 和 postcss-pxtorem 验证"></a>用 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/amfe-flexible"><strong>amfe-flexible</strong></a> 和 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/postcss-pxtorem?activeTab=readme"><strong>postcss-pxtorem</strong></a> 验证</h3><ul>
<li><p><strong>文本和原始样式</strong></p>
<p><img src="/../../images/41f1a9992daf4fc0b97eb095ea677ef9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
<li><p><a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/amfe-flexible"><strong><code>amfe-flexible</code></strong></a> <strong>和</strong> <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/postcss-pxtorem?activeTab=readme"><strong><code>postcss-pxtorem</code></strong></a> <strong>配置</strong></p>
<p><img src="/../../images/01504131c0fe45b3b037085e57f39891tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<p><img src="/../../images/4e476925beb74879b29acebb2298cfddtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
<li><p><strong>最终展示效果</strong></p>
<p><img src="/../../images/f264ce2c08244c25809af9d5f99f1498tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
</li>
</ul>
<h5 id="配置postcss-pxtorem"><a href="#配置postcss-pxtorem" class="headerlink" title="配置postcss-pxtorem"></a>配置postcss-pxtorem</h5><p><em>module</em>.<em>exports</em> &#x3D; {</p>
<p> plugins: {</p>
<p>  “postcss-pxtorem”: {</p>
<p>   rootValue:192, &#x2F;&#x2F; 设计稿宽度的1&#x2F; 10 例如设计稿按照 1920设计 此处就为192</p>
<p>   propList: [“*”, “!border”], &#x2F;&#x2F; 除 border 外所有px 转 rem</p>
<p>  },</p>
<p> },</p>
<p>};</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[js继承的几种方式]]></title>
      <url>/2024/01/26/js%E9%AB%98%E7%BA%A7/js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20240220160509656.png" alt="image-20240220160509656"></p>
<p><img src="/../../images/image-20240220162628935.png" alt="image-20240220162628935"></p>
<p><img src="/../../images/image-20240220162636631.png" alt="image-20240220162636631"></p>
<h4 id="函数式继承"><a href="#函数式继承" class="headerlink" title="函数式继承"></a>函数式继承</h4><p><img src="/../../images/image-20240220162707440.png" alt="image-20240220162707440"></p>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p><img src="/../../images/image-20240220162717742.png" alt="image-20240220162717742"></p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p><img src="/../../images/image-20240220162736984.png" alt="image-20240220162736984"></p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p> 可以在子类原型上扩展新的属性和方法，而不影响父类的原型。</p>
<p><img src="/../../images/image-20240220162809298.png" alt="image-20240220162809298"></p>
<h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><p><img src="/../../images/image-20240220162914674.png" alt="image-20240220162914674"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原型链继承   c.prototype&#x3D;&#x3D;new p()  缺点不能参数 对于父类身上的引用属性 因为不同的实例指向的同一块区间 会窜改</p>
<p>函数继承   p.call(c)    解决上面两个问题  出现问题是不能继承父类原型上的方法</p>
<p>组合   解决上面 缺点两次调用父类构造函数</p>
<p>寄生组合 利用object.create(p.prototype) 返回一个实例（这个实例的原型指向p的原型）     </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[开放题]]></title>
      <url>/2024/01/25/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E5%BC%80%E6%94%BE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h5 id="uni-app怎么编译到其他平台"><a href="#uni-app怎么编译到其他平台" class="headerlink" title="uni-app怎么编译到其他平台"></a>uni-app怎么编译到其他平台</h5><p>当使用uni-app进行开发时，你可以轻松地将项目编译为H5网站和小程序。下面我将分别介绍这两个编译过程：</p>
<h6 id="编译到H5网"><a href="#编译到H5网" class="headerlink" title="编译到H5网"></a>编译到H5网</h6><ol>
<li><p>创建与编写代码</p>
<p>：</p>
<ul>
<li>首先，在uni-app中创建你的项目，并编写所需的功能代码。</li>
</ul>
</li>
<li><p>配置H5设置</p>
<p>：</p>
<ul>
<li>编辑项目配置文件<code>manifest.json</code>，并找到“h5配置”部分，根据需要进行修改。这包括设置应用的标题、图标、启动页等。</li>
</ul>
</li>
<li><p>编译项目</p>
<p>：</p>
<ul>
<li>点击菜单栏的“发行”选项，然后选择“网站-H5手机版”。这将开始编译整个项目，生成纯静态的HTML、CSS和JS代码。</li>
</ul>
</li>
<li><p>发布到服务器</p>
<p>：</p>
<ul>
<li>编译完成后，你会在项目目录下的<code>/unpackage/dist/build/h5</code>找到生成的静态文件。将这些文件复制并发布到你的Web服务器根目录下。这可以是一个本地的Web服务器，如XAMPP，或者是一个云服务器。</li>
<li>如果使用本地服务器，比如XAMPP，你需要将文件复制到XAMPP的<code>htdocs</code>目录下，然后启动XAMPP。之后，你可以在浏览器中通过访问<code>127.0.0.1/index.html</code>来查看你的H5网站。</li>
</ul>
</li>
</ol>
<h3 id="编译到小程序"><a href="#编译到小程序" class="headerlink" title="编译到小程序"></a>编译到小程序</h3><ol>
<li><p>创建小程序项目</p>
<p>：</p>
<ul>
<li>使用微信开发者工具或其他小程序开发工具创建一个新的小程序项目。填写相应的项目信息，并选择一个合适的项目目录。</li>
</ul>
</li>
<li><p>导入uni-app代码</p>
<p>：</p>
<ul>
<li>将uni-app项目的<code>src</code>目录下的代码复制到小程序项目的相应位置。确保将<code>pages.json</code>、<code>main.js</code>和<code>App.vue</code>等核心文件复制到小程序项目的根目录。</li>
</ul>
</li>
<li><p>修改项目配置</p>
<p>：</p>
<ul>
<li>打开小程序项目的<code>app.json</code>文件，修改其中的页面路径，使其与uni-app代码的结构相匹配。这确保了小程序能够正确加载和显示uni-app的页面和组件。</li>
</ul>
</li>
<li><p>配置与运行</p>
<p>：</p>
<ul>
<li>在uni-app项目中，你可能还需要配置一些小程序特定的设置，如<code>manifest.json</code>中的微信小程序AppID。</li>
<li>使用HBuilderX或其他开发工具，点击运行到小程序的功能。确保你已经登录了微信开发者工具，并且正确配置了开发者工具的路径。</li>
</ul>
</li>
<li><p>预览与发布</p>
<p>：</p>
<ul>
<li>运行成功后，你可以在微信开发者工具中预览你的小程序。完成开发和测试后，你可以通过微信开发者工具提交审核和发布你的小程序。</li>
</ul>
</li>
</ol>
<p>请注意，具体的编译和发布流程可能因uni-app的版本和工具链的不同而有所差异。建议参考uni-app的官方文档和社区资源，以获取最准确和最新的编译指南。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/01/24/%E6%95%B0%E6%8D%AE%E7%A0%94%E7%A9%B6%E9%99%A2/</url>
      <content type="html"><![CDATA[<h3 id="御风"><a href="#御风" class="headerlink" title="御风"></a>御风</h3><p>账号 <a href="mailto:&#x31;&#51;&#x36;&#x33;&#54;&#x33;&#57;&#48;&#48;&#53;&#x33;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#51;&#x36;&#x33;&#54;&#x33;&#57;&#48;&#48;&#53;&#x33;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>密码  Prec123456</p>
<p>【腾讯文档】园区环境地址<br><a href="https://docs.qq.com/sheet/DSkRrSFZLQnV1WXZp?tab=BB08J2">https://docs.qq.com/sheet/DSkRrSFZLQnV1WXZp?tab=BB08J2</a></p>
<p> remotes&#x2F;origin&#x2F;metadverse_v1.0</p>
<p><a href="http://221.122.70.196:9000/zentao/my.html">http://221.122.70.196:9000/zentao/my.html</a> 禅道</p>
<p><a href="http://172.16.0.45:7000/users/sign_in">http://172.16.0.45:7000/users/sign_in</a> gitlab</p>
<p>服务端 ‘<a href="http://36.7.130.226:30990&#39;">http://36.7.130.226:30990&#39;</a></p>
<p><img src="/../images/image-20240320144436974.png" alt="image-20240320144436974"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[缺乏知识点]]></title>
      <url>/2024/01/21/%E5%AF%92%E5%81%87%E7%AA%81%E5%87%BB/%E7%BC%BA%E4%B9%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h2><p><img src="/../../images/image-20240121161721911.png" alt="image-20240121161721911"></p>
<p>子组件用 v-bind&#x3D;$attrs来接收父组件的值</p>
<p><img src="/../../images/image-20240121161752218.png" alt="image-20240121161752218"></p>
<p>属性深度传递  使用attrs</p>
<h1 id="html5语义化标签"><a href="#html5语义化标签" class="headerlink" title="html5语义化标签"></a>html5语义化标签</h1><p><a href="https://link.juejin.cn/?target=http://www.html5jscss.com/html5-semantics-section.html">https://link.juejin.cn/?target=http%3A%2F%2Fwww.html5jscss.com%2Fhtml5-semantics-section.html</a>)</p>
<p>HTML 5的革新之一：语义化标签一节元素标签。</p>
<p>在HTML 5出来之前，我们用<code>div</code>来表示页面章节，但是这些<code>div</code>都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为因为html5的出现消失了，这就是我们平时说的“语义”。</p>
<p>看下图没有用div标签来布局</p>
<p><img src="/../../images/160c3bf5485ff9cetplv-t2oaga2asx-jj-mark3024000q75.webp" alt="HTML 5的革新——语义化标签(一)"></p>
<p>html5的布局</p>
<p>嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。</p>
<h4 id="媒介查询匹配浏览器系统系统颜色-独一抖音"><a href="#媒介查询匹配浏览器系统系统颜色-独一抖音" class="headerlink" title="媒介查询匹配浏览器系统系统颜色    独一抖音"></a>媒介查询匹配浏览器系统系统颜色    独一抖音</h4><h4 id="ajax避免浏览器缓存-提高效应速度"><a href="#ajax避免浏览器缓存-提高效应速度" class="headerlink" title="ajax避免浏览器缓存 提高效应速度"></a>ajax避免浏览器缓存 提高效应速度</h4><p><img src="/../../images/image-20240223212109838.png" alt="image-20240223212109838"></p>
<h4 id="动态执行脚本"><a href="#动态执行脚本" class="headerlink" title="动态执行脚本"></a>动态执行脚本</h4><p><img src="/../../images/image-20240224134200427.png" alt="image-20240224134200427"></p>
<h1 id="快手前端面经"><a href="#快手前端面经" class="headerlink" title="快手前端面经"></a>快手前端面经</h1><h4 id="1map和forEach的区别"><a href="#1map和forEach的区别" class="headerlink" title="1map和forEach的区别"></a>1map和forEach的区别</h4><h5 id="foreach改变值"><a href="#foreach改变值" class="headerlink" title="foreach改变值"></a>foreach改变值</h5><p><img src="/../../images/image-20240226095401591.png" alt="image-20240226095401591"></p>
<p><img src="/../../images/image-20240226094546002.png" alt="image-20240226094546002"></p>
<h4 id="2promise-all-和-promise-race的区别"><a href="#2promise-all-和-promise-race的区别" class="headerlink" title="2promise all 和 promise race的区别"></a>2promise all 和 promise race的区别</h4><ul>
<li><p>Promise.all接收的是数组，得到的结果也是数组，并且一一对应，也可以理解为Promise.all照顾跑的最慢的，最慢的跑完才结束。</p>
</li>
<li><p>Promise.race接收的也是数组，不过，得到的却是数组中跑的最快的那个，当最快的一跑完就立马结束。</p>
<p> 扩展</p>
</li>
</ul>
<p><img src="/../../images/image-20240226101804592.png" alt="image-20240226101804592"></p>
<h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><p><img src="/../../images/image-20240226105104022.png" alt="image-20240226105104022"></p>
<p>304重定向</p>
<h4 id="udp和tcp"><a href="#udp和tcp" class="headerlink" title="udp和tcp"></a>udp和tcp</h4><p><img src="/../../images/image-20240226105513979.png" alt="image-20240226105513979"></p>
<h4 id="面试官问到关于前端关键性能数据监控的问题时，你可以按照以下结构来回答："><a href="#面试官问到关于前端关键性能数据监控的问题时，你可以按照以下结构来回答：" class="headerlink" title="面试官问到关于前端关键性能数据监控的问题时，你可以按照以下结构来回答："></a>面试官问到关于前端关键性能数据监控的问题时，你可以按照以下结构来回答：</h4><ol>
<li><p>理解问题的重要性</p>
<ul>
<li>首先强调前端性能对用户体验的重要性，包括页面加载速度、响应时间、交互流畅性等。</li>
<li>提到性能问题可能导致用户流失、搜索引擎排名下降等负面影响。</li>
</ul>
</li>
<li><p>关键性能指标 (KPIs)</p>
<ul>
<li>列举一些常见的前端性能监控指标，如：<ul>
<li>页面加载时间 (Time to First Byte, Time to Interactive, DOMContentLoaded, Load Time)</li>
<li>页面响应时间 (Response Time)</li>
<li>JavaScript 执行时间</li>
<li>资源加载时间 (如 CSS、图片、脚本文件等)</li>
<li>用户交互时间 (如点击、滚动、键盘输入等)</li>
<li>错误率 (如 404 错误、JavaScript 错误等)</li>
</ul>
</li>
</ul>
</li>
<li><p>监控工具和技术</p>
<ul>
<li>介绍一些常用的前端性能监控工具，如：<ul>
<li>Lighthouse</li>
<li>PageSpeed Insights</li>
<li>WebPageTest</li>
<li>Performance tab in Chrome DevTools</li>
<li>New Relic</li>
<li>Datadog</li>
<li>Pingdom</li>
</ul>
</li>
<li>提及这些工具如何帮助你收集和分析性能数据，以及它们提供的具体功能（如瀑布图、性能指标、用户行为分析等）。</li>
</ul>
</li>
<li><p><strong>数据分析和优化</strong></p>
<p>：</p>
<ul>
<li>讲解如何通过分析监控数据来找出性能瓶颈，并给出优化建议。</li>
<li>举例说明如何通过调整代码、优化资源加载、使用缓存策略、改进网络请求等方式来提升前端性能。</li>
</ul>
</li>
<li><p>持续监控和反馈循环</p>
<p>：</p>
<ul>
<li>强调性能监控是一个持续的过程，需要定期检查和更新。</li>
<li>提到建立反馈循环的重要性，确保团队能够迅速响应性能问题，并在产品迭代中持续改进。</li>
</ul>
</li>
<li><p>个人经验和项目实例</p>
<p>：</p>
<ul>
<li>如果可能，分享一些你在实际项目中进行前端性能监控的经验和案例，展示你如何解决问题并取得积极成果。</li>
</ul>
</li>
<li><p>未来展望</p>
<p>：</p>
<ul>
<li>提及一些前沿的性能监控趋势和技术，如使用 AI 进行性能预测和优化、服务端渲染 (SSR)、代码拆分 (Code Splitting) 等。</li>
<li>表达你对持续学习和掌握新技术的热情。</li>
</ul>
</li>
</ol>
<p><strong>第四点分析监控数据以找出性能瓶颈及优化建议</strong></p>
<ol>
<li><p>识别瓶颈</p>
<ul>
<li><strong>加载时间分析</strong>：通过工具提供的加载时间报告，识别哪些资源（如脚本、样式表、图片）加载时间过长，这些通常是性能瓶颈的初步指示。</li>
<li><strong>CPU与内存使用</strong>：分析CPU和内存的使用情况，识别是否有资源密集型操作或内存泄漏问题。</li>
<li><strong>网络延迟</strong>：查看网络请求的延迟，确定是否存在服务器响应慢或网络带宽瓶颈。</li>
</ul>
</li>
<li><p>用户行为分析</p>
<ul>
<li><strong>页面交互</strong>：分析用户在页面上的交互行为，如滚动、点击等，找出可能导致延迟或卡顿的操作。</li>
<li><strong>错误报告</strong>：检查用户端的错误报告，识别常见的JavaScript错误或资源加载失败问题。</li>
</ul>
</li>
<li><p>优化建议</p>
<ul>
<li><strong>减少资源加载</strong>：压缩和合并资源文件，如使用Gzip压缩、CSS和JavaScript合并等。</li>
<li><strong>优化图片</strong>：使用适当的图片格式和压缩工具，减少图片文件大小。</li>
<li><strong>异步加载</strong>：使用异步加载技术，如异步脚本、懒加载图片等，避免阻塞主线程。</li>
<li><strong>代码优化</strong>：减少DOM操作、避免不必要的重绘和回流，使用Web Workers处理复杂计算。</li>
</ul>
</li>
</ol>
<p><strong>举例说明性能提升方法</strong></p>
<ol>
<li><p>调整代码</p>
<ul>
<li><strong>避免内联脚本</strong>：将内联脚本（如<code>&lt;script&gt;</code>标签直接写在HTML中）移动到外部文件，并异步加载，以减少页面渲染时的阻塞。</li>
<li><strong>使用事件委托</strong>：通过事件委托减少事件监听器的数量，提高性能。</li>
</ul>
</li>
<li><p>优化资源加载</p>
<ul>
<li><strong>利用CDN</strong>：通过内容分发网络（CDN）加快资源文件的分发速度，减少用户等待时间。</li>
<li><strong>预加载和预取</strong>：使用<code>&lt;link rel=&quot;preload&quot;&gt;</code>和<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>来预加载和预取关键资源，减少页面加载时的延迟。</li>
</ul>
</li>
<li><p>使用缓存策略</p>
<ul>
<li><strong>HTTP缓存</strong>：通过设置HTTP缓存头（如<code>Cache-Control</code>和<code>Expires</code>），让浏览器缓存静态资源，减少重复请求。</li>
<li><strong>Service Workers</strong>：使用Service Workers来拦截和缓存网络请求，提高资源加载速度。</li>
</ul>
</li>
<li><p>改进网络请求</p>
<ul>
<li><strong>减少请求数量</strong>：合并多个小的CSS或JavaScript文件为一个文件，减少网络请求次数。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>使用更高效的API</strong>：如使用Fetch API替代XMLHttpRequest进行网络请求，因为它提供了更好的错误处理和更简洁的语法。</li>
</ul>
<p>通过以上方法，可以显著提升前端性能，提供更好的用户体验。重要的是，每个项目和应用都有其独特性，因此性能优化需要针对具体情况进行定制和优化。</p>
<h3 id="闭包的属性放在堆内存还是栈内存为什么"><a href="#闭包的属性放在堆内存还是栈内存为什么" class="headerlink" title="闭包的属性放在堆内存还是栈内存为什么"></a>闭包的属性放在堆内存还是栈内存为什么</h3><p>闭包中的变量主要存储在<strong>堆内存</strong>中。这是因为闭包涉及到的函数会保留对其外部作用域的引用，而这些引用的值（变量）通常会存储在堆内存中。堆内存用于存储引用数据类型值，而闭包中的变量正是这样的引用类型。</p>
<p>在JavaScript中，栈内存主要用于存储基本数据类型值以及提供代码执行的环境。当函数执行完成后，所形成的私有作用域（栈内存）通常会自动释放掉，其中的值也会被释放。但是，如果函数内部存在闭包，那么闭包引用的外部变量将不会被释放，因为这些变量仍然被闭包所引用，所以它们会留在堆内存中，直到闭包不再被引用为止。</p>
<p>闭包的存在是为了保护函数的私有变量不受外部的干扰，同时实现方法和属性的私有化。然而，过度使用闭包可能会导致内存泄露，因为闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。</p>
<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>1、fetch 是 XMLHttpRequest 的一种替代方案，fetch是js原生语法也能像ajax一样获取后台数据 </p>
<p>优点： - 基于标准Promise实现，支持async&#x2F; await - 语法简洁，更加语意化fetch 可以理解成简化版的 XMLHttpRequest </p>
<p>缺点： - 兼容性不好，不支持IE - 不能中断请求（xhr有个xhr.abort 方法能直接中断请求） - 没法检测请求进度  </p>
<h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>\1. - 传统服务端渲染 : JSP&#x2F;PHP等等(前后端不分离的旧时代，模板引擎😅，后端拿到前端页面替换数据，前后端耦合)     - 现代服务端渲染 : (Vue-&gt;Nuxt.js,React-&gt;Next.js，自己做SSR ， 前后端分离的同时实现SSR)  2. 服务端渲染(SSR)即是在服务器端渲染完整的HTML后返回给客户端(通常是浏览器)。  3. 客户端渲染(CSR),也就是常见的单页面应用(SPA),由服务器端返回的初始 HTML 页面，由 JS 去异步加载数据，完成页面的渲染。由于ajax请求是异步的，百度Google等搜索引擎抓取的页面是几乎空白的，可以右键查看网页源代码看是否完整的HTML结构判断是SSR还是CSR。  4. 同构渲染，就是将SSR和CSR结合在一起，服务端渲染首屏后，激活应用，按照SPA方式运行，结合CSR和SSR各自优点。  5. 从上可知，服务端渲染的优点是:  - 搜索引擎爬虫能爬取完整HTML，有利于做搜索引擎优化(SEO),提高网站流量和曝光率  - 首屏渲染在服务端就完成，所以有更快的首屏加载速度  - 只是首屏快，其他页面不像SPA一样是无感刷新，切换页面通过超链接进行页面跳转，体验稍差(传统PHP&#x2F;JSP) 6.服务端渲染的缺点:  - 由于是在服务端进行渲染，需要占用更多服务器端资源(更多的CPU和内存)。  - 由于在服务端渲染，所以有些浏览器API无法使用，同样地 客户端一些生命周期在SSR也是不存在的。  - 部署和开发要求稍高，前后端耦合</p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>1.性能评估 Chrome Performance选项卡 &#x2F; Lighthouse 生成性能检测报告<br> 2.值得关注的性能指标<br>  （1）LCP (Largest Contentful Paint 最大内容绘制 )<br> （2）首屏渲染时间（也叫白屏时间）<br> （3）FCP (Fitst Contentful Paint 首先内容绘制 )<br> （4）可交互时间 (Time to Interactive TTI)<br> （5） Network请求时间(jax,js等)<br> 3.浏览器开发者工具什么都能看得到，可以调用性能监测API 或建立 前端监控系统(无痕埋点)   </p>
<p>####性能优化方向</p>
<p> 前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。 加载更快的方法： 让传输的数据包更小（压缩文件&#x2F;图片）：图片压缩和文件压缩 减少网络请求的次数：雪碧图&#x2F;精灵图、节流防抖 减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等）  渲染更快的方法： 提前渲染：ssr服务器端渲染 避免渲染阻塞：CSS放在HTML的head中  JS放在HTML的body底部 避免无用渲染：懒加载 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签  加分回答 雪碧图的应用场景一般是项目中不常更换的一些固定图标组合在一起，比如logo、搜索图标、切换图标等。 电商项目中最常用到的懒加载，一般在查看商品展示的时候通常下拉加载更多，因为商品数据太多，一次性请求过来数据太大且渲染的时间太长。</p>
<h4 id="vue-router原理"><a href="#vue-router原理" class="headerlink" title="vue-router原理"></a>vue-router原理</h4><p>HashRouter的原理：通过<code>window.onhashchange</code>方法获取新URL中hash值，再做进一步处理  HistoryRouter的原理：通过<code>history.pushState </code>使用它做页面跳转不会触发页面刷新，使用<code>window.onpopstate</code> 监听浏览器的前进和后退，再做其他处理  加分回答 hash模式下url会带有#，需要url更优雅时，可以使用history模式。 需要兼容低版本的浏览器时，建议使用hash模式。 需要添加任意类型数据到记录时，可以使用history模式。</p>
<h4 id="vite为什么比webpack快"><a href="#vite为什么比webpack快" class="headerlink" title="vite为什么比webpack快"></a>vite为什么比webpack快</h4><p>是<code>Vite</code>的打包方式，刚刚说了，<code>Vite</code>是直接把转换后的<code>es module</code>的JavaScript代码，扔给<code>支持es module的浏览器</code>，让浏览器自己去加载依赖，也就是把压力丢给了<code>浏览器</code>，从而达到了项目启动速度快的效果。</p>
<p><img src="/../../images/3f56ff49a8704589ace3f3711fea5b10tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<h3 id="解决更新缓慢"><a href="#解决更新缓慢" class="headerlink" title="解决更新缓慢"></a>解决更新缓慢</h3><p>刚刚说了，项目启动时，将模块分成<code>依赖</code>和<code>源码</code>，当你更新代码时，<code>依赖</code>就不需要重新加载，只需要精准地找到是哪个<code>源码</code>的文件更新了，更新相对应的文件就行了。这样做使得更新速度非常快。</p>
<p><code>Vite</code> 同时利用 <code>HTTP</code> 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 <code>304 Not Modified</code> 进行协商缓存，而依赖模块请求则会通过 <code>Cache-Control: max-age=31536000,immutable</code> 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p>
<p><code>vite</code>**开发环境依赖<code>esbuild</code>**进行预构建，生产环境则依赖<code>**rollup**</code>进行打包，并且充分利用了现代浏览器的特性，比如<code>http2</code>、<code>ES module</code>，<code>vite</code>是站在众多巨人肩膀上的一个产物， 类似<code>webpack + webpack-dev-server</code>的结合体，是一个非常棒的前端项目的构建工具。</p>
<p><strong>我们再来看一下，vite与webpack在项目构建上有哪些区别。</strong></p>
<p><strong>webpack</strong></p>
<p>webpack是基于<code>nodejs</code>运行的，但<code>js</code>只能单线程运行，无法利用多核CPU的优势，当项目越来越大时，构建速度也就越来越慢了。</p>
<p><strong>vite</strong></p>
<p>vite<code>预构建</code>与<code>按需编译</code>的过程，都是使用<code>esbuild</code>完成的。</p>
<p><code>esbuild</code>是用<code>go</code>语言编写的，可以充分利用多核CPU的优势，所以vite开发环境下的<code>预构建</code>与<code>按需编译</code>速度，都是非常快的。</p>
<p>vite充分利用了http2可以并发请求的优势，这也是速度快的一个主要原因。 接下来，我们了解一下<strong>http2</strong>的来龙去脉。</p>
<h5 id="打包机制"><a href="#打包机制" class="headerlink" title="打包机制"></a>打包机制</h5><p><code>bundle</code> 工作机制的核心部分分为两块：构建模块依赖图 - <code>module graph</code> 和将 <code>module graph</code> 分解为最终供浏览器使用的几个输出文件。</p>
<p>v<code>ite</code> 之所以在 <code>dev server</code> 启动方面，如此给力，是因为它采取了与 <code>Webpack</code> 截然不同的 <code>unbundle</code> 机制。</p>
<p><code>unbundle</code> 机制，顾名思义，不需要做 <code>bundle</code> 操作，即不需要构建、分解 <code>module graph</code>，源文件之间的依赖关系完全通过浏览器对 <code>ESM</code> 规范的支持来解析。这就使得 <code>dev server</code> 在启动过程中只需做一些初始化的工作，剩下的完全由浏览器支持。这和 <code>Webpack</code> 的 <code>bundle</code> 机制一比，简直就是降维打击，都有点欺负人了 😂。</p>
<p>那有的同学就会问，源文件的 <code>resolve</code>、<code>load</code>、<code>transform</code>、<code>parse</code> 什么时候做呢 ？</p>
<p>答案是浏览器发起请求以后，<code>dev server</code> 端会通过 <code>middlewares</code> 对请求做拦截，然后对源文件做 <code>resolve</code>、<code>load</code>、<code>transform</code>、<code>parse</code> 操作，然后再将转换以后的内容发送给浏览器。</p>
<h4 id="vue-keep-alive"><a href="#vue-keep-alive" class="headerlink" title="vue keep-alive"></a>vue keep-alive</h4><p> <code>&lt;keep-alive&gt;</code>作用：缓存组件，提升性能，避免重复加载一些不需要经常变动且内容较多的组件。 <code>&lt;keep-alive&gt;</code>的使用方法：使用<code>&lt;keep-alive&gt;</code>标签对需要缓存的组件进行包裹，默认情况下被<code>&lt;keep-alive&gt;</code>标签包裹的组件都会进行缓存，区分被包裹的组件是否缓存有两种方法，第一种是给keepalive 添加属性，组件名称指的是具体组件添加的name，不是路由里面的name。include 包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)。exclude 排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)。第二种也是最常用的一种是，和路由配合使用：在路由中添加meta属性。  使用keepalive导致组件不重新加载，也就不会重新执行生命周期的函数，如果要解决这个问题，就需要两个属性进入时触发：activated 退出时触发：deactivated  加分回答 <code>&lt;keep-alive&gt;</code>适用的场景：首页展示固定数据的组件，比如banner九宫格</keep-alive></keep-alive></keep-alive></keep-alive></keep-alive></p>
<h4 id="vue为什么多次操作只更新一次"><a href="#vue为什么多次操作只更新一次" class="headerlink" title="vue为什么多次操作只更新一次"></a>vue为什么多次操作只更新一次</h4><p>异步更新策略  当前微任务队列结束之后 在重新开始渲染</p>
<p>Vue.js 在处理 DOM 更新时，为了提高性能，采用了异步更新的策略，即当数据发生变化时，Vue 不会立即更新 DOM，而是等到当前微任务（microtask）队列清空后再执行更新操作。这就是为什么在多次操作数据后，Vue 只更新一次 DOM 的原因</p>
<p>这种异步更新的机制有以下几个优点：</p>
<ol>
<li><strong>性能优化</strong>：如果每次数据变化都立即更新 DOM，那么会导致大量的不必要的计算和渲染，尤其是在快速连续的操作数据时。Vue 的异步更新策略使得多个数据变化只触发一次 DOM 更新，从而减少了浏览器的重排和重绘次数，提高了性能。</li>
<li><strong>批处理</strong>：Vue 可以将多次数据变化合并成一次 DOM 更新，这样可以在一次更新中处理所有的变化，而不是分别处理每个变化。这有助于减少浏览器的渲染负担。</li>
<li><strong>用户体验</strong>：在某些场景下，用户可能察觉不到数据的微小变化，而 Vue 的异步更新策略可以帮助隐藏这种变化，从而提高用户体验。</li>
</ol>
<h3 id="v8引擎"><a href="#v8引擎" class="headerlink" title="v8引擎"></a>v8引擎</h3><p>1 V8 引擎的核心功能是解析、优化和执行 JavaScript 代码。其工作过程可以分为以下几个主要阶段：</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p><code>扫描器（Scanner）</code>用于对拿到的JavaScript代码进行<code>词法分析</code>，这个过程会将源代码转换为<code>tokens</code>，也叫<code>词素</code>，在 <a href="https://link.juejin.cn/?target=https://github.com/v8/v8/blob/master/src/parsing/keywords.txt">keywords.txt</a> 文件中可以找到所有的JS <code>tokens</code>。该文件定义了一个结构体</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p><code>解析器（Parser）</code>会对这些<code>tokens</code>进行<code>语法分析</code>，并根据它来构建<code>抽象语法树(Abstract Syntax Tree，简写为AST)</code>，同时会验证语法，如果有语法错误就会抛出来。</p>
<h4 id="三，代码执行与优化"><a href="#三，代码执行与优化" class="headerlink" title="三，代码执行与优化"></a>三，代码执行与优化</h4><ul>
<li><strong>执行</strong>：<code>Ignition</code>解释执行生成的字节码，这是JavaScript代码首次运行的形式。在执行的同时，V8会收集类型信息，为后续的优化编译提供数据。</li>
<li><strong>优化</strong>：基于收集到的类型信息，然后V8的<code>JIT</code>编译器<code>TurboFan</code>会将“热点代码”（经常执行的代码）编译成优化的机器代码，以提高执行效率。</li>
<li><strong>去优化</strong>：在执行过程中，如果V8发现对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候就需要执行<code>去优化</code>操作，经过去优化的代码，下次执行时就会回退到解释器解释执行</li>
</ul>
<h4 id="二，字节码生成"><a href="#二，字节码生成" class="headerlink" title="二，字节码生成"></a>二，字节码生成</h4><p>V8的<code>解释器（Interpreter）</code>名为<code>Ignition</code>，它会将<code>AST</code>转换成<code>ByteCode（字节码）</code>，这是一种介于<code>AST</code>和机器码之间的中间表示形式，专为快速解释执行设计，由于需要通过解释器执行或编译成机器码，其执行速度通常比直接执行机器码更慢。</p>
<p><img src="/../../images/image-20240312174837376.png" alt="image-20240312174837376"></p>
<p><img src="/../../images/image-20240312174853048.png" alt="image-20240312174853048"></p>
<h4 id="new一个class类和new一个function构造函数的区别"><a href="#new一个class类和new一个function构造函数的区别" class="headerlink" title="new一个class类和new一个function构造函数的区别"></a>new一个class类和new一个function构造函数的区别</h4><p>3.84 icA:&#x2F; 09&#x2F;12 <a href="mailto:&#109;&#64;&#x64;&#46;&#x41;&#84;">&#109;&#64;&#x64;&#46;&#x41;&#84;</a> class转function # JavaScript # 前端开发工程师 # 编程 # 程序员 # web前端  <a href="https://v.douyin.com/iYBg1V7t/">https://v.douyin.com/iYBg1V7t/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p>
<ol>
<li><strong>语法简洁性</strong>：使用类（class）的语法更简洁，更易于阅读和理解，尤其是在处理继承和方法重用时。</li>
<li><strong>继承</strong>：类（class）提供了内置的继承机制，可以通过<code>extends</code>关键字轻松实现。而使用函数作为构造函数时，需要手动实现原型链继承，这通常更加复杂。</li>
<li><strong>方法定义</strong>：在类中，方法可以直接定义在类体内部。而在使用函数作为构造函数时，方法通常定义在构造函数内部，这可能会导致每个实例都有自己的方法副本，从而增加内存消耗（除非方法定义在原型上）。</li>
<li><strong>静态属性&#x2F;方法</strong>：类支持静态属性和方法，这是使用函数作为构造函数无法直接提供的。</li>
<li><strong>私有和受保护成员</strong>：虽然JavaScript本身并不直接支持私有或受保护的成员，但类语法结合某些模式（如Symbol或WeakMap）可以更容易地实现这些特性。</li>
<li><strong>兼容性</strong>：类（class）是ES6引入的新特性，因此在一些老旧的浏览器或环境中可能不受支持。而函数作为构造函数则具有更好的兼容性。</li>
</ol>
<h3 id="隐藏一个div的方法"><a href="#隐藏一个div的方法" class="headerlink" title="隐藏一个div的方法"></a>隐藏一个div的方法</h3><p><img src="/../../images/image-20240411224620048.png" alt="image-20240411224620048"></p>
<p>这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：</p>
<p>1、display:none：元素彻底消失，很显然不会触发其点击事件<br>2、visibility:hidden：无法触发其点击事件，有一种说法是display:none是元素看不见摸不着，而visibility:hidden是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。<br>3、opacity:0：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件<br>4、height:0：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。</p>
<p>但是这些结论真的准确吗？<br>我们在上面的代码中添加这样一句代码：</p>
<p>结果发现，触发了click事件，也就是通过JS可以触发被设置为display:none的元素的事件。<br>所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！</p>
<h4 id="获取元素对象"><a href="#获取元素对象" class="headerlink" title="获取元素对象"></a>获取元素对象</h4><p><img src="/../../images/image-20240412155233230.png" alt="image-20240412155233230"></p>
<h2 id="bfc"><a href="#bfc" class="headerlink" title="bfc"></a>bfc</h2><h5 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h5><p>BFC 是一种特殊的上下文环境。当一个元素创建 BFC 后，就具备了一个完全独立的环境。</p>
<p>BFC 会影响当前元素和内部元素的布局表现，但不会影响跟外部元素之间的布局关系。</p>
<p>BFC 被用烂了的 2 个场景分别是清除浮动影响（clear the floats） 包含浮动元素 不让他影响外面</p>
<p> 和避免外边距合并（prevent margins collapsing）。</p>
<h4 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h4><p><img src="/../../images/image-20240413221054465.png" alt="image-20240413221054465"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2024/01/21/vue/vue3%20setup/</url>
      <content type="html"><![CDATA[<p>1</p>
<p><img src="/../../images/image-20240121160750365.png" alt="image-20240121160750365"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[网络面试题]]></title>
      <url>/2023/12/29/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h3 id="三次挥手"><a href="#三次挥手" class="headerlink" title="三次挥手"></a>三次挥手</h3><p><img src="/../../images/image-20231229154806791.png" alt="image-20231229154806791"></p>
<p><img src="/../../images/image-20231229154840316.png" alt="image-20231229154840316"></p>
<h5 id="三次挥手-判断客户端和服务器是否正常工作-第三次挥手用于确定自己的包被对方收到"><a href="#三次挥手-判断客户端和服务器是否正常工作-第三次挥手用于确定自己的包被对方收到" class="headerlink" title="三次挥手 判断客户端和服务器是否正常工作  第三次挥手用于确定自己的包被对方收到"></a>三次挥手 判断客户端和服务器是否正常工作  第三次挥手用于确定自己的包被对方收到</h5><h3 id="四次挥手（tcp断开连接）"><a href="#四次挥手（tcp断开连接）" class="headerlink" title="四次挥手（tcp断开连接）"></a>四次挥手（tcp断开连接）</h3><p><img src="/../../images/image-20231229155007911.png" alt="image-20231229155007911"></p>
<p><img src="/../../images/image-20231229155038472.png" alt="image-20231229155038472"></p>
<h3 id="HTTPS-加密流程"><a href="#HTTPS-加密流程" class="headerlink" title="HTTPS 加密流程"></a>HTTPS 加密流程</h3><p><img src="/../../images/image-20231229162400251.png" alt="image-20231229162400251"></p>
<p>建立连接的时候使用的是非对称密钥</p>
<p><img src="/../../images/image-20231229231757698.png" alt="image-20231229231757698"></p>
<p>之后使用对称加密通信 保持连接</p>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><img src="/../../images/image-20231229231909356.png" alt="image-20231229231909356"></p>
<h3 id="http-1-0-1-1-2-0"><a href="#http-1-0-1-1-2-0" class="headerlink" title="http 1,0 1,1 2.0"></a>http 1,0 1,1 2.0</h3><p><img src="/../../images/image-20231229232423214.png" alt="image-20231229232423214"></p>
<p><img src="/../../images/image-20240310185704351.png" alt="image-20240310185704351"></p>
<p><img src="/../../images/image-20240310185936160.png" alt="image-20240310185936160"></p>
<h3 id="HTTP-1-1-和-HTTP-2-0-的区别"><a href="#HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title=". HTTP 1.1 和 HTTP 2.0 的区别"></a>. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong>HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong>HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong>HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不的。</li>
</ul>
<h4 id="http3解决了什么"><a href="#http3解决了什么" class="headerlink" title="http3解决了什么"></a>http3解决了什么</h4><p>HTTP&#x2F;3主要解决了HTTP&#x2F;2中的队头阻塞（Head-of-Line Blocking）问题。</p>
<p>在HTTP&#x2F;2中，虽然应用层可以将不同文件的数据拆分成一个个的流（stream）放在同一个连接中进行传输，但底层的TCP协议并不知道这些流属于不同的文件，它会将所有的流当作同一个文件来处理。因此，当发送的数据出现丢包时，TCP会重新发送所有的文件包，从而导致队头阻塞的问题。这种阻塞会影响到同连接中的所有请求，即使其中一些请求与丢包的请求无关。</p>
<p>HTTP&#x2F;3基于UDP协议重新定义了连接，并在QUIC层实现了无序、并发字节流的传输。QUIC协议原生实现了多路复用，其传输的单个数据流可以保证有序交付且不会影响其他的数据流。这意味着，当某个流出现丢包时，HTTP&#x2F;3只会重发失败的流，而不是整个文件或连接中的所有流，从而有效解决了队头阻塞问题。</p>
<p><strong>HTTP&#x2F;3 使用 QUIC 协议</strong>，该协议在传输层上实现了多路复用。在 HTTP&#x2F;2 和之前的版本中，多路复用是通过在单个 TCP 连接上划分多个逻辑流来实现的。但是，TCP 的特性导致了队头阻塞问题：当某个数据包丢失时，整个 TCP 连接上的数据传输都会受到阻塞，直到丢失的数据包被重传并成功接收。</p>
<p>而 QUIC 协议通过以下方式解决了这个问题：</p>
<ol>
<li><strong>流独立性</strong>：在 QUIC 中，每个流都有自己的独立的传输控制逻辑。这意味着每个流都有自己的序列号、确认机制和重传机制。因此，当某个流的数据包丢失时，只有该流会受到影响，其他流可以继续传输数据。</li>
<li><strong>基于流的重传</strong>：当 QUIC 检测到某个流的数据包丢失时，它只会重传该流中丢失的数据包，而不是整个连接的所有数据。这种基于流的细粒度重传机制有效地减少了不必要的重传开销，并提高了传输效率。</li>
</ol>
<h3 id="敲下回车"><a href="#敲下回车" class="headerlink" title="敲下回车"></a>敲下回车</h3><p><img src="/../../images/image-20231229232807428.png" alt="image-20231229232807428"></p>
<p> 输入地址，浏览器查找域名的 IP 地址。 浏览器向 该 IP 地址的web 服务器发送一个 HTTP 请求，在发送请求之前浏览器和服务器建立TCP的三次握手，判断是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求，如果是HTTP协商缓存向后端发送请求且和后端服务器对比，在有效期内，服务器返回304，直接从浏览器获取数据，如果不在有效期内服务器返回200，返回新数据。  请求发送出去服务器返回重定向，浏览器再按照重定向的地址重新发送请求。  如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。  如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。  渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。</p>
<p>1、URL解析：判断浏览器输入的是搜索内容还是URL；2、查找缓存：如果能找到缓存则直接返回页面，如果没有缓存则需要发送网络请求页面；3、DNS域名解析；4、三次握手建立TCP连接；5、发起HTTP请求 看是否有强制缓存和协商缓存；6、服务器响应并返回结果；7、通过四次挥手手释放TCP连接；8、浏览器渲染；9、js引擎解析 … 展开   </p>
<h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p><strong>http</strong>缓存是一种客户端缓存，当Web浏览器向服务器发起资源请求时，服务器可以在响应报文头中包含缓存相关的信息。这些HTTP Header会告诉浏览器是否以及如何缓存资源，再次请求时如果命中缓存将直接读取本地缓存不再发出请求。</p>
<p>http缓存规则由响应头中<strong>Expires</strong>，<strong>Cache-Control</strong> ，<strong>Last-Modified</strong> ，<strong>Etag</strong> 这四个关键字段控制。其中<strong>Expires</strong>和<strong>Cache-Control为强缓存</strong>用来确定确定缓存的存储时间，<strong>Last-Modified</strong> 和<strong>Etag为协商缓存</strong>则用来确定缓存是否要被更新，接下来我们简单来看一下区别。</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>•cache-control: HTTP1.1中用来控制缓存时间的参数</p>
<p>◦public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</p>
<p>◦private: 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器例如CDN不能缓存它）。</p>
<p><strong>◦max-age&#x3D;</strong>: 设置缓存存储的最大周期，相对于请求的时间缓存seconds秒，在此时间内，访问资源直接读取本地缓存，不向服务器发出请求。（与expires同时出现时，max-age优先级更高）</p>
<p>◦s-maxage&#x3D;: 规则等同max-age，覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。（与expires或max-age同时出现时，s-maxage优先级更高）</p>
<p>◦no-store: 不缓存服务器响应的任何内容，每次访问资源都需要服务器完整响应</p>
<p>◦no-cache: 缓存资源，但立即过期，每次请求都需要跟服务器对比验证资源是否被修改。（等同于max-age&#x3D;0）</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><p>•Last-modified: 源头服务器认定的资源做出修改的日期及时间。精确度比Etag低。包含有If-Modified-Since ( 资源修改的时间 )或 If-Unmodified-Since首部的条件请求会使用这个字段，Last-Modified优先级低于Etag。</p>
<p>•Etag: HTTP响应头是资源的特定版本的标识符，如果客户端想再次请求相同的URL，将会发送一个包含已保存的ETag和“If-None-Match”（标识符字符串）字段的请求。客户端请求之后，服务器可能会比较客户端的ETag和当前版本资源的ETag（只要文件内容改动，ETag就会重新计算）。如果ETag值匹配，这就意味着资源没有改变，服务器便会发送回一个极短的响应，包含HTTP “304 未修改”的状态。304状态告诉客户端，它的缓存版本是最新的，并应该使用它。</p>
<p><img src="/../../images/image-20231229233841063.png" alt="image-20231229233841063"></p>
<p><img src="/../../images/image-20231229233929297.png" alt="image-20231229233929297"></p>
<p>注：如果HTTP为1.0时，则用expires判断是否过期，如果HTTP为1.1及其以上时，则查看cache-control。</p>
<h5 id="重点关注1-缓存是否过期"><a href="#重点关注1-缓存是否过期" class="headerlink" title="重点关注1: 缓存是否过期"></a><strong>重点关注1: 缓存是否过期</strong></h5><p>基于该资源上次响应缓存规则同时满足下列条件则视为缓存未过期，不发请求直接从本地缓存读取该文件。需要注意的是，判断缓存是否过期只跟客户端有关系，与服务端无关。1&amp;2&amp;3同时满足即认为缓存未过期，相反则是已过期</p>
<p>1.cache-control值为max-age</p>
<p>2.max-age &gt; 0</p>
<p>3.当前 date &lt; 上次请求时的date + max-age</p>
<p>注：如果HTTP为1.0时，则用expires判断是否过期，如果HTTP为1.1及其以上时，则查看cache-control。</p>
<h5 id="重点关注2-询问服务器资源是否修改"><a href="#重点关注2-询问服务器资源是否修改" class="headerlink" title="重点关注2: 询问服务器资源是否修改"></a><strong>重点关注2: 询问服务器资源是否修改</strong></h5><p><strong>判断资源是否修改，需要客户端与服务器共同协作，客户端在首次拿到资源缓存后会存储Etag（若有）和Last-Modified（若有）,在下次缓存过期时会将Etag写在请求头部中的If-None-Match中，将Last-Modified值写在请求头部中的If-Modified-Since中，服务端优先对Etag进行对比，然后再对比Last-Modified，一致即视为缓存没有修改，命中协商缓存，返回304，不一致则返回新文件并带上新的Etag或Last-Modified值。</strong>、</p>
<h3 id="udp和tcp"><a href="#udp和tcp" class="headerlink" title="udp和tcp"></a>udp和tcp</h3><p><img src="/../../images/image-20240226105513979.png" alt="image-20240226105513979"></p>
<h4 id="script的几个标签"><a href="#script的几个标签" class="headerlink" title="script的几个标签"></a>script的几个标签</h4><p><img src="/../../images/image-20240228204113576.png" alt="image-20240228204113576"></p>
<h4 id="preload和prefetch的区别"><a href="#preload和prefetch的区别" class="headerlink" title="preload和prefetch的区别"></a>preload和prefetch的区别</h4><p><img src="/../../images/image-20240228205046204.png" alt="image-20240228205046204"></p>
<p>浏览器中的进程</p>
<p><img src="/../../images/image-20240229170511283.png" alt="image-20240229170511283"></p>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p><img src="/../../images/image-20240229172656970.png" alt="image-20240229172656970"></p>
<p><strong>1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）时间触发线程</strong></p>
<p><strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li><p>XMLHttpRequest连接后通过浏览器新开一个线程请求；</p>
</li>
<li><p>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</p>
</li>
</ul>
<h4 id="HTTP协议和TCP-x2F-IP协议都是计算机网络中常用的协议，它们之间的关系和TCP、UDP为HTTP提供的服务如下："><a href="#HTTP协议和TCP-x2F-IP协议都是计算机网络中常用的协议，它们之间的关系和TCP、UDP为HTTP提供的服务如下：" class="headerlink" title="HTTP协议和TCP&#x2F;IP协议都是计算机网络中常用的协议，它们之间的关系和TCP、UDP为HTTP提供的服务如下："></a><strong>HTTP协议和TCP&#x2F;IP协议都是计算机网络中常用的协议，它们之间的关系和TCP、UDP为HTTP提供的服务如下：</strong></h4><ol>
<li>HTTP协议和TCP&#x2F;IP协议的关系：</li>
</ol>
<p>HTTP协议是一种应用层协议，用于在客户端和服务器之间传输超文本数据。它是基于TCP&#x2F;IP协议族中的TCP协议实现的。TCP&#x2F;IP协议族包括TCP、UDP、IP等协议，它们分别负责不同的网络传输功能。IP协议负责将数据包从源地址传输到目的地址，而TCP协议则负责在源主机和目标主机之间建立可靠的连接，并确保数据的完整性和顺序性。因此，HTTP协议依赖于TCP&#x2F;IP协议族中的TCP协议来实现可靠的数据传输。</p>
<ol>
<li>TCP和UDP为HTTP提供的服务：</li>
</ol>
<p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。它为HTTP提供了可靠的数据传输服务，包括数据包的顺序传输、错误控制、流量控制等功能。通过使用TCP协议，HTTP可以确保在客户端和服务器之间传输的数据的完整性和可靠性。</p>
<p>相比之下，UDP是一种无连接的、不可靠的传输层协议。它不提供数据包的顺序传输和错误控制等功能，因此传输速度相对较快，但数据可能会丢失或乱序。由于HTTP协议需要确保数据的完整性和可靠性，因此通常不会使用UDP协议来传输HTTP数据。</p>
<p><strong>总之，HTTP协议依赖于TCP&#x2F;IP协议族中的TCP协议来实现可靠的数据传输，而TCP为HTTP提供了可靠的数据传输服务，包括数据包的顺序传输、错误控制、流量控制等功能。UDP虽然也可以用于传输数据，但由于其不可靠性，通常不会用于传输HTTP数据</strong>。</p>
<h4 id="实时通信"><a href="#实时通信" class="headerlink" title="实时通信"></a>实时通信</h4><p>加分回答 轮询适用于：小型应用，实时性不高 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 iframe适用于：客服通信等 WebSocket适用于：微信、网络互动游戏等 SSE适用于：金融股票数据、看板等</p>
<h3 id="csrf攻击"><a href="#csrf攻击" class="headerlink" title="csrf攻击"></a>csrf攻击</h3><p><img src="/../../images/image-20240406191635293.png" alt="image-20240406191635293"></p>
<p>跨站请求攻击</p>
<h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>跨站脚本攻击</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>
<p>比如你一个评论输入框 坏人输入一段脚<script>alert(docement.cookid)</script>    发给服务器 服务器也没有验证直接返回数据 这是浏览器就会在解析html文档的时候 解析 坏人就可以获取你的数据这些了 </p>
<h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><p>存储型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>反射型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM 型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL。</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><h4 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h4><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p>
<h4 id="转义-HTML"><a href="#转义-HTML" class="headerlink" title="转义 HTML"></a>转义 HTML</h4><p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>使用内容安全策略（CSP）来限制哪些源可以执行脚本。</p>
<p> 1设置 HTTPOnly 标志来防止 JavaScript 访问 Cookie，从而降低窃取 Cookie 的风险。2</p>
<p>2<strong>Domain</strong>：通过设置Cookie的Domain属性，可以限制Cookie只在特定的域名下有效。这样可以防止其他网站通过跨站请求伪造（CSRF）等方式获取和使用你的Cookie。</p>
<p>3 防止CSRF攻击：CSRF攻击利用了浏览器发送Cookie的特性，攻击者通过构造一个恶意网站，诱导用户在不知情的情况下向受攻击的网站发送包含恶意请求的Cookie。SameSite属性的引入可以防止这种攻击，因为它限制了Cookie在不同站点之间的传输。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一些面经]]></title>
      <url>/2023/12/29/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<p><img src="/../images/image-20231229151713576.png" alt="image-20231229151713576"></p>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><img src="/../images/image-20231229231909356.png" alt="image-20231229231909356"></p>
<h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p><strong>http</strong>缓存是一种客户端缓存，当Web浏览器向服务器发起资源请求时，服务器可以在响应报文头中包含缓存相关的信息。这些HTTP Header会告诉浏览器是否以及如何缓存资源，再次请求时如果命中缓存将直接读取本地缓存不再发出请求。</p>
<p>http缓存规则由响应头中<strong>Expires</strong>，<strong>Cache-Control</strong> ，<strong>Last-Modified</strong> ，<strong>Etag</strong> 这四个关键字段控制。其中<strong>Expires</strong>和<strong>Cache-Control为强缓存</strong>用来确定确定缓存的存储时间，<strong>Last-Modified</strong> 和<strong>Etag为协商缓存</strong>则用来确定缓存是否要被更新，接下来我们简单来看一下区别。</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>•cache-control: HTTP1.1中用来控制缓存时间的参数</p>
<p>◦public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</p>
<p>◦private: 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器例如CDN不能缓存它）。</p>
<p><strong>◦max-age&#x3D;</strong>: 设置缓存存储的最大周期，相对于请求的时间缓存seconds秒，在此时间内，访问资源直接读取本地缓存，不向服务器发出请求。（与expires同时出现时，max-age优先级更高）</p>
<p>◦s-maxage&#x3D;: 规则等同max-age，覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。（与expires或max-age同时出现时，s-maxage优先级更高）</p>
<p>◦no-store: 不缓存服务器响应的任何内容，每次访问资源都需要服务器完整响应</p>
<p>◦no-cache: 缓存资源，但立即过期，每次请求都需要跟服务器对比验证资源是否被修改。（等同于max-age&#x3D;0）</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><p>•Last-modified: 源头服务器认定的资源做出修改的日期及时间。精确度比Etag低。包含有If-Modified-Since ( 资源修改的时间 )或 If-Unmodified-Since首部的条件请求会使用这个字段，Last-Modified优先级低于Etag。</p>
<p>•Etag: HTTP响应头是资源的特定版本的标识符，如果客户端想再次请求相同的URL，将会发送一个包含已保存的ETag和“If-None-Match”（标识符字符串）字段的请求。客户端请求之后，服务器可能会比较客户端的ETag和当前版本资源的ETag（只要文件内容改动，ETag就会重新计算）。如果ETag值匹配，这就意味着资源没有改变，服务器便会发送回一个极短的响应，包含HTTP “304 未修改”的状态。304状态告诉客户端，它的缓存版本是最新的，并应该使用它。</p>
<p><img src="/../images/image-20231229233841063.png" alt="image-20231229233841063"></p>
<p><img src="/../images/image-20231229233929297.png" alt="image-20231229233929297"></p>
<p>注：如果HTTP为1.0时，则用expires判断是否过期，如果HTTP为1.1及其以上时，则查看cache-control。</p>
<h5 id="重点关注1-缓存是否过期"><a href="#重点关注1-缓存是否过期" class="headerlink" title="重点关注1: 缓存是否过期"></a><strong>重点关注1: 缓存是否过期</strong></h5><p>基于该资源上次响应缓存规则同时满足下列条件则视为缓存未过期，不发请求直接从本地缓存读取该文件。需要注意的是，判断缓存是否过期只跟客户端有关系，与服务端无关。1&amp;2&amp;3同时满足即认为缓存未过期，相反则是已过期</p>
<p>1.cache-control值为max-age</p>
<p>2.max-age &gt; 0</p>
<p>3.当前 date &lt; 上次请求时的date + max-age</p>
<p>注：如果HTTP为1.0时，则用expires判断是否过期，如果HTTP为1.1及其以上时，则查看cache-control。</p>
<h5 id="重点关注2-询问服务器资源是否修改"><a href="#重点关注2-询问服务器资源是否修改" class="headerlink" title="重点关注2: 询问服务器资源是否修改"></a><strong>重点关注2: 询问服务器资源是否修改</strong></h5><p><strong>判断资源是否修改，需要客户端与服务器共同协作，客户端在首次拿到资源缓存后会存储Etag（若有）和Last-Modified（若有）,在下次缓存过期时会将Etag写在请求头部中的If-None-Match中，将Last-Modified值写在请求头部中的If-Modified-Since中，服务端优先对Etag进行对比，然后再对比Last-Modified，一致即视为缓存没有修改，命中协商缓存，返回304，不一致则返回新文件并带上新的Etag或Last-Modified值。</strong></p>
<h3 id="两种路由"><a href="#两种路由" class="headerlink" title="两种路由"></a>两种路由</h3><p><a href="https://juejin.cn/post/7110592611231989767">Vue Router的路由模式 hash 和 history 的实现原理和区别详解 - 掘金 (juejin.cn)</a></p>
<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><h1 id="字节一面二面三面四面"><a href="#字节一面二面三面四面" class="headerlink" title="字节一面二面三面四面"></a>字节一面二面三面四面</h1><p><strong>一面</strong></p>
<p>最基础的一集，但是也会深挖，好久没被问基础了</p>
<p>实习中最有挑战的问题</p>
<p>SSR相关</p>
<p>js有哪些数据类型</p>
<p>数据类型判断</p>
<p>如何判断数组  isARRAY  object.getxxxxxx.CALL   instance of</p>
<p>原型链</p>
<p>vue-router的两种模式，原理</p>
<p>hash 使用 hashchange 事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：</p>
<ul>
<li><p>浏览器前进后退改变 URL</p>
</li>
<li><p>a 标签改变 URL</p>
</li>
<li><p>window.location 改变 URL</p>
<p>hash 模式是一种把前端路由的路径用井号 # 拼接在真实 URL 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 hashchange 事件。</p>
<p>history 原理：History 模式使用 HTML5 提供的 History API，通过修改浏览器历史记录来实现路由切换。它使用 <code>pushState()</code> 方法向浏览器历史记录添加新的状态，并且不会重新加载页面。当用户点击浏览器的前进或后退按钮时，Vue Router 会根据历史记录的变化，匹配到相应的路由并渲染对应的组件。</p>
</li>
</ul>
<p>script的async defer</p>
<p>垂直水平居中</p>
<p>块级格式化上下文  ？？？？</p>
<p>输出题 </p>
<p>事件循环题 </p>
<p>事件冒泡捕获题 </p>
<p>字符串格式化 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str=`</span><br><span class="line">1 2 4342    3 4 5</span><br><span class="line">23 4</span><br><span class="line">    4  5</span><br><span class="line">`</span><br><span class="line">let ans=[[1,2,4342,3,4,5],[23,4],[4,5]]</span><br></pre></td></tr></table></figure>



<p><strong>二面</strong></p>
<p>输入url到页面展现的过程 ！！！！！</p>
<p>五层模型</p>
<p>tcp在哪一层</p>
<p>tcp依赖于哪个协议</p>
<p>如何区别每一个进程</p>
<p>端口的作用</p>
<p>对首屏的理解 是哪段时间</p>
<p>实现一个repeat函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let timeLog=repeat(2,1000,console.log)</span><br><span class="line">timeLog(&#x27;hello world&#x27;)</span><br><span class="line">timeLog(&#x27;ByteDance&#x27;)</span><br><span class="line">//&#x27;hello world&#x27;</span><br><span class="line">//&#x27;ByteDance&#x27;</span><br><span class="line">//&#x27;hello world&#x27;</span><br><span class="line">//&#x27;ByteDance&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>三面</strong></p>
<p>实习中最有挑战，最有价值的事</p>
<p>vue中比较核心的提高开发体验的点，讲一讲</p>
<p>如果我声明了一个响应式数据但是并没有使用它，在它发生变化时会rerender吗</p>
<p>vue是在什么时候去做依赖收集的呢</p>
<p>在使用tree-shaking时需要注意哪些事情</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str=&#x27;a.b.c&#x27;</span><br><span class="line">resolve(str)</span><br><span class="line">// &#123;</span><br><span class="line">//   a:&#123;</span><br><span class="line">//     b:&#123;</span><br><span class="line">//       c:null</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>



<p><strong>四面</strong></p>
<p>为什么离职</p>
<p>之前面试没有通过的原因有复盘过吗</p>
<p>上一份实习时候有发现自己的不足，如何改进的呢</p>
<p>为什么学前端的呢</p>
<p>上份实习有做过一些商业投放页的功能能讲一讲吗，有难点吗</p>
<p>上份实习学到了哪些东西</p>
<p>以后的规划</p>
<p>有在面其他公司吗</p>
<p>为什么拒了呢</p>
<p>对我们岗位的认识讲一讲</p>
<p><a href="">#我的实习求职记录#</a></p>
<h4 id="字节前端面-日常实习"><a href="#字节前端面-日常实习" class="headerlink" title="字节前端面 日常实习"></a>字节前端面 日常实习</h4><p><img src="/../images/image-20240303143834247.png" alt="image-20240303143834247"></p>
<p>4 箭头函数的this是在函数定义的时候就确定好的 指向离他最近的非箭头函数的上下文</p>
<p>5node环境下的this指向什么</p>
<p> 其被使用的上下文</p>
<p>在全局上下文中，<code>this</code>指向<code>global</code>对象。然而，在模块中，<code>this</code>的指向会有所不同。</p>
<p>在Node.js的模块系统中，每个模块都有其自己的作用域，因此<code>this</code>在模块的顶层（也就是不在任何函数中）通常指向<code>module.exports</code>。这是因为<code>module.exports</code>是模块公开其API的方式。当你在模块顶层访问<code>this</code>时，你其实是在访问<code>module.exports</code>。</p>
<p>6 </p>
<ul>
<li>Node.js是对Google V8引擎进行封装的运行环境，它使得JavaScript能够在服务器端运行，从而突破了JavaScript只能在浏览器端运行的限制。</li>
<li>JavaScript主要作为客户端编程语言，用于在浏览器中实现交互效果和动态内容更新。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[three3d三个小球效果]]></title>
      <url>/2023/12/27/3d/</url>
      <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"> //创建三个小球 并设置基础材质</span><br><span class="line"></span><br><span class="line"> let ballGeometry=**new** THREE.SphereGeometry(1,10,10)</span><br><span class="line"></span><br><span class="line"> let ballMaterial=**new** THREE.MeshBasicMaterial(&#123;</span><br><span class="line"></span><br><span class="line">​    color:0xffffff,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> let ballGeometry1=**new** THREE.SphereGeometry(1,10,10)</span><br><span class="line"></span><br><span class="line"> let ballMaterial1=**new** THREE.MeshBasicMaterial(&#123;</span><br><span class="line"></span><br><span class="line">   //设置黄色</span><br><span class="line"></span><br><span class="line">​    color:0xffff00,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> let ballGeometry2=**new** THREE.SphereGeometry(1,10,10)</span><br><span class="line"></span><br><span class="line"> let ballMaterial2=**new** THREE.MeshBasicMaterial(&#123;</span><br><span class="line"></span><br><span class="line">   //设置绿色</span><br><span class="line"></span><br><span class="line">​    color:0x00ff00,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> //加入场景并设置位置</span><br><span class="line"></span><br><span class="line"> let ball1=**new** THREE.Mesh(ballGeometry,ballMaterial)</span><br><span class="line"></span><br><span class="line"> ball1.position.set(-4,0,0)</span><br><span class="line"></span><br><span class="line"> let ball2=**new** THREE.Mesh(ballGeometry1,ballMaterial1)</span><br><span class="line"></span><br><span class="line"> ball2.position.set(4,0,0)</span><br><span class="line"></span><br><span class="line"> let ball3=**new** THREE.Mesh(ballGeometry2,ballMaterial2)</span><br><span class="line"></span><br><span class="line"> ball3.position.set(0,0,4)</span><br><span class="line"></span><br><span class="line"> scene.add(ball1)</span><br><span class="line"></span><br><span class="line"> scene.add(ball2)</span><br><span class="line"></span><br><span class="line"> scene.add(ball3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //创建射线</span><br><span class="line"></span><br><span class="line"> let raycaster=**new** THREE.Raycaster()</span><br><span class="line"></span><br><span class="line"> //创建鼠标向量</span><br><span class="line"></span><br><span class="line"> let mouse=**new** THREE.Vector2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //开启窗口的点击监听鼠标向量</span><br><span class="line"></span><br><span class="line"> window.addEventListener(&#x27;click&#x27;,</span><br><span class="line"></span><br><span class="line"> (*event*)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  //通过鼠标点击的位置计算出射线的位置</span><br><span class="line"></span><br><span class="line">  mouse.x=(*event*.clientX/window.innerWidth)*2-1</span><br><span class="line"></span><br><span class="line">  mouse.y=-(*event*.clientY/window.innerHeight)*2+1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  //通过鼠标点击的位置计算出射线的位置</span><br><span class="line"></span><br><span class="line">  raycaster.setFromCamera(mouse,camera)</span><br><span class="line"></span><br><span class="line">  //获取射线和所有模型的相交部分</span><br><span class="line"></span><br><span class="line">  let intersects=raycaster.intersectObjects(scene.children)</span><br><span class="line"></span><br><span class="line">  //将第一个相交的模型的颜色设置为红色</span><br><span class="line"></span><br><span class="line">  if(intersects.length&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  //判断是否被选中 </span><br><span class="line"></span><br><span class="line">   if(intersects[0].object._isSelec)&#123;</span><br><span class="line"></span><br><span class="line">   intersects[0].object.material.color.set(intersects[0].object._originalColor)</span><br><span class="line"></span><br><span class="line">   intersects[0].object._isSelec=false</span><br><span class="line"></span><br><span class="line">   return </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   intersects[0].object._isSelec=true</span><br><span class="line"></span><br><span class="line">   //记录当前颜色</span><br><span class="line"></span><br><span class="line">   intersects[0].object._originalColor=intersects[0].object.material.color.clone()</span><br><span class="line"></span><br><span class="line">   intersects[0].object.material.color.set(0xff0000)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;,false)</span><br></pre></td></tr></table></figure>

<p>3d的点击交互事件</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/12/20/vue/%E7%BB%84%E4%BB%B6/%E6%8C%89%E9%92%AE/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20231220131919257.png" alt="image-20231220131919257"></p>
<!-- yu-button组件 -->

<script setup>
const props = defineProps({
  btnPadding: {
    type: String,
    default: '10px 20px'
  },
  btnBorder: {
    type: String,
    default: 'none'
  }
})
</script>

<template>
  <button class="btn">
    <slot></slot>
  </button>
</template>

<style lang="less" scoped>
.btn {
    padding: v-bind('props.btnPadding');
    background-image: linear-gradient(to right, #91c0e0 0%, #d6edab 51%, #76e3de 100%);
    background-size: 200% auto;
    text-align: center;
    text-transform: uppercase;
    transition: 0.5s;
    border: v-bind('props.btnBorder');
    border-radius: 8px;
    color: white;
    cursor: pointer;
  }
  .btn:hover {
    background-position: right center;
  }
</style> ]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/12/16/bug/%E5%85%B6%E4%BB%96ts%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%20pinia/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title-其他ts文件使用-pinia"><a href="#title-其他ts文件使用-pinia" class="headerlink" title="title :其他ts文件使用 pinia"></a>title :其他ts文件使用 pinia</h2><p><img src="/../../images/image-20231216204753653.png" alt="image-20231216204753653"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[复习 面试题]]></title>
      <url>/2023/11/24/%E9%9D%A2%E7%BB%8F/%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="5-如何进⾏⽹站性能优化"><a href="#5-如何进⾏⽹站性能优化" class="headerlink" title="5 如何进⾏⽹站性能优化"></a>5 如何进⾏⽹站性能优化</h4><h5 id="content-⽅⾯"><a href="#content-⽅⾯" class="headerlink" title="content ⽅⾯"></a><strong>content ⽅⾯</strong></h5><p>减少 HTTP 请求：合并⽂件、 CSS 精灵、 inline Image</p>
<p>减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名</p>
<p>减少 DOM 元素数量</p>
<h5 id="Server-⽅⾯"><a href="#Server-⽅⾯" class="headerlink" title="Server ⽅⾯"></a><strong>Server ⽅⾯</strong></h5><p>使⽤ CDN</p>
<p>配置 ETag</p>
<p>对组件使⽤ Gzip 压缩</p>
<h5 id="Cookie-⽅⾯"><a href="#Cookie-⽅⾯" class="headerlink" title="Cookie ⽅⾯"></a>Cookie ⽅⾯</h5><p>减⼩ cookie ⼤⼩</p>
<h5 id="css-⽅⾯"><a href="#css-⽅⾯" class="headerlink" title="css ⽅⾯"></a>css ⽅⾯</h5><p>将样式表放到⻚⾯顶部</p>
<p>不使⽤ CSS 表达式</p>
<p>使⽤ <link> 不使⽤ @import</p>
<h5 id="Javascript-⽅⾯"><a href="#Javascript-⽅⾯" class="headerlink" title="Javascript ⽅⾯"></a>Javascript ⽅⾯</h5><p>将脚本放到⻚⾯底部</p>
<p>将 javascript 和 css 从外部引⼊</p>
<p>压缩 javascript 和 css</p>
<p>删除不需要的脚本</p>
<p>减少 DOM 访问</p>
<p><strong>图⽚⽅⾯</strong></p>
<p>优化图⽚：根据实际颜⾊需要选择⾊深、压缩</p>
<p>优化 css 精灵</p>
<p>不要在 HTML 中拉伸图⽚</p>
<h4 id="13-iframe有那些缺点？"><a href="#13-iframe有那些缺点？" class="headerlink" title="13 iframe有那些缺点？"></a>13 iframe有那些缺点？</h4><ol>
<li><strong>iframe 会阻塞主⻚⾯的 Onload 事件</strong></li>
<li>搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO</li>
<li>iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载</li>
<li>使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过</li>
<li>javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题</li>
</ol>
<h4 id="24-渲染优化"><a href="#24-渲染优化" class="headerlink" title="24 渲染优化"></a>24 渲染优化</h4><ol>
<li>禁⽌使⽤ iframe （阻塞⽗⽂档 onload 事件）</li>
<li>iframe 会阻塞主⻚⾯的 Onload 事件</li>
<li>搜索引擎的检索程序⽆法解读这种⻚⾯，不利于SEO</li>
<li>iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并</li>
<li>⾏加载</li>
<li>使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过</li>
<li>javascript</li>
<li>动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题</li>
<li>禁⽌使⽤ gif 图⽚实现 loading 效果（降低 CPU 消耗，提升渲染性能）</li>
<li>使⽤ CSS3 代码代替 JS 动画（尽可能避免重绘重排以及回流）</li>
<li>对于⼀些⼩图标，可以使⽤base64位编码，以减少⽹络请求。但不建议⼤图使⽤，⽐较耗费 CPU</li>
<li>⼩图标优势在于 减少 HTTP 请求  避免⽂件跨域   修改及时⽣效</li>
<li>⻚⾯头部的 <style></style> <script></script> 会阻塞⻚⾯；（因为进程Renderer中 JS 线程和渲染线程是互斥的） </li>
<li>⻚⾯中空的 href 和 src 会阻塞⻚⾯其他资源的加载 (阻塞下载进程)</li>
<li>⽹⻚ gzip ， CDN 托管， data 缓存 ，图⽚服务器</li>
<li>前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端⽤变量保存AJAX请求结 果，每次操作本地变量，不⽤请求，减少请求次数</li>
<li>⽤ innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</li>
<li>当需要设置的样式很多时设置 className ⽽不是直接操作 style</li>
<li>少⽤全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作</li>
<li>图⽚预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>
<li>对普通的⽹站有⼀个统⼀的思路，就是尽量向前端优化、减少数据库操作、减少磁盘</li>
</ol>
<h3 id="33性能优化预加载"><a href="#33性能优化预加载" class="headerlink" title="33性能优化预加载"></a>33性能优化预加载</h3><p><strong>预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源</strong>；</p>
<h4 id="图片预加载（HTML-img标签-Image对象）"><a href="#图片预加载（HTML-img标签-Image对象）" class="headerlink" title="图片预加载（HTML- img标签 Image对象）"></a>图片预加载（HTML- img标签 Image对象）</h4><p><img src="/../../images/image-20231128223144253.png" alt="image-20231128223144253"></p>
<p>视频（advio 对象）</p>
<p>link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载 </p>
<p>prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制</p>
<p>修改常规流中元素的 display 通常会造成⽂档重排。修改 visibility 属性只会造成</p>
<p>本元素的重绘</p>
<h2 id="34清除浮动"><a href="#34清除浮动" class="headerlink" title="34清除浮动"></a>34清除浮动</h2><ol>
<li>使用 clearfix 类清除浮动：</li>
</ol>
<p>​    定义一个 CSS 类 <code>.clearfix</code>，并将其应用于包含浮动元素的父元素。</p>
<p>  2 使用 overflow 属性清除浮动：</p>
<p>将包含浮动元素的父元素设置 <code>overflow</code> 属性为 <code>auto</code> 或 <code>hidden</code>。</p>
<p>​    3 使用 BFC（块级格式化上下文）清除浮动：</p>
<p>将包含浮动元素的父元素触发 BFC，可以通过设置父元素的 <code>overflow</code>、<code>display</code>、<code>float</code>、<code>position</code>、<code>flex</code> 等属性来触发 BFC。</p>
<h2 id="35display-inline-block-什么时候不会显示间隙？"><a href="#35display-inline-block-什么时候不会显示间隙？" class="headerlink" title="35display:inline-block 什么时候不会显示间隙？"></a>35display:inline-block 什么时候不会显示间隙？</h2><p>在使用 <code>di splay: inline-block;</code> 属性时，元素之间可能会出现间隙的情况。这是因为浏览器将 inline-block 元素之间的空白字符（空格、换行符等）视为文本节点，从而导致间隙出现。</p>
<p>有几种情况下，<code>display: inline-block;</code> 不会显示间隙：</p>
<ol>
<li><p>移除源代码中的空白字符：可以将 inline-block 元素的 HTML 标签写在一行上，移除元素之间的空格或换行符。</p>
</li>
<li><p>将父容器的字体大小设为 0：通过将包含 inline-block 元素的父容器的字体大小设为 0，可以消除间隙。</p>
</li>
<li><p>使用注释清除间隙：在 inline-block 元素之间添加注释，将空白字符替换为注释，从而消除间隙。</p>
</li>
<li><p>使用负 margin 清除间隙：为 inline-block 元素应用负 margin，将间隙抵消。</p>
</li>
</ol>
<h4 id="js-判断两个对象是否内容相等"><a href="#js-判断两个对象是否内容相等" class="headerlink" title="js 判断两个对象是否内容相等"></a>js 判断两个对象是否内容相等</h4><p>1&#x3D;&#x3D;&#x3D;</p>
<p>2JSON.stringify(a) &#x3D;&#x3D;&#x3D; JSON.stirngify(b) ，只能是属性顺序一致的对象，有函数的情况也不能转字符串</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/10/25/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：-面试记录"><a href="#title：-面试记录" class="headerlink" title="title： 面试记录"></a>title： 面试记录</h2><p>北京小程序</p>
<p>1 介绍下你自己和你的项目</p>
<p>2 遇到的难点</p>
<p>3 vue中封装一个通用组件的策略或者理念</p>
<p>4 vue3的生命周期相对vue2的变化</p>
<p>5 css作用域 如何区分单个组件 全局组件</p>
<p>6 对原生微信小程序的理解和掌握程度</p>
<p>7 数据加载慢，页面加载慢的一些处理方式</p>
<p>传音控股   地点变更＋钱太少   ×</p>
<p>基础vue</p>
<p>合肥数据院    一面过  等通知</p>
<p>基础项目问题 </p>
<p>基础js </p>
<p>基础的vue</p>
<p>武汉</p>
<p>http是什么 如何理解</p>
<p>https</p>
<p>tcp和udp</p>
<p>三次挥手</p>
<p>闭包</p>
<p>虚拟dom</p>
<p>new一个实例</p>
<p>各种定位</p>
<p>隐藏dom</p>
<p>js数据类型</p>
<p>项目遇到的问题</p>
<p>返回的错误报错</p>
<p>404是什么 如何解决</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[封装瀑布流]]></title>
      <url>/2023/10/22/vue/%E7%BB%84%E4%BB%B6/%E5%B0%81%E8%A3%85%E7%80%91%E5%B8%83%E6%B5%81/</url>
      <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;  :style=&quot;&#123; width: `$&#123;appWidth&#125;px`, hight: `$&#123;appHight&#125;px` &#125;&quot;&gt;</span><br><span class="line">  &lt;Waterfall&gt;</span><br><span class="line">    &lt;item v-for=&quot;(item, index) in 50&quot; :key=&quot;index&quot;&gt;  </span><br><span class="line">      &lt;img :src=&quot;&#x27;https://picsum.photos/id/&#x27;+getRandomWidth()+ &#x27;/200/&#x27;+getRandomWidth()+&#x27;?grayscale&#x27;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/Waterfall&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref ,onMounted&#125; from &quot;vue&quot;;</span><br><span class="line">import Waterfall from &#x27;./components/my-vueWaterfall.vue&#x27;</span><br><span class="line"></span><br><span class="line">const appWidth = ref(window.innerWidth*0.8);</span><br><span class="line">const appHight=ref(window.innerHeight);</span><br><span class="line">const handleResize = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  appWidth.value = window.innerWidth;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">const getRandomWidth = () =&gt; &#123;</span><br><span class="line">  return Math.floor(Math.random() * (400 - 100) + 100); // 生成100到400之间的随机宽度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  window.addEventListener(&#x27;resize&#x27;, handleResize);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">img&#123;</span><br><span class="line"> width:100%</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>





<p>组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div ref=&quot;$el&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script &gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Waterfall&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    count: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 8</span><br><span class="line">    &#125;,</span><br><span class="line">    gap: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    const $el = ref(null);</span><br><span class="line">    const count = ref(props.count);</span><br><span class="line">    const gap = ref(props.gap);</span><br><span class="line">    const width = ref(0);</span><br><span class="line">    const items = ref([]);</span><br><span class="line">    const H = ref([]);</span><br><span class="line">    const flag = ref(null);</span><br><span class="line"></span><br><span class="line">​    const init = () =&gt; &#123;</span><br><span class="line">​      items.value = Array.from($el.value.children);</span><br><span class="line">​      reset();</span><br><span class="line">​      render();</span><br><span class="line">​    &#125;;</span><br><span class="line"></span><br><span class="line">​    const reset = () =&gt; &#123;</span><br><span class="line">​      flag.value = document.createDocumentFragment();</span><br><span class="line">​      console.log($el.value.clientWidth);</span><br><span class="line">​      width.value = $el.value.clientWidth / count.value;</span><br><span class="line">​      H.value = new Array(count.value).fill(0);</span><br><span class="line">​      $el.value.innerHTML = &#x27;&#x27;;</span><br><span class="line">​    &#125;;</span><br><span class="line"></span><br><span class="line">​    const render = () =&gt; &#123;</span><br><span class="line">​      items.value.forEach((item) =&gt; &#123;</span><br><span class="line">​        item.style.width = `$&#123;width.value&#125;px`;</span><br><span class="line">​        item.style.position = &#x27;absolute&#x27;;</span><br><span class="line">​        const img = item.querySelector(&#x27;img&#x27;);</span><br><span class="line">​        if (img.complete) &#123;</span><br><span class="line">​          const tag = H.value.indexOf(Math.min(...H.value));</span><br><span class="line">​          item.style.left = `$&#123;tag * (width.value + gap.value)&#125;px`;</span><br><span class="line">​          item.style.top = `$&#123;H.value[tag]&#125;px`;</span><br><span class="line">​          H.value[tag] += (img.height * width.value) / img.width + gap.value;</span><br><span class="line">​          flag.value.appendChild(item);</span><br><span class="line">​        &#125; else &#123;</span><br><span class="line">​          img.addEventListener(&#x27;load&#x27;, () =&gt; &#123;</span><br><span class="line">​            const tag = H.value.indexOf(Math.min(...H.value));</span><br><span class="line">​            item.style.left = `$&#123;tag * (width.value + gap.value)&#125;px`;</span><br><span class="line">​            item.style.top = `$&#123;H.value[tag]&#125;px`;</span><br><span class="line">​            H.value[tag] += (img.height * width.value) / img.width + gap.value;</span><br><span class="line">​            flag.value.appendChild(item);</span><br><span class="line">​            $el.value.append(flag.value);</span><br><span class="line">​          &#125;);</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;);</span><br><span class="line">​      $el.value.append(flag.value);</span><br><span class="line">​    &#125;;</span><br><span class="line"></span><br><span class="line">​    onMounted(() =&gt; &#123;</span><br><span class="line">​      init();</span><br><span class="line">​    &#125;);</span><br><span class="line"></span><br><span class="line">​    return &#123;</span><br><span class="line">​      $el,</span><br><span class="line">​      count,</span><br><span class="line">​      gap,</span><br><span class="line">​      width,</span><br><span class="line">​      items,</span><br><span class="line">​      H,</span><br><span class="line">​      flag,</span><br><span class="line">​      reset,</span><br><span class="line">​      render</span><br><span class="line">​    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style  scoped&gt;</span><br><span class="line"></span><br><span class="line">.waterfall &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.waterfall .item &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  /* 其他样式属性 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/10/08/leetcode/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 确定dp数组下标含义 dp[i][j] 到每一个坐标可能的路径种类</span></span><br><span class="line"><span class="comment">     * 2. 递推公式 dp[i][j] = dp[i-1][j] dp[i][j-1]</span></span><br><span class="line"><span class="comment">     * 3. 初始化 dp[i][0]=1 dp[0][i]=1 初始化横竖就可</span></span><br><span class="line"><span class="comment">     * 4. 遍历顺序 一行一行遍历</span></span><br><span class="line"><span class="comment">     * 5. 推导结果 。。。。。。。。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[class和function构造类的区别.]]></title>
      <url>/2023/10/06/es6/class%E5%92%8Cfunction%E6%9E%84%E9%80%A0%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>1 类的所有代码都在严格模式下执行  函数的this不是windows</p>
<p>   注意 ：  类中方法的this 不是固定的</p>
<p>​                 以方法形式调用时，this就是当前的实例    xx.fn()  </p>
<p>​                以函数形式调用是，this是undefined           fn()</p>
<p>​     解决 使用箭头函数来</p>
<p>2  类只用new调用 </p>
<p>3 类的方法都是放在原型上的</p>
<p>4 类的方法不可枚举     类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p> 5 重复定义：function会覆盖之前定义的方法；class会报错</p>
<p>6、class没有<a href="https://so.csdn.net/so/search?q=%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87&spm=1001.2101.3001.7020">变量提升</a>，function有</p>
<p>7、class定义的类没有私有方法和私有属性</p>
<p>8  关于构造器constructor：在function定义的构造函数中，其prototype.constructor属性指向构造器本身，在class定义的类中，constructor其实也相当于定义在prototype属性上。</p>
<p><a href="https://github.com/tc39/proposal-class-fields">ES2022</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p>
<p><strong>新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上面。</strong>  这个属性是实例对象的this上面的</p>
<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解释<span class="keyword">class</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  bar = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  baz = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vite中静态资源的动态导入]]></title>
      <url>/2023/09/14/bug/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5/</url>
      <content type="html"><![CDATA[<p><a href="https://www.douyin.com/user/self?modal_id=7269754701720112444&showTab=like">来一份棉花糖的主页 - 抖音 (douyin.com)</a></p>
<p>vite脚手架的打包 不会给我们打包动态导入的资源  静态资源打包问题  打包路径和源码路径不一致造成</p>
<p>解决方案 </p>
<p>1 将src下的assetc文件放到public文件中（此文件会全部打包） 缺点:丢失掉文件指纹</p>
<p>2 </p>
<p><img src="/Yuanmingjian/../../images/image-20230914213740338.png" alt="image-20230914213740338"></p>
<p><img src="/Yuanmingjian/../../images/image-20230914213813168.png" alt="image-20230914213813168"></p>
<p>该文件将import的文件打包 缺点会生成大量js文件 造成会发送很多url请求</p>
<p>3 </p>
<p><img src="/Yuanmingjian/../../images/image-20230914213925659.png" alt="image-20230914213925659"></p>
<p><img src="/Yuanmingjian/../../images/image-20230914213953498.png" alt="image-20230914213953498"></p>
]]></content>
      
        <categories>
            
            <category> bug </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue的一些遇到的bug/问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[柯里化函数的使用]]></title>
      <url>/2023/09/11/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>概念：将使用多个参数的函数转换成一系列使用一个参数的函数</p>
<p><strong>闭包在柯里化函数中主要作用就是帮助我们保存已经传入的参数，以便于后续调用时使用。这也是柯里化函数可以实现链式调用的关键所在。</strong></p>
<h4 id="示例代码（通用）"><a href="#示例代码（通用）" class="headerlink" title="示例代码（通用）"></a>示例代码（通用）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args=[] <span class="comment">//收集新的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(newArgs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>curry</code> 函数可以接受任意函数作为参数，并返回一个新函数。新函数在接收到足够的参数后，会调用原始函数 <code>fn</code>，否则会递归调用自身，并将已有的参数与新的参数连接起来。apply的作用就是将后面的数组序列化传过去</p>
<p>你可以根据具体需求使用这个通用的柯里化函数来实现不同的功能。例如，对一个求和函数进行柯里化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedSum = <span class="title function_">curry</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));  <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们使用 <code>curry</code> 函数对 <code>sum</code> 函数进行柯里化。然后，我们可以使用链式调用的方式分别传递参数 <code>1</code>、<code>2</code> 和 <code>3</code>，最终获得求和结果 <code>6</code>。</p>
<p>需要注意的是，柯里化函数的实现可能存在性能问题，因为每次调用都会创建新的函数。在实际开发中，应根据具体情况来权衡使用柯里化的利与弊，并选择合适的实现方式。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>&#x2F;&#x2F;版本1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sumEvent</span> = (<span class="params">...*params*</span>)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> *params*.<span class="title function_">reduce</span>(<span class="function">(<span class="params">*opt1*,*opt2*</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *opt1*+*opt2*</span><br><span class="line"></span><br><span class="line"> &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currying=<span class="keyword">function</span> (<span class="params">*option*</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> argument=[] <span class="comment">//收集参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">consequence</span>(<span class="params">...*params*</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(!*params*.<span class="property">length</span>)<span class="comment">//没有参数的时候执行  此处也可以换成当新参数长度&gt;=旧参数长度</span></span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="title function_">option</span>(...argument)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//收集参数 继续调用 直到没有参数</span></span><br><span class="line"></span><br><span class="line">   argument.<span class="title function_">push</span>(...*params*)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> consequence</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(currying(sumEvent)(1,4)(3,5)());</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/../images/image-20230911144758972.png" alt="image-20230911144758972"></p>
<p>代码实现了一个类似柯里化（Currying）的函数 <code>add</code>，它可以接受多个参数并返回一个新的函数。每次调用返回的函数都会将新的参数添加到参数列表中，并且该函数还重写了 <code>toString</code> 方法，使其返回参数列表的和。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[最长递增子序列]]></title>
      <url>/2023/09/06/leetcode/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@param</span> *&#123;number[]&#125;* *nums*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@return</span> *&#123;number&#125;*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="keyword">function</span>(<span class="params">*nums*</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*nums*.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> target=[*nums*[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">1</span> ; i &lt; *nums*.<span class="property">length</span>; i++)&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target[target.<span class="property">length</span>-<span class="number">1</span>]&lt;*nums*[i])&#123;</span><br><span class="line"></span><br><span class="line">   target.<span class="title function_">push</span>(*nums*[i])</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> indexs=<span class="title function_">findFirst</span>(*nums*[i])</span><br><span class="line"></span><br><span class="line">   target[indexs]=*nums*[i]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">findFirst</span>(<span class="params">*x*</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; target.<span class="property">length</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(target[i]&gt;=*x*)&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res=<span class="title function_">lengthOfLIS</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/image-20230906145325562.png" alt="image-20230906145325562"></p>
<h4 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2 贪心"></a>2 贪心</h4><p> 从前往后遍历数字 将数字传入函数（n）</p>
<p> 从后往前遍历结果数组   若n&gt;数组【i】最后一位 拼接  一直遍历到第一个若还是小于就直接替换了</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[setup中的defineprops]]></title>
      <url>/2023/08/31/vue/setup%E4%B8%AD%E7%9A%84defineprops/</url>
      <content type="html"><![CDATA[<p>运行时声明</p>
<script setup lang="ts">
/**
 *  type：参数类型
 *  required：必须传参（默认：false）
 *  default：默认值
 * /
const props = defineProps({
  name: {
    type: String,
    required: true
  },
  title: {
    type: Number,
       required: false
  },
  status: Boolean
})
</script>






<p>基于类型的声明</p>
<script setup lang="ts">
/**
 * 方式一：通过泛型参数
 */
const props = defineProps<{
  name?: string,
  title: number,
  status?: boolean
}>()

/**
 * 方式二：编写单独接口
 */
  interface Props {
    name?: string,
    title: number,
    status?: boolean
  }
  const props = defineProps<Props>()

// ?代表可选参数 可以不用传
</script>



<p>在 Vue 3 中，在 <code>&lt;script setup&gt;</code> 中声明 props 的方式有两种：运行时声明和基于类型的声明。它们的区别在于定义 props 的方式不同，具体解释如下：</p>
<ol>
<li>运行时声明</li>
</ol>
<p>运行时声明是通过 <code>defineProps</code> 函数来定义组件的 props，并在该函数中传入一个对象字面量，用于指定每个 prop 的类型、默认值、是否必须等其他选项。这种方式的优点是灵活性高，可以根据需要为每个 prop 定义不同的选项。</p>
<p>在你提供的示例代码中就是使用运行时声明的方式来定义 props，其中 <code>defineProps</code> 用于声明 props 类型，对象字面量用于指定每个 prop 的选项。例如 <code>&#123; type: String, required: true &#125;</code> 表示指定 <code>name</code> prop 的类型为字符串类型且必须传入参数。</p>
<ol>
<li>基于类型的声明</li>
</ol>
<p>基于类型的声明是通过 TypeScript 的类型系统来定义组件的 props，并使用 <code>defineProps</code> 函数来声明组件的 props 类型。这种方式的优点是类型安全性高，可以在编译时检查 prop 的类型，避免在运行时出现类型错误。</p>
<p>在你提供的示例代码中就是使用基于类型的声明的方式来定义 props，其中通过两种方式（泛型参数和单独接口）定义了 <code>Props</code> 接口，然后使用 <code>defineProps&lt;Props&gt;()</code> 函数声明组件的 props 类型为 <code>Props</code>。这样，在组件中使用 props 时，就会有 TypeScript 的类型检查。例如 <code>const &#123; name, title, status &#125; = props</code>，会根据 <code>Props</code> 接口自动推导 <code>name</code> 的类型为可选字符串类型、<code>title</code> 的类型为必选数值类型，以及 <code>status</code> 的类型为可选布尔类型。</p>
<p>总体来说，两种声明方式各有优点，可以根据项目需要进行选择使用。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>const props&#x3D;defineProps      &lt;{ list:BannerItem[]} &gt;       ()</p>
<p>这段代码是 Vue 3 中的一个新的特性，称为 Composition API。它允许你使用类型注解来定义组件的 props，从而获得更强大的类型检查和错误处理。</p>
<p><code>defineProps</code> 函数是 <code>setup</code> 函数中的一个辅助函数，用于定义组件的 props。它接受一个类型注解作为参数，该注解定义了 props 的结构。</p>
<p>在这个例子中，我们使用 <code>defineProps&lt;&#123;list: BannerItem[]&#125;&gt;()</code> 来定义一个名为 <code>list</code> 的 prop，其类型为 <code>BannerItem[]</code>。这意味着组件可以接收一个包含 <code>BannerItem</code> 对象的数组作为 <code>list</code> 属性。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[v-model的使用]]></title>
      <url>/2023/08/28/vue/vmodel/</url>
      <content type="html"><![CDATA[<h2 id="三、Vue3-x-使用-v-model"><a href="#三、Vue3-x-使用-v-model" class="headerlink" title="三、Vue3.x 使用 v-model"></a>三、Vue3.x 使用 v-model</h2><p>vue2 中的 v-model 和 .sync 功能重叠，容易混淆，因此 vue3 做了统一，一个组件可以多次使用 v-model 。</p>
<p><strong>3.1、vue 3 的v-model使用原理：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">复制代码&lt;child-comp v-model=<span class="string">&quot;msg&quot;</span> /&gt; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//可翻译为</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">child-comp</span> <span class="attr">:modelValue</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;msg=$event&quot;</span> /&gt;</span></span>  <span class="comment">//类似注册了一个update事件 </span></span><br></pre></td></tr></table></figure>

<p>单个数据双向绑定完整示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件代码</span></span><br><span class="line">&lt;child-comp v-model=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">  </span><br><span class="line">子组件代码：</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;newValue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="attr">props</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">modelValue</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="attr">type</span>:<span class="title class_">String</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="attr">default</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">newValue</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">modelValue</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="attr">set</span>:<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>,value)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>vue3 使用特定的 modelValue ，避免 value 的占用，通过 update:modelValue 实现数据双向绑定。值得注意的是，vue3 移除了 model 选项。</p>
<p><strong>3.2、多个 v-model 使用</strong></p>
<p>在 vue3 一个组件可以使用多个 v-model ，统一了 vue2 的 v-model 和 .sync 修饰符。</p>
<p>使用原理：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ruby复制代码&lt;child-comp v-<span class="symbol">model:</span>name=<span class="string">&quot;name&quot;</span> v-<span class="symbol">model:</span>age=<span class="string">&quot;age&quot;</span> /&gt; </span><br><span class="line">  </span><br><span class="line">  <span class="regexp">//</span>可翻译为</span><br><span class="line">&lt;child-comp </span><br><span class="line">  <span class="symbol">:name=<span class="string">&quot;name&quot;</span></span> <span class="variable">@update</span><span class="symbol">:name=<span class="string">&quot;name=$event&quot;</span></span></span><br><span class="line">  <span class="symbol">:age=<span class="string">&quot;age&quot;</span></span> <span class="variable">@update</span><span class="symbol">:age=<span class="string">&quot;age=$event&quot;</span></span> /&gt; </span><br></pre></td></tr></table></figure>

<p>实现多个数据双向绑定完整实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码<span class="comment">//父组件代码</span></span><br><span class="line">&lt;child-comp v-<span class="attr">model</span>:name=<span class="string">&quot;name&quot;</span> v-<span class="attr">model</span>:age=<span class="string">&quot;age&quot;</span> /&gt; </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//子组件代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;newName&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;newAge&quot;&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> props:&#123;</span><br><span class="line">  name:&#123;</span><br><span class="line">   type:String,</span><br><span class="line">   default:&#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  age:&#123;</span><br><span class="line">   type:String,</span><br><span class="line">   default:&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> emits:[&#x27;update:name&#x27;,&#x27;update:age&#x27;],</span><br><span class="line"> computed:&#123;</span><br><span class="line">  newName:&#123;</span><br><span class="line">   get:function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">   &#125;,</span><br><span class="line">  set:function(value)&#123;</span><br><span class="line">    this.$emit(&#x27;update:name&#x27;,value)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> newAge:&#123;</span><br><span class="line">  get:function()&#123;</span><br><span class="line">   return this.age</span><br><span class="line">  &#125;,</span><br><span class="line">  set:function(value)&#123;</span><br><span class="line">   this.$emit(&#x27;update:age&#x27;,value)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>

<p>需要注意的是 script 中多了一个 emits 选项，你发现了吗？</p>
<p>vue3 组件的自定义事件需要定义在 emits 选项中，只要是自定义事件，就需要添加在 emits 中，否则会有警告。它的优点：</p>
<ol>
<li>如果与原生事件相同名时，事件就会被触发两次，如果在 emits 选项中加入时，当作自定义事件处理，只会触发一次。</li>
<li>更好地指示组件的工作方式。</li>
<li>可以校验对象形式的事件。</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>从 vue2.0 开始，组件上自定义 v-model 进行数据双向绑定，不断改进它的使用。过程如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码&lt;child-comp <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span> /&gt; </span><br></pre></td></tr></table></figure>

<p><strong>4.1、vue2.0 可以翻译为：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码&lt;child-comp :<span class="attr">value</span>=<span class="string">&quot;msg&quot;</span> @input=<span class="string">&quot;msg=$event&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>存在问题：v-model 和 value 有一个强绑定关系，如果子组件中有一个 input 原生标签，此时就会影响原生标签的 value 和 input 事件。</p>
<p><strong>4.2、vue2.2版本</strong></p>
<p>引入了 model 组件选项，允许开发者任意指定 v-model 的 props 和 event 。这样就解决了 vue2.0 中的 v-model 和 value 的强绑定关系。但是还是存在一个问题，就是多个数据双向绑定时，还是需要借助 .sync 修饰符。</p>
<p><strong>4.3、vue3.x 版本</strong></p>
<p>Vue3 可以翻译为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby</span><br><span class="line">复制代码&lt;child-comp <span class="symbol">:modelValue=<span class="string">&quot;msg&quot;</span></span> <span class="variable">@update</span><span class="symbol">:modelValue=<span class="string">&quot;msg=$event&quot;</span></span> /&gt; </span><br></pre></td></tr></table></figure>

<p>vue3 统一 使用 v-model 进行多个数据双向绑定，废除了 model 组件选项。</p>
<p>子组件只能在defineprops 通过指定参数modelValue来接收 </p>
<h4 id="例-3-1"><a href="#例-3-1" class="headerlink" title="例 3.1"></a>例 3.1</h4><p><img src="/../../images/image-20230828142747120.png" alt="image-20230828142747120"></p>
<p>当子组件出现表单等  使用v-model绑定各个文本框 这是如果直接绑定从父组件通过v-model传来的数据时 会打破单向数据流  这是需要把v-model  展开成以下内容 通过emit触发事件修改<img src="/../../images/image-20230828142947175.png" alt="image-20230828142947175"></p>
<p><img src="/../../images/image-20230828143028523.png" alt="image-20230828143028523"></p>
<h3 id="优化-通用computed来绑定"><a href="#优化-通用computed来绑定" class="headerlink" title="优化 通用computed来绑定"></a>优化 通用computed来绑定</h3><p><img src="/../../images/image-20230828143145981.png" alt="image-20230828143145981"></p>
<p>在computed中的set中 触发emit事件  将v-model中的绑定computed的值1</p>
<p><img src="/../../images/image-20230828143304116.png" alt="image-20230828143304116"></p>
<p><img src="/../../images/image-20230828143319808.png" alt="image-20230828143319808"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[部署服务器中 nginx的配置]]></title>
      <url>/2023/08/17/nginx%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 4096;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line">        //重要配置地方</span><br><span class="line">        location / &#123;</span><br><span class="line">        root       /home/www/dist;</span><br><span class="line">        index     index.html;</span><br><span class="line">        try_files  $uri  $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        //以什么开头的路由一般为api接口 反向代理 该地址d</span><br><span class="line">        location /page4 &#123;</span><br><span class="line">          proxy_pass   http://81.70.228.109:8000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># Settings for a TLS enabled server.</span><br><span class="line">#</span><br><span class="line">#    server &#123;</span><br><span class="line">#        listen       443 ssl http2;</span><br><span class="line">#        listen       [::]:443 ssl http2;</span><br><span class="line">#        server_name  _;</span><br><span class="line">#        root         /usr/share/nginx/html;</span><br><span class="line">#</span><br><span class="line">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span><br><span class="line">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span><br><span class="line">#        ssl_session_cache shared:SSL:1m;</span><br><span class="line">#        ssl_session_timeout  10m;</span><br><span class="line">#        ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">#        ssl_prefer_server_ciphers on;</span><br><span class="line">#</span><br><span class="line">#        # Load configuration files for the default server block.</span><br><span class="line">#        include /etc/nginx/default.d/*.conf;</span><br><span class="line">#</span><br><span class="line">#        error_page 404 /404.html;</span><br><span class="line">#            location = /40x.html &#123;</span><br><span class="line">#        &#125;</span><br><span class="line">#</span><br><span class="line">#        error_page 500 502 503 504 /50x.html;</span><br><span class="line">#            location = /50x.html &#123;</span><br><span class="line">#        &#125;</span><br><span class="line">#    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 问题</p>
<p>nginx 配置 报错 500     root 权限开启</p>
<p>2 检查防火墙设置： 如果您启用了防火墙，需要确保已将80端口（HTTP）和443端口（HTTPS）开放。执行以下命令来检查防火墙规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>如果80端口和443端口没有列出，则需要添加防火墙规则。执行以下命令来添加规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-service=http --permanent</span><br><span class="line">sudo firewall-cmd --add-service=https --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>



]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ts 贪吃蛇项目回顾]]></title>
      <url>/2023/08/14/%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      <content type="html"><![CDATA[<p>1 创建三个类 蛇（蛇头   蛇身体（包括头））       食物（）               积分难度</p>
<p>2 键盘事件加定时器（递归思想 run里面调定时器回调run）<br>3 判断蛇与食物的坐标相等是  蛇的长度加一 积分加一  </p>
<p>4 边界判断 蛇不能越出指定范围 在蛇类中set中判断 </p>
<p>5 蛇身体的移动 从后往前遍历 当前坐标去等于前一个坐标 </p>
<p>6 掉头 判断蛇头坐标是否等于第二个身体 做相应对策 如正在右走掉头 继续右走</p>
<p>7 蛇身相撞  遍历判断蛇头于蛇身坐标  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域配置]]></title>
      <url>/2023/08/12/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p> vue3 </p>
<p> server: {</p>
<p>  proxy: {</p>
<p>   &#x2F;&#x2F;通过代理实现跨域</p>
<p>   “&#x2F;api”: {</p>
<p>​    target: “<a href="http://81.70.228.109:8000&quot;">http://81.70.228.109:8000&quot;</a>, &#x2F;&#x2F;替换的域名地址</p>
<p>​    changeOrigin: true, &#x2F;&#x2F;开启代理，表示允许跨域</p>
<p>​    rewrite: (<em>path</em>) &#x3D;&gt; <em>path</em>.replace(&#x2F;^/api&#x2F;, ‘’)&#x2F;&#x2F;重写路径，替换字符串”&#x2F;path”      &#x2F;&#x2F;&#x2F; vue2 写这个pathRewrite: {‘^&#x2F;api1’: ‘’}},</p>
<p>   },</p>
<p>  },</p>
<p> },</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ts的一些使用]]></title>
      <url>/2023/08/11/ts/</url>
      <content type="html"><![CDATA[<h4 id="3-3-确定赋值断言"><a href="#3-3-确定赋值断言" class="headerlink" title="3.3 确定赋值断言"></a>3.3 确定赋值断言</h4><p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：<strong>静态编译阶段 无法判断x是否赋值</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"><span class="comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言： </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p>
<h4 id="下面案例是一个父组件获取子组件暴露的数据，需要用到ref。"><a href="#下面案例是一个父组件获取子组件暴露的数据，需要用到ref。" class="headerlink" title="下面案例是一个父组件获取子组件暴露的数据，需要用到ref。"></a>下面案例是一个父组件获取子组件暴露的数据，需要用到ref。</h4><p>父组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Search ref=&quot;searchRef&quot; @search=&quot;handleSearch&quot;&gt;&lt;/Search&gt;</span><br><span class="line">	&lt;el-button @click=&quot;getData&quot;&gt;获取子组件暴露的数据&lt;/el-button&gt;	</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">	import Search from &#x27;./component/search.vue&#x27;</span><br><span class="line">	const searchRef = ref&lt;any&gt;(null)</span><br><span class="line">	const getData = ()=&gt;&#123;</span><br><span class="line">		console.log(searchRef.value?.queryData)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;&#123;&#123; queryData.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">	const queryData = reative(&#123;</span><br><span class="line">		name:&#x27;tt&#x27;</span><br><span class="line">	&#125;)</span><br><span class="line">	defineExpose(&#123;</span><br><span class="line">	    queryData</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这么写也是没问题(反正any大法，不报错)，有一天实在想规范申明下，找了下规范的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Search ref=&quot;searchRef&quot; @search=&quot;handleSearch&quot;&gt;&lt;/Search&gt;</span><br><span class="line">	&lt;el-button @click=&quot;getData&quot;&gt;获取子组件暴露的数据&lt;/el-button&gt;	</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">	import Search from &#x27;./component/search.vue&#x27;</span><br><span class="line">	// 正确的写法：</span><br><span class="line">	const searchRef = ref&lt;InstanceType&lt;typeof Search&gt; | null&gt;(null)</span><br><span class="line">	const getData = ()=&gt;&#123;</span><br><span class="line">		console.log(searchRef.value?.queryData)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ref和reactive]]></title>
      <url>/2023/08/09/vue/ref%E5%92%8Creactive/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/5f2d18460f854584a3b3e31f964508betplv-k3u1fbpfcp-jj-mark0000q75.webp" alt="img"></p>
<h3 id="ref解包"><a href="#ref解包" class="headerlink" title="ref解包"></a>ref解包</h3><h6 id="1-ref在模板中自动解包"><a href="#1-ref在模板中自动解包" class="headerlink" title="1. ref在模板中自动解包"></a>1. ref在模板中自动解包</h6><p>当ref作为顶层属性在模板中使用时，自动解包，不用<code>.value</code>即可获取值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(1);</span><br><span class="line">count.value = 2;</span><br></pre></td></tr></table></figure>

<p>直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- count值为2 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;count + 1&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>若不是顶层属性, 假如值需要逻辑操作，则会出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    age: ref(1)</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 可以正常显示--&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;obj.age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 会报错  渲染的结果会是一个 [object Object]，因为 obj.age 是一个 ref 对象。需要obj.age.value 才能正常显示--&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;obj.age + 1&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>解构后也具有响应式 (reactive 结构后会出现问题)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;age&#125; = obj;</span><br></pre></td></tr></table></figure>

<h6 id="2-ref-在响应式对象中的解包"><a href="#2-ref-在响应式对象中的解包" class="headerlink" title="2. ref 在响应式对象中的解包"></a>2. ref 在响应式对象中的解包</h6><p>一个ref对象嵌套在一个响应式对象中，属性访问时会自动解包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = ref(1)</span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">    age: a</span><br><span class="line">&#125;)</span><br><span class="line">console.log(state.age); // 1 直接解包，不用state.age.value</span><br></pre></td></tr></table></figure>

<p>如果将一个新的 ref 赋值给另一个对象具有 ref属性的 ，那么它会替换掉旧的 ref。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const b = ref(3);</span><br><span class="line">// 假如将b直接赋值给state.age,因为b是一个ref对象，则会替代之前的ref对象，则现在state.age不管如何变化都变量a没有了关系</span><br><span class="line">state.age = b;</span><br><span class="line">console.log(stata.age); // 3</span><br><span class="line">console.log(a); // 1</span><br><span class="line">// 假如将b.value赋值给state.age,其实b.value就相等于一个值，并不是ref对象，则不会替代之前的ref对象，则state.age变化，之前的变量a也会随之变化</span><br><span class="line">state.age = b.value;</span><br><span class="line">console.log(state.age); // 3</span><br><span class="line">console.log(a); // 3</span><br></pre></td></tr></table></figure>

<p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。</p>
<h2 id="3-数组和集合类型的-ref-解包"><a href="#3-数组和集合类型的-ref-解包" class="headerlink" title="3. 数组和集合类型的 ref 解包"></a>3. 数组和集合类型的 ref 解包</h2><p>跟响应式对象不同，当 ref 作为响应式数组或像 <code>Map</code> 这种原生集合类型的元素被访问时，不会进行解包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">&#x27;Vue 3 Guide&#x27;</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>)</span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;count&#x27;</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;count&#x27;</span>).<span class="property">value</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node中的流]]></title>
      <url>/2023/08/07/nodejs/%E6%B5%81/</url>
      <content type="html"><![CDATA[<h2 id="流的介绍"><a href="#流的介绍" class="headerlink" title="流的介绍"></a>流的介绍</h2><p>在 NodeJS 中，我们对文件的操作需要依赖核心模块 <code>fs</code>，<code>fs</code> 中有很基本 API 可以帮助我们读写占用内存较小的文件，如果是大文件或内存不确定也可以通过 <code>open</code>、<code>read</code>、<code>write</code>、<code>close</code> 等方法对文件进行操作，但是这样操作文件每一个步骤都要关心，非常繁琐，<code>fs</code> 中提供了可读流和可写流，让我们通过流来操作文件，方便我们对文件的读取和写入。</p>
<h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><h3 id="1、createReadStream-创建可读流"><a href="#1、createReadStream-创建可读流" class="headerlink" title="1、createReadStream 创建可读流"></a>1、createReadStream 创建可读流</h3><p><code>createReadStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有八个参数：</p>
<ul>
<li>flags：标识位，默认为 <code>r</code>；</li>
<li>encoding：字符编码，默认为 <code>null</code>；</li>
<li>fd：文件描述符，默认为 <code>null</code>；</li>
<li>mode：权限位，默认为 <code>0o666</code>；</li>
<li>autoClose：是否自动关闭文件，默认为 <code>true</code>；</li>
<li>start：读取文件的起始位置；</li>
<li>end：读取文件的（包含）结束位置；</li>
<li>highWaterMark：最大读取文件的字节数，默认 <code>64 * 1024</code>。</li>
</ul>
<p><code>createReadStream</code> 的返回值为 <code>fs.ReadStream</code> 对象，读取文件的数据在不指定 <code>encoding</code> 时，默认为 Buffer。</p>
<p>创建可读流</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 创建可读流，读取 1.txt 文件</span><br><span class="line">let <span class="attr">rs</span> = fs.creatReadStream(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    end: 3,</span><br><span class="line">    highWaterMark: 2</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在创建可读流后默认是不会读取文件内容的，读取文件时，可读流有两种状态，暂停状态和流动状态。</p>
<p><strong>注意：本篇的可写流为流动模式，流动模式中有暂停状态和流动状态，而不是暂停模式，暂停模式是另一种可读流 <code>readable</code>。</strong></p>
<h3 id="2、流动状态"><a href="#2、流动状态" class="headerlink" title="2、流动状态"></a>2、流动状态</h3><p>流动状态的意思是，一旦开始读取文件，会按照 <code>highWaterMark</code> 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 <code>data</code> 事件触发。</p>
<p>假如现在 <code>1.txt</code> 文件中的内容为 <code>0~9</code> 十个数字，我们现在创建可读流并用流动状态读取。</p>
<p>流动状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">end</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听读取结束</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读完了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;Buffer 30 31&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32 33&gt;</span></span><br><span class="line"><span class="comment">// 读完了</span></span><br></pre></td></tr></table></figure>

<p>在上面代码中，返回的 <code>rs</code> 对象监听了两个事件：</p>
<ul>
<li>data：每次读取 <code>highWaterMark</code> 个字节，触发一次 <code>data</code> 事件，直到读取完成，回调的参数为每次读取的 Buffer；</li>
<li>end：当读取完成时触发并执行回调函数。</li>
</ul>
<p>我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 <code>data</code> 事件触发时进行拼接，以前我们可能使用下面这种方式。</p>
<p>错误拼接数据的方式</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">rs</span> = fs.createReadStream(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    end: 3,</span><br><span class="line">    highWaterMark: 2</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">str</span> = <span class="string">&quot;&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;data&quot;, <span class="attr">data</span> =&gt; &#123;</span><br><span class="line">    str += data<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(str)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 0123</span><br></pre></td></tr></table></figure>

<p>在上面代码中如果读取的文件内容是中文，每次读取的 <code>highWaterMark</code> 为两个字节，不能组成一个完整的汉字，在每次读取时进行 <code>+=</code> 操作会默认调用 <code>toString</code> 方法，这样会导致最后读取的结果是乱码。</p>
<p>在以后通过流操作文件时，大部分情况下都是在操作 Buffer，所以应该用下面这种方式来获取最后读取到的结果。</p>
<p>正确拼接数据的方式</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">rs</span> = fs.createReadStream(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    end: 3,</span><br><span class="line">    highWaterMark: 2</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 存储每次读取回来的 Buffer</span><br><span class="line">let <span class="attr">bufArr</span> = []<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;data&quot;, <span class="attr">data</span> =&gt; &#123;</span><br><span class="line">    bufArr.push(data)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(Buffer.concat(bufArr).toString())<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 0123</span><br></pre></td></tr></table></figure>

<h3 id="3、暂停状态"><a href="#3、暂停状态" class="headerlink" title="3、暂停状态"></a>3、暂停状态</h3><p>在流动状态中，一旦开始读取文件，会不断的触发 <code>data</code> 事件，直到读完，暂停状态是我们每读取一次就直接暂停，不再继续读取，即不再触发 <code>data</code> 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。</p>
<p>类似于开关水龙头的动作，也就是暂停和恢复读取的动作，在可读流返回的 <code>rs</code> 对象上有两个对应的方法，<code>pause</code> 和 <code>resume</code>。</p>
<p>在下面的场景中我们把创建可读流的结尾位置更改成 <code>9</code>，在每次读两个字节并暂停一秒后恢复读取，直到读完 <code>0~9</code> 十个数字。</p>
<p>暂停状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">end</span>: <span class="number">9</span>,</span><br><span class="line">    <span class="attr">hithWaterMark</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bufArr = [];</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    bufArr.<span class="title function_">push</span>(data);</span><br><span class="line">    rs.<span class="title function_">pause</span>(); <span class="comment">// 暂停读取</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;暂停&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rs.<span class="title function_">resume</span>(); <span class="comment">// 恢复读取</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Buffer</span>.<span class="title function_">concat</span>(bufArr).<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:52.436Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:53.439Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:54.440Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:55.442Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:56.443Z</span></span><br><span class="line"><span class="comment">// 0123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="4、错误监听"><a href="#4、错误监听" class="headerlink" title="4、错误监听"></a>4、错误监听</h3><p>在通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 <code>rs</code>对象可以通过 <code>error</code> 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 <code>err</code>，即错误对象。</p>
<p>错误监听</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 读取一个不存在的文件</span><br><span class="line">let <span class="attr">rs</span> = fs.createReadStream(<span class="string">&quot;xxx.js&quot;</span>, &#123;</span><br><span class="line">    highWarterMark: 2</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">bufArr</span> = []<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;data&quot;, <span class="attr">data</span> =&gt; &#123;</span><br><span class="line">    bufArr.push(data)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;err&quot;, <span class="attr">err</span> =&gt; &#123;</span><br><span class="line">    console.log(err)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">rs.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(Buffer.concat(bufArr).toString())<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// &#123; Error: ENOENT: no such file or directory, open &#x27;......xxx.js&#x27; ......&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、打开和关闭文件的监听"><a href="#5、打开和关闭文件的监听" class="headerlink" title="5、打开和关闭文件的监听"></a>5、打开和关闭文件的监听</h3><p>流的适用性非常广，不只是文件读写，也可以用在 <code>http</code> 中数据的请求和响应上，但是在针对文件读取返回的 <code>rs</code> 上有两个专有的事件用来监听文件的打开与关闭。</p>
<p><code>open</code> 事件用来监听文件的打开，回调函数在打开文件后执行，<code>close</code> 事件用来监听文件的关闭，如果创建的可读流的 <code>autoClose</code> 为 <code>true</code>，在自动关闭文件时触发，回调函数在关闭文件后执行。</p>
<p>打开和关闭可读流的监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">end</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br></pre></td></tr></table></figure>

<p>在上面代码我们看出只要创建了可读流就会打开文件触发 <code>open</code> 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 <code>close</code> 事件。</p>
<p>暂停状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">end</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">hithWaterMark</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br><span class="line"><span class="comment">// &lt;Buffer 30 31&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32 33&gt;</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// close</span></span><br></pre></td></tr></table></figure>

<p>从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 <code>close</code> 事件，<code>end</code> 事件的触发要早于 <code>close</code>。</p>
<h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><h3 id="1、createWriteStream-创建可写流"><a href="#1、createWriteStream-创建可写流" class="headerlink" title="1、createWriteStream 创建可写流"></a>1、createWriteStream 创建可写流</h3><p><code>createWriteStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有七个参数：</p>
<ul>
<li>flags：标识位，默认为 <code>w</code>；</li>
<li>encoding：字符编码，默认为 <code>utf8</code>；</li>
<li>fd：文件描述符，默认为 <code>null</code>；</li>
<li>mode：权限位，默认为 <code>0o666</code>；</li>
<li>autoClose：是否自动关闭文件，默认为 <code>true</code>；</li>
<li>start：写入文件的起始位置；</li>
<li>highWaterMark：一个对比写入字节数的标识，默认 <code>16 * 1024</code>。</li>
</ul>
<p><code>createWriteStream</code> 返回值为 <code>fs.WriteStream</code> 对象，第一次写入时会真的写入文件中，继续写入，会写入到缓存中。</p>
<p>创建可写流</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 创建可写流，写入 2.txt 文件</span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteStream(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、可写流的-write-方法"><a href="#2、可写流的-write-方法" class="headerlink" title="2、可写流的 write 方法"></a>2、可写流的 write 方法</h3><p>在可写流中将内容写入文件需要使用 <code>ws</code> 的 <code>write</code> 方法，参数为写入的内容，返回值是一个布尔值，代表 <code>highWaterMark</code> 的值是否足够当前的写入，如果足够，返回 <code>true</code>，否则返回 <code>false</code>，换种说法就是写入内容的长度是否超出了 <code>highWaterMark</code>，超出返回 <code>false</code>。</p>
<p>write 方法写入</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteSteam(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag1</span> = ws.write(<span class="string">&quot;1&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag1)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag2</span> = ws.write(<span class="string">&quot;2&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag2)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag3</span> = ws.write(<span class="string">&quot;3&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag3)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">// true</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>

<p>写入不存在的文件时会自动创建文件，如果 <code>start</code> 的值不是 <code>0</code>，在写入不存在的文件时默认找不到写入的位置。</p>
<h3 id="3、可写流的-drain-事件"><a href="#3、可写流的-drain-事件" class="headerlink" title="3、可写流的 drain 事件"></a>3、可写流的 drain 事件</h3><p><code>drain</code> 意为 “吸干”，当前写入的内容已经大于等于了 <code>highWaterMark</code>，会触发 <code>drain</code> 事件，当内容全部从缓存写入文件后，会执行回调函数。</p>
<p>drain 事件</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteStream(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag1</span> = ws.write(<span class="string">&quot;1&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag1)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag2</span> = ws.write(<span class="string">&quot;2&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag2)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag3</span> = ws.write(<span class="string">&quot;3&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag3)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ws.on(&quot;drain&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;吸干&quot;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">// true</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>

<h3 id="4、可写流的-end-方法"><a href="#4、可写流的-end-方法" class="headerlink" title="4、可写流的 end 方法"></a>4、可写流的 end 方法</h3><p><code>end</code> 方法传入的参数为最后写入的内容，<code>end</code> 会将缓存未写入的内容清空写入文件，并关闭文件。</p>
<p>end 方法</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteStream(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag1</span> = ws.write(<span class="string">&quot;1&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag1)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag2</span> = ws.write(<span class="string">&quot;2&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag2)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">flag3</span> = ws.write(<span class="string">&quot;3&quot;</span>)<span class="comment">;</span></span><br><span class="line">console.log(flag3)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ws.on(&quot;drain&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;吸干&quot;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ws.end(&quot;写完了&quot;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// true</span><br><span class="line">// true</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>

<p>在调用 <code>end</code> 方法后，即使再次写入的值超出了 <code>highWaterMark</code> 也不会再触发 <code>drain</code> 事件了，此时打开 <code>2.txt</code> 后发现文件中的内容为 “123写完了”。</p>
<p>常见报错</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteStream(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    start: 0,</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ws.write(&quot;1&quot;)<span class="comment">;</span></span><br><span class="line">ws.end(&quot;写完了&quot;)<span class="comment">;</span></span><br><span class="line">ws.write(&quot;2&quot;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// Error <span class="section">[ERR_STREAM_WRITE_AFTER_END]</span>: write after end...</span><br></pre></td></tr></table></figure>

<p>在调用 <code>end</code> 方法后，不可以再调用 <code>write</code> 方法写入，否则会报一个很常见的错误 <code>write after end</code>，文件原有内容会被清空，而且不会被写入新内容。</p>
<h2 id="可写流与可读流混合使用"><a href="#可写流与可读流混合使用" class="headerlink" title="可写流与可读流混合使用"></a>可写流与可读流混合使用</h2><p>可写流和可读流一般配合来使用，读来的内容如果超出了可写流的 <code>highWaterMark</code>，则调用可读流的 <code>pause</code>暂停读取，等待内存中的内容写入文件，未写入的内容小于 <code>highWaterMark</code> 时，调用可写流的 <code>resume</code> 恢复读取，创建可写流返回值的 <code>rs</code> 上的 <code>pipe</code> 方法是专门用来连接可读流和可写流的，可以将一个文件读来的内容通过流写到另一个文件中。</p>
<p>pipe 方法使用</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">fs</span> = require(<span class="string">&quot;fs&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 创建可读流和可写流</span><br><span class="line">let <span class="attr">rs</span> = fs.createReadStream(<span class="string">&quot;1.txt&quot;</span>, &#123;</span><br><span class="line">    highWaterMark: 3</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">let <span class="attr">ws</span> = fs.createWriteStream(<span class="string">&quot;2.txt&quot;</span>, &#123;</span><br><span class="line">    highWaterMark: 2</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 将 1.txt 的内容通过流写入 2.txt 中</span><br><span class="line">rs.pipe(ws)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>通过上面的这种类似于管道的方式，将一个流从一个文件输送到了另一个文件中，而且会根据读流和写流的 <code>highWaterMark</code> 自由的控制写入的 “节奏”，不用担心内存的消耗。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇是关于读流和写流的基本用法，在平时的开发当中，大多数的 API 都用不到，只有最后的 <code>pipe</code> 用的最多，无论是在文件的读写还是请求的响应，其他的 API 虽然用的少，但是作为一个合格的程序员一定要有所了解。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node中的可读流]]></title>
      <url>/2023/08/07/nodejs/%E5%8F%AF%E8%AF%BB%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>在Node.js中，Readable Stream 是一个抽象的基类，用于表示可读数据的源。<code>fs.createReadStream()</code> 是一个特定的可读流，用于从文件系统中读取数据。</p>
<p>下面是 <code>Readable</code> 和 <code>createReadStream()</code> 的主要区别：</p>
<ol>
<li>类型：<ul>
<li><code>Readable</code> 是一个抽象类，它是可读流的基类。可以通过继承 <code>Readable</code> 类来创建自定义的可读流。</li>
<li><code>createReadStream()</code> 是一个函数，用于创建一个特定类型的可读流，从文件系统中读取数据。</li>
</ul>
</li>
<li>数据源：<ul>
<li><code>Readable</code> 可以从任何数据源中读取数据，例如网络请求、内存缓冲区或其他流，也可以通过重写 <code>_read()</code> 方法来实现自定义数据源。</li>
<li><code>createReadStream()</code> 专门用于从文件系统中读取数据，它会打开指定的文件并读取其中的内容。</li>
</ul>
</li>
<li>参数：<ul>
<li><code>Readable</code> 类的构造函数不接收任何参数，需要通过继承并重写相关方法来实现自定义的可读流。</li>
<li><code>createReadStream()</code> 接收文件路径作为参数，以便打开指定的文件并读取其中的数据。</li>
</ul>
</li>
<li>用法：<ul>
<li>使用 <code>Readable</code> 类时，需要手动实现 <code>_read()</code> 方法，并调用 <code>push()</code> 方法将数据推送给消费者。</li>
<li>使用 <code>createReadStream()</code> 时，只需提供要读取的文件路径，然后可读流会自动将数据块推送给消费者。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>Readable</code> 是一个抽象的基类，用于构建自定义的可读流，而 <code>createReadStream()</code> 是一个具体的函数，用于创建从文件系统中读取数据的可读流。</p>
<h3 id="自定义可读流"><a href="#自定义可读流" class="headerlink" title="自定义可读流"></a>自定义可读流</h3><p><img src="/../../images/image-20230807205008834.png" alt="image-20230807205008834"></p>
<p>readable 为暂停模式的  需要主动调用read（） 来读数据</p>
<p>data为流动模式</p>
<p><img src="/../../images/image-20230807205909071.png" alt="image-20230807205909071"></p>
<p><img src="/../../images/image-20230807201158668.png" alt="image-20230807201158668"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Readable</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomReadStream</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Readable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(options);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">start</span> = options.<span class="property">start</span> || <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">end</span> = options.<span class="property">end</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">highWaterMark</span> = options.<span class="property">highWaterMark</span> || <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span> = fs.<span class="title function_">createReadStream</span>(options.<span class="property">file</span>, &#123;</span><br><span class="line">      <span class="attr">start</span>: <span class="variable language_">this</span>.<span class="property">start</span>,</span><br><span class="line">      <span class="attr">end</span>: <span class="variable language_">this</span>.<span class="property">end</span>,</span><br><span class="line">      <span class="attr">highWaterMark</span>: <span class="variable language_">this</span>.<span class="property">highWaterMark</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">(<span class="params">fd</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File opened:&#x27;</span>, fd);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">push</span>(chunk)) &#123;</span><br><span class="line">        <span class="comment">// 如果push返回false，表示内部缓冲区已满，暂停读取</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">pause</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 数据读取完毕后，调用push(null)表示结束</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">push</span>(<span class="literal">null</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File read completed&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File closed&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当内部缓冲区有空间时，恢复读取</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customReadStream = <span class="keyword">new</span> <span class="title class_">CustomReadStream</span>(&#123;</span><br><span class="line">  <span class="attr">file</span>: <span class="string">&#x27;1.txt&#x27;</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">50</span>,</span><br><span class="line">  <span class="attr">highWaterMark</span>: <span class="number">1024</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="小dome会以64k为分隔"><a href="#小dome会以64k为分隔" class="headerlink" title="小dome会以64k为分隔,"></a>小dome会以64k为分隔,</h4><p>将1.txt的内容拷贝到2.txt里面,这样的可读可写流在客户端传大文件给服务器时尤为重要!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可读流</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;./1.txt&quot;</span>)</span><br><span class="line"><span class="comment">//创建可写流</span></span><br><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&quot;./2.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听data方法,可读流每次读取会调用</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(!ws.<span class="title function_">write</span>(val+<span class="string">&quot;64k分隔\n&quot;</span>))&#123;<span class="comment">//\n是回车,\t是进格...</span></span><br><span class="line">        <span class="comment">//如果缓存满了会进此这个代码块</span></span><br><span class="line">        rs.<span class="title function_">pause</span>()<span class="comment">//暂停读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听可写流的drain方法,写入缓存空了会调用此方法</span></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;drain&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    rs.<span class="title function_">resume</span>() <span class="comment">//继续读取</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听end方法,可读流读取完毕时该方法调用</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>,<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">    <span class="comment">//记得关闭可写流!!!</span></span><br><span class="line">    ws.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听错误 </span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span>  <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>

<h3 id="写入和读入（生产数）"><a href="#写入和读入（生产数）" class="headerlink" title="写入和读入（生产数）"></a>写入和读入（生产数）</h3><p><img src="/../../images/image-20230807211151285.png" alt="image-20230807211151285"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Node的事件环]]></title>
      <url>/2023/08/06/nodejs/%E4%BA%8B%E4%BB%B6%E7%8E%AF/</url>
      <content type="html"><![CDATA[<h1 id="学Node-你不可能不知道Node的事件环吧"><a href="#学Node-你不可能不知道Node的事件环吧" class="headerlink" title="学Node,你不可能不知道Node的事件环吧"></a>学Node,你不可能不知道Node的事件环吧</h1><p><a href="https://juejin.cn/user/1222312662937800/posts">Sandy</a></p>
<p>2020-12-13 23:46347</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>和浏览器中一样NodeJS中也有事件环(Event Loop)</li>
<li>但是由于执行代码的宿主环境和应用场景不同</li>
<li>所以两者的事件环也有所不同</li>
</ul>
<h2 id="2-NodeJS事件环和浏览器事件环区别"><a href="#2-NodeJS事件环和浏览器事件环区别" class="headerlink" title="2.NodeJS事件环和浏览器事件环区别"></a>2.NodeJS事件环和浏览器事件环区别</h2><h3 id="2-1任务队列个数不同"><a href="#2-1任务队列个数不同" class="headerlink" title="2.1任务队列个数不同"></a>2.1任务队列个数不同</h3><ul>
<li>浏览器事件环有2个事件队列(宏任务队列和微任务队列)</li>
<li>NodeJS事件环有6个事件队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">index.js复制代码    ┌───────────────────────┐</span><br><span class="line">┌&gt; │timers          │执行setTimeout() 和 setInterval()中到期的callback</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │pending callbacks│执行系统操作的回调, 如:tcp, udp通信的错误callback</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │idle, prepare   │只在内部使用</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │poll            │执行与I/O相关的回调</span><br><span class="line">    │                  (除了close回调、定时器回调和setImmediate()之外，几乎所有回调都执行);</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │check           │执行setImmediate的callback</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└─┤close callbacks │执行close事件的callback，例如socket.on(&quot;close&quot;,func)</span><br><span class="line">    └───────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="2-2微任务队列不同"><a href="#2-2微任务队列不同" class="headerlink" title="2.2微任务队列不同"></a>2.2微任务队列不同</h3><ul>
<li>浏览器事件环中有专门存储微任务的队列</li>
<li>NodeJS事件环中没有专门存储微任务的队列</li>
</ul>
<h3 id="2-3微任务执行时机不同-废除"><a href="#2-3微任务执行时机不同-废除" class="headerlink" title="2.3微任务执行时机不同(废除)"></a>2.3微任务执行时机不同(废除)</h3><ul>
<li>浏览器事件环中每执行完一个宏任务都会去清空微任务队列</li>
<li>NodeJS事件环中只有同步代码执行完毕和其它队列之间切换的时候回去清空微任务队列(以前的版本)</li>
</ul>
<p><strong>现在</strong></p>
<p>Node的事件环跟浏览器的事件环基本一致,先执行同步代码,执行完以后就清空微任务队列,清空完以后按照事件环队列的优先级进行执行,每执行完一个宏任务就会去清空微任务队列</p>
<h3 id="2-4微任务优先级不同"><a href="#2-4微任务优先级不同" class="headerlink" title="2.4微任务优先级不同"></a>2.4微任务优先级不同</h3><ul>
<li>浏览器事件环中如果多个微任务同时满足执行条件, 采用先进先出</li>
<li>NodeJS事件环中如果多个微任务同时满足执行条件, 会按照优先级执行</li>
</ul>
<p>前面是不是说了常见的微任务有Promise, MutationObserver ,process.nextTick</p>
<p>但是MutationObserver不属与Node的宏任务,因为这个东西是监听DOM树的变化的,你Node有DOM树吗? 是不是没有,所以Node中常见的宏任务就只有Promise,process.nextTick</p>
<p>那这两个哪个的优先级要高喃?</p>
<p>写个代码来看看就清楚了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">index.js复制代码Promise.resolve().then(function () &#123;</span><br><span class="line">  console.log(&quot;Promise&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">  console.log(&quot;process.nextTick1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">  console.log(&quot;process.nextTick2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">  console.log(&quot;process.nextTick3&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看看结果如何</p>
<p><img src="/../../images/34d0dc5ae02f44b390ed313dcc026012tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>由图可知,是不是process.nextTick的优先级比promise的优先级高</p>
<p>process.nextTick代码执行完&gt;&gt;才会执行promise的代码</p>
<h2 id="3-完整流程"><a href="#3-完整流程" class="headerlink" title="3.完整流程"></a>3.完整流程</h2><p>先来看两个例子就基本了解Node代码执行的完整流程了</p>
<p><strong>第一个例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.resolve().then(function () &#123;</span><br><span class="line">  console.log(&quot;Promise&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;同步代码 Start&quot;);</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">  console.log(&quot;process.nextTick&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(function () &#123;</span><br><span class="line">  console.log(&quot;setImmediate&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;同步代码 End&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/53570edc873b491dba743c532ddbddb3tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>我还是简单来讲解一下</p>
<p>从上至下执行代码,首先遇到一个setTimeout,这个是不是一个异步代码,setTimeout属于timers队列,就把这个setTimeout放入timers队列</p>
<p>然后遇到一个Promise,这个是不是也是一个异步代码,Promise是不是微任务,我们就暂时假设一个队列来存放Node的(微任务),把promise放入假设的队列</p>
<p>然后遇到一个console.log,这个是不是一个同步代码,同步代码是不是立即执行,就输出同步代码Start</p>
<p>接着遇到一个process.nextTick,这个是不是也是一个异步代码,process.nextTick是不是微任务,把process.nextTick放入假设的队列</p>
<p>之后遇到一个setImmediate,这个是不是一个异步代码,setImmediate属于check队列,就把setImmediate放入check队列</p>
<p>最后遇到一个console.log,这个是不是一个同步代码,同步代码是不是立即执行,就输出同步代码End</p>
<p>上面是不是说了先执行同步代码,同步代码执行完毕以后就会立即执行满足条件的微任务</p>
<p>这里同步代码是不是都执行完了,然后执行微任务,微任务中有一个promise和nextTick,在浏览器中是不是按照先进先出的原则,但是Node是按照优先级的原则来执行</p>
<p>前面是不是说过,nextTick的优先级比promsie的优先级高,所以会先执行nextTick代码,是不是就输出了nextTick</p>
<p>然后执行promise代码,静跟着输出了promise</p>
<p>微任务执行完毕以后,是不是就会按照Node的事件环的队列顺序来执行,setTimeout是属于timers队列的, setImmediate是属于check队列的,timers队列优先级比check高,就会先执行timers的队列就打印出了setTimeout</p>
<p>上面是不是说过执行完一个Node事件环中的队列以后,就会去查看微任务是否有满足条件的代码,如果满足就立即执行,不满足就不执行,执行完timers队列以后,微任务是不是没有任务,然后就会跳转到check队列,然后执行check队列,最后打印出setImmediate</p>
<p>如何验证我的说法</p>
<p>是不是来看一下执行结果</p>
<p><img src="/../../images/59f817096033471cafff3599ca727968tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>是不是就没有任何问题</p>
<p>下面来看第二个例子</p>
<p><strong>第二个例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">index.js复制代码setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;s1&#x27;);</span><br><span class="line"> Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;p1&#x27;);</span><br><span class="line"> &#125;)</span><br><span class="line"> process.nextTick(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;n1&#x27;);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;start&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;s2&#x27;);</span><br><span class="line"> Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;p2&#x27;);</span><br><span class="line"> &#125;)</span><br><span class="line"> process.nextTick(() =&gt; &#123;</span><br><span class="line">   console.log(&#x27;n2&#x27;);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;end&#x27;);</span><br></pre></td></tr></table></figure>

<p>我还是简单的讲解一下</p>
<p>从上至下依次执行</p>
<p>遇到一个setTimeout,属于异步代码不立即执行,setTimeout属于timers队列,放入timers队列</p>
<p>遇到console.log,属于同步代码,立即执行,打印start</p>
<p>又遇到一个setTimeout,属于异步代码不立即执行,setTimeout属于timers队列,放入timers队列</p>
<p>同步代码执行完毕就回去执行微任务,现在微任务里面没有任务,就会按照事件环的优先级来执行 当前只有一个timers队列就看里面是否有满足的条件的代码,两个是不是都满足根据先进先出的原则,s1先进来就先执行,遇到console.log,属于同步代码,立即执行,打印s1,遇到一个promise,属于异步代码不立即执行,promise属于微任务,假象一个存放微任务的队列把promise存放进去,然后遇到一个nextTick,属于异步代码不立即执行,nextTick属于微任务存放进假象的任务队列,s1就执行完毕了</p>
<p>s1执行完以后,上面是不是说过,执行完一个队列就会去执行微任务,看微任务里面有没有满足的代码,是不是promise和nextTick都满足,根据优先级的原则,nextTick会先执行,所以静跟着打印n1,之后执行promise,静跟着打印p1</p>
<p>微任务执行完毕,进行执行timers队列,s1执行完了就只剩s2了,执行s2,遇到console.log,属于同步代码,立即执行,打印s2,遇到一个promise,属于异步代码不立即执行,promise属于微任务,假象一个存放微任务的队列把promise存放进去,然后遇到一个nextTick,属于异步代码不立即执行,nextTick属于微任务存放进假象的任务队列,s2就执行完毕了</p>
<p>s2执行完以后,上面是不是说过,执行完一个队列就会去执行微任务,看微任务里面有没有满足的代码,是不是promise和nextTick都满足,根据优先级的原则,nextTick会先执行,所以静跟着打印n2,之后执行promise,静跟着打印p2</p>
<p>怎么验证我的说法?</p>
<p>是不是看看输出结果</p>
<p><img src="/../../images/283df34e25994d4184b7f3aeeea250d0tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>是不是就没有任何问题</p>
<p><strong>是不是很简单</strong></p>
<h2 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4.面试题"></a>4.面试题</h2><p><strong>注意点</strong></p>
<p>当执行以下代码的时候,结果是随机的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index.js复制代码setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;setImmediate&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>来看看打印结果</p>
<p><img src="/../../images/5bd246ea03fc4517a92a8013d54670c2tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>为什么会这样?</p>
<p>因为在NodeJS中指定的延迟时间是有一定的误差的, 所以导致了输出结果随机的问题</p>
<p>我们这里没设置延迟时间是不是就表示延迟0s,因为延迟时间存在一定的误差,是不是可能延迟时间是0.1或者0.2,是不是延迟了就会立即执行下面的代码,这就是为什么存在随机性,有可能会产生误差,有可能不会产生</p>
<p>当然这不是面试题,只是了解一下</p>
<p>下面的才是面试题</p>
<p><strong>面试题</strong></p>
<p>下面这段代码输出的结果肯定是setImmediate先输出,setTimeout后输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">index.js复制代码const path = require(&quot;path&quot;);</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &quot;04.js&quot;), () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setImmediate&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>来看看打印结果</p>
<p><img src="/../../images/61e2239384a0476eab1615f35b4d7c5ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>那到底是为什么?</p>
<p>我来简单的分析一下</p>
<p>还是老样子从上之下执行代码,遇到一个readfile,这个是不是异步代码不立即执行,readfile属于poll队列</p>
<p>好了代码就执行完毕了,代码执行完毕就立即执行满足条件的微任务,当前没有微任务,就按照队列的优先级来执行,当前只有一个poll队列,这个readfile满足条件就可以执行,执行readfile,首先遇到一个setTimeout,这个是不是属于异步代码不立即执行,setTimeout属于timers队列,就放入timers队列,之后遇到一个setImmediate,这个是不是属于异步代码,属于check队列,就放入check队列里,这样poll队列是不是就执行完毕了,执行完一个宏任务,是不是就会去看微任务中有没有满足条件的可以进行执行,当前是不是没有微任务,之后就会切换到check队列,为什么**?因为前面说过Node事件环有顺序,poll队列的后面就是check队列,是不是应该执行完check队列才会回头执行timers队列,所以永远输出setImmediate在前面,setTimeout在后面**</p>
<p>有一定执行顺序</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[详解Object.create(null)]]></title>
      <url>/2023/08/05/es6/Object%20created/</url>
      <content type="html"><![CDATA[<h1 id="详解Object-create-null"><a href="#详解Object-create-null" class="headerlink" title="详解Object.create(null)"></a>详解Object.create(null)</h1><p>const me &#x3D; Object.create(person); &#x2F;&#x2F;   me.<em>proto</em> &#x3D;&#x3D;&#x3D; person</p>
<blockquote>
<p>在Vue和Vuex的源码中，作者都使用了<code>Object.create(null)</code>来初始化一个新对象。为什么不用更简洁的<code>&#123;&#125;</code>呢？</p>
<p>在<code>SegmentFault</code>和<code>Stack Overflow</code>等开发者社区中也有很多人展开了讨论，在这里总结成文，温故知新。</p>
</blockquote>
<h3 id="Object-create-的定义"><a href="#Object-create-的定义" class="headerlink" title="Object.create()的定义"></a>Object.create()的定义</h3><p>照搬一下MDN上的定义：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css</span><br><span class="line">复制代码<span class="selector-tag">Object</span><span class="selector-class">.create</span>(proto,<span class="selector-attr">[propertiesObject]</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>proto:新创建对象的原型对象</li>
<li>propertiesObject:可选。要添加到新对象的<strong>可枚举</strong>（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。</li>
</ul>
<p>举个例子(恶改了一下MDN的官方例子，看懂的点赞)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> car = &#123;</span><br><span class="line">  <span class="attr">isSportsCar</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi girl, this is a <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>. </span></span><br><span class="line"><span class="string">    Do you like to have a drink with me ? <span class="subst">$&#123;<span class="variable language_">this</span>.isSportsCar&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> porsche = <span class="title class_">Object</span>.<span class="title function_">create</span>(car,&#123;</span><br><span class="line">    <span class="comment">//color成为porsche的数据属性</span></span><br><span class="line">    <span class="comment">//颜色不喜欢，可以改色或贴膜，所以可修改</span></span><br><span class="line">    <span class="attr">color</span>:&#123;</span><br><span class="line">        <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//type成为porsche的访问器属性</span></span><br><span class="line">    <span class="attr">type</span>:&#123;</span><br><span class="line">        <span class="comment">// writable、configurable等属性，不显式设置则默认为false</span></span><br><span class="line">        <span class="comment">// 想把普通车改成敞篷，成本有点大了，所以就设成不可配置吧</span></span><br><span class="line">        <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">&#x27;convertible&#x27;</span>&#125;,</span><br><span class="line">        <span class="attr">set</span>:<span class="keyword">function</span>(<span class="params">value</span>)&#123;<span class="string">&quot;change this car to&quot;</span>,value&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">porsche.<span class="property">name</span> = <span class="string">&quot;Porsche 911&quot;</span>; <span class="comment">// &quot;name&quot;是&quot;porsche&quot;的属性, 而不是&quot;car&quot;的</span></span><br><span class="line">porsche.<span class="property">isSportsCar</span> = <span class="literal">true</span>; <span class="comment">// 继承的属性可以被覆写</span></span><br><span class="line"></span><br><span class="line">porsche.<span class="title function_">introduction</span>();</span><br><span class="line"><span class="comment">// expected output: &quot;Hi girl, this is a Porsche 911. Do you like to have a drink with me ? true&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>的定义其实很简单，弄清楚上面这个例子就可以了。</p>
<h3 id="Object-create-、-…-的区别"><a href="#Object-create-、-…-的区别" class="headerlink" title="Object.create()、{…}的区别"></a>Object.create()、{…}的区别</h3><p>先看看我们经常使用的<code>&#123;&#125;</code>创建的对象是什么样子的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码var <span class="attr">o</span> = &#123;a：<span class="number">1</span>&#125;<span class="comment">;</span></span><br><span class="line">console.log(o)</span><br></pre></td></tr></table></figure>

<p>在chrome控制台打印如下：</p>
<p><img src="/../../images/162b2eeff41e8f5dtplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>从上图可以看到，新创建的对象继承了<code>Object</code>自身的方法，如<code>hasOwnProperty</code>、<code>toString</code>等，在新对象上可以直接使用。</p>
<p>再看看使用<code>Object.create()</code>创建对象：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="keyword">var</span> o = Object.<span class="title function_ invoke__">create</span>(<span class="literal">null</span>,&#123;</span><br><span class="line">    <span class="attr">a</span>:&#123;</span><br><span class="line">           <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(o)</span><br></pre></td></tr></table></figure>

<p>在chrome控制台打印如下：</p>
<p><img src="/../../images/162b2ef2d7089a2ftplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>可以看到，新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用<code>o.toString()</code>会报<code>Uncaught TypeError</code>的错误。</p>
<p>大家可能会注意到，第一个参数使用了null。也就是说将null设置成了新创建对象的原型，自然就不会有原型链上的属性。我们再把上面的例子改一改：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="keyword">var</span> o = Object.<span class="title function_ invoke__">create</span>(&#123;&#125;,&#123;</span><br><span class="line">    <span class="attr">a</span>:&#123;</span><br><span class="line">           <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(o)</span><br></pre></td></tr></table></figure>

<p>将<code>null</code>改为<code>&#123;&#125;</code>，结果是怎样的？在chrome控制台打印如下：</p>
<p><img src="/../../images/162b2ef45967219dtplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>我们看到，这样创建的对象和使用<code>&#123;&#125;</code>创建对象已经很相近了，但是还是有一点区别：多了一层<code>proto</code>嵌套。</p>
<p>我们最后再来改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">var</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>,&#123;</span><br><span class="line">    <span class="attr">a</span>:&#123;</span><br><span class="line">           <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o)</span><br></pre></td></tr></table></figure>

<p>chrome控制台打印如下：</p>
<p><img src="/../../images/162b2ef5f507c834tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>这次就和使用<code>&#123;&#125;</code>创建的对象一模一样了。至此，我相信大家已经对两者的区别十分清楚了。</p>
<h3 id="Object-create-null-的使用场景"><a href="#Object-create-null-的使用场景" class="headerlink" title="Object.create(null)的使用场景"></a>Object.create(null)的使用场景</h3><p>再回到文章开头的问题，为什么很多源码作者会使用<code>Object.create(null)</code>来初始化一个新对象呢？这是作者的习惯，还是一个最佳实践？</p>
<p>其实都不是，这并不是作者不经思考随便用的，也不是javascript编程中的最佳实践，而是需要因地制宜，具体问题具体分析。</p>
<p>我们进一步比较一下<code>Object.create(null)</code>和<code>&#123;&#125;</code>创建控对象的区别：</p>
<p>在chrome打印如下：</p>
<p><img src="/../../images/162b2ef76658b2f1tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>从上图可以看到，使用<code>create</code>创建的对象，没有任何属性，显示<code>No properties</code>，我们可以把它当作一个非常<strong>纯净</strong>的map来使用，我们可以自己定义<code>hasOwnProperty</code>、<code>toString</code>方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">//Demo1:</span></span><br><span class="line"><span class="keyword">var</span> a= &#123;...省略很多属性和方法...&#125;;</span><br><span class="line"><span class="comment">//如果想要检查a是否存在一个名为toString的属性，你必须像下面这样进行检查：</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(a,<span class="string">&#x27;toString&#x27;</span>))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为什么不能直接用a.hasOwnProperty(&#x27;toString&#x27;)?因为你可能给a添加了一个自定义的hasOwnProperty</span></span><br><span class="line"><span class="comment">//你无法使用下面这种方式来进行判断,因为原型上的toString方法是存在的：</span></span><br><span class="line"><span class="keyword">if</span>(a.<span class="property">toString</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo2:</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">//你可以直接使用下面这种方式判断，因为存在的属性，都将定义在a上面，除非手动指定原型：</span></span><br><span class="line"><span class="keyword">if</span>(a.<span class="property">toString</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另一个使用<code>create(null)</code>的理由是，在我们使用<code>for..in</code>循环的时候会遍历对象原型链上的属性，使用<code>create(null)</code>就不必再对属性进行检查了，当然，我们也可以直接使用<code>Object.keys[]</code>。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>你需要一个非常干净且高度可定制的对象当作数据字典的时候；</li>
<li>想节省<code>hasOwnProperty</code>带来的一丢丢性能损失并且可以偷懒少些一点代码的时候</li>
</ol>
<p>用<code>Object.create(null)</code>吧！其他时候，请用<code>&#123;&#125;</code>。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[new的过程]]></title>
      <url>/2023/08/05/es6/new%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</p>
<ol>
<li>一个继承自 <code>Foo.prototype</code> 的新对象被创建。</li>
<li>使用指定的参数调用构造函数 <code>Foo</code> ，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()</code>，也就是没有指定参数列表，<code>Foo</code> 不带任何参数调用的情况。</li>
<li>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。</li>
</ol>
<p>说到这里就要聊聊 <code>new</code> 的实现了，实现代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 1、创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(),</span><br><span class="line">	<span class="comment">// 2、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class="line">    <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">	<span class="comment">// 3、链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">	<span class="comment">// 4、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">	<span class="comment">// 5、优先返回构造函数返回的对象</span></span><br><span class="line">	<span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[promise源码的解读和思考]]></title>
      <url>/2023/08/04/promise/</url>
      <content type="html"><![CDATA[<p><img src="/../images/image-20230804220750099.png" alt="image-20230804220750099"></p>
<p>第一个then 执行第二个回调 拒绝   该回调 函数没有报错 完成了promise return的值作为reslove（）   下一个then就执行成功的第一个回调函数    </p>
<p>  打印结果    promise 失败1   123</p>
<p>  ok  456</p>
<p>then的源码中提到一个对象数组一个对象（一个对象有传来的完成函数，失败函数，resolve，reject）就是接收一个then（比如调用多个then） 就有多个对象  一次从数组中取出一个判断该对象中的状态如果是pending 直接return 不执行  如果是完成就执行完成函数并把上一个resolve的结果传个这个函数当参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;  </span><br><span class="line">  // 显式地抛出错误  </span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;);  </span><br><span class="line">&#125;).catch(err =&gt; &#123;  </span><br><span class="line">  console.log(&quot;catch: &quot;, err);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;  </span><br><span class="line">  return new Error(&#x27;error!!!&#x27;); // 返回一个错误对象，而不是抛出它  </span><br><span class="line">&#125;).then(result =&gt; &#123;  </span><br><span class="line">  // result 将会是 Error 对象，而不是被 catch 捕获的错误  </span><br><span class="line">  console.log(result instanceof Error); // 输出: true  </span><br><span class="line">&#125;).catch(err =&gt; &#123;  </span><br><span class="line">  // 这个 catch 不会被触发，因为没有错误被抛出  </span><br><span class="line">  console.log(&quot;This catch won&#x27;t be triggered&quot;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>return 和 throw 一个错误的区别</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/08/04/vue/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：vue3利用vueuse-core插件懒加载"><a href="#title：vue3利用vueuse-core插件懒加载" class="headerlink" title="title：vue3利用vueuse core插件懒加载"></a>title：vue3利用vueuse core插件懒加载</h2><p>注册全局指令 <code>img-lazy</code> 的 Vue 指令在回调函数中，首先获取到 <code>isIntersecting</code> 的值，该值表示元素是否进入了视窗。如果 <code>isIntersecting</code> 为真，则表示元素进入了视窗，此时可以进行相应的操作，比如打印 <code>el</code>。然后使用 <code>stop</code> 函数来停止对元素的监听。</p>
<p>综合起来，这段代码的作用是实现了一个图片懒加载的指令。当被绑定的元素进入视窗时，会触发懒加载逻辑，并停止对元素的监听。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mport &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;img-lazy&#x27;</span>,&#123;</span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;stop&#125;= <span class="title function_">useIntersectionObserver</span>(el,</span><br><span class="line">    <span class="function">(<span class="params">[&#123; isIntersecting &#125;], observerElement</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(isIntersecting)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">     <span class="title function_">stop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    )</span><br><span class="line"> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[生成器yiled]]></title>
      <url>/2023/08/03/es6/%E7%94%9F%E6%88%90%E5%99%A8yield/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">inner</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer1</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">inner</span>()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer2</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello!&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs中的commonjs规范]]></title>
      <url>/2023/08/02/nodejs/commonjs%20%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>avaScript模块发展的概念基本如： “script”引入&#x3D;&gt; 作用域函数&#x3D;》自执行函数&#x3D;〉 Commonjs（AMD）。在nodejs中的模块主要采用commonjs规范，如下所示。</p>
<ul>
<li>每个文件就是一个模块， 有自己的作用域。</li>
<li>每个文件中定义的变量、函数、类都是私有的，对其它文件不可见</li>
<li>每个模块内部可以通过 <code>exports</code> 或者 <code>module.exports</code> 对外暴露接口</li>
<li>每个模块通过 <code>require</code> 加载另外的模块</li>
</ul>
<p>我们在nodejs中常用require exports module.exports都是基于Commonjs来的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[module.exports` 和 `export]]></title>
      <url>/2023/08/01/nodejs/%E4%B8%A4%E7%A7%8D%E5%AF%BC%E5%87%BA/</url>
      <content type="html"><![CDATA[<h3 id="module-exports-和-export"><a href="#module-exports-和-export" class="headerlink" title="module.exports 和 export"></a><code>module.exports</code> 和 <code>export</code></h3><p><code>module.exports</code> 和 <code>export</code> 是用于在 Node.js（CommonJS 模块系统）和 JavaScript（ES6 模块系统）中导出模块的关键字，它们有一些区别。</p>
<ol>
<li>语法差异：<ul>
<li><code>module.exports</code> 是 Node.js 的导出语法，使用赋值语句直接将要导出的内容赋值给 <code>module.exports</code>。</li>
<li><code>export</code> 是 ES6 的导出语法，使用 <code>export</code> 关键字来导出变量、函数、类或模块，可以有多个导出项。</li>
</ul>
</li>
<li>导出方式的不同：<ul>
<li><code>module.exports</code> 可以导出任何类型的值，包括对象、函数、类、字符串等。例如：<code>module.exports = &#123; key: value &#125;</code> 或 <code>module.exports = function() &#123; &#125;</code>。</li>
<li><code>export</code> 关键字只能导出模块中定义的变量、函数、类等。例如：<code>export const key = value;</code> 或 <code>export function functionName() &#123; &#125;</code>。</li>
</ul>
</li>
<li>导入方式的不同：<ul>
<li><code>module.exports</code> 导出的模块可以使用 <code>require()</code> 函数进行导入。例如：<code>const module = require(&#39;./module&#39;)</code>。</li>
<li><code>export</code> 导出的模块可以使用 <code>import</code> 关键字进行导入。例如：<code>import &#123; key &#125; from &#39;./module&#39;</code>。</li>
</ul>
</li>
</ol>
<p>需要注意的是，在单个模块中不能同时使用 <code>module.exports</code> 和 <code>export</code>，因为它们属于不同的模块系统。如果你在一个文件中使用了 <code>module.exports</code>，则应该使用 <code>require()</code> 来导入该模块；如果使用了 <code>export</code>，则应该使用 <code>import</code> 进行导入。</p>
<p>总结起来，<code>module.exports</code> 是用于 Node.js 的导出方式，而 <code>export</code> 是用于 ES6 模块系统的导出方式。它们的使用取决于你所使用的模块系统和环境。</p>
<h4 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h4><p>总结：</p>
<ul>
<li><code>export</code> 用于导出多个具名成员，并需要使用名称来引用。</li>
<li><code>export default</code> 用于导出默认成员，并可以自定义引用名称。</li>
</ul>
<p>在导入模块时，你可以根据导出方式选择适当的导入方式：使用 <code>&#123;&#125;</code> 解构语法导入具名成员，或使用一个自定义名称导入默认成员。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[防抖和节流]]></title>
      <url>/2023/07/31/%E9%9D%A2%E7%BB%8F/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      <content type="html"><![CDATA[<h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title=".防抖(debounce)"></a>.防抖(debounce)</h1><p><strong>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">tex复制代码开发使用场景- 搜索框防抖</span><br><span class="line">假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多</span><br><span class="line">我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，则需要再等300ms 后发送请求</span><br><span class="line">html复制代码&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        <span class="attr">width</span>: 200px;</span><br><span class="line">        <span class="attr">height</span>: 200px;</span><br><span class="line">        background-<span class="attr">color</span>: #<span class="variable constant_">CCCCCC</span>;</span><br><span class="line">        line-<span class="attr">height</span>: 200px;</span><br><span class="line">        text-<span class="attr">align</span>: center;</span><br><span class="line">        font-<span class="attr">size</span>: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = ++i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">//上一次的计时还在先清除 只执行最后一次</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            timer = <span class="built_in">setTimeout</span>(fun.<span class="title function_">bind</span>(div), time)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    div.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="title function_">debounce</span>(fun, <span class="number">1000</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">fangdou</span>(<span class="params">*fun*</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timeid</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">clearTimeout</span>(timeid)</span><br><span class="line"></span><br><span class="line">   timeid=<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//现在这个区域的this指向外层也就是 return回去的 它由button的onclick调用 所以它的this为button这个对象</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---&quot;</span>+*<span class="variable language_">this</span>*);</span><br><span class="line"><span class="comment">//此处fun（）的this因为直接调用为window 我们需要通过apply的方法将其this转化为目前区域的this（button）</span></span><br><span class="line">​    <span class="title function_">fun</span>()</span><br><span class="line">      <span class="comment">// fun.apply(this) </span></span><br><span class="line">   &#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> functon <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="variable language_">console</span>.<span class="title function_">log</span>(*<span class="variable language_">this</span>*);</span><br><span class="line"></span><br><span class="line">​     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1234</span>); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> button=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#one&#x27;</span>)</span><br><span class="line"></span><br><span class="line">button.<span class="property">onclick</span>=<span class="title function_">fangdou</span>(fun1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/image-20240305134132194.png" alt="image-20240305134132194"></p>
<h1 id="1-节流（throttle）"><a href="#1-节流（throttle）" class="headerlink" title="1.节流（throttle）"></a>1.节流（throttle）</h1><p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">tex复制代码开发使用场景 – 小米轮播图点击效果、鼠标移动、页面尺寸缩放resize、滚动条滚动 就可以加节流</span><br><span class="line">假如一张轮播图完成切换需要300ms， 不加节流效果，快速点击，则嗖嗖嗖的切换，加上节流效果，不管快速点击多少次，300ms时间内，只能切换一张图片。</span><br><span class="line">html复制代码&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        <span class="attr">width</span>: 200px;</span><br><span class="line">        <span class="attr">height</span>: 200px;</span><br><span class="line">        background-<span class="attr">color</span>: #<span class="variable constant_">CCCCCC</span>;</span><br><span class="line">        line-<span class="attr">height</span>: 200px;</span><br><span class="line">        text-<span class="attr">align</span>: center;</span><br><span class="line">        font-<span class="attr">size</span>: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = ++i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> startTime = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (nowTime - startTime &gt;= time) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                fun.<span class="title function_">bind</span>(div)();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                startTime = nowTime;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    div.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="title function_">throttle</span>(fun, <span class="number">1000</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代器的基本结构]]></title>
      <url>/2023/07/29/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>symbol.iterator方法 会返回一个函数 里面会有一个next方法   依次来实现可迭起</p>
<p><img src="/../images/image-20230729205324949.png" alt="image-20230729205324949"></p>
<p><img src="/../images/image-20230729205425625.png" alt="image-20230729205425625"></p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">recursiveGenerator</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">recursiveGenerator</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成器实现迭代</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/07/23/webpack/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：webpack使用"><a href="#title：webpack使用" class="headerlink" title="title：webpack使用"></a>title：webpack使用</h2><p>1</p>
<p>  npx webpack –mode&#x3D;development  .&#x2F;src&#x2F;main.js        若配置后进入口文件后 直接npx webpack</p>
<p><img src="/../images/image-20230723214124615.png" alt="image-20230723214124615"></p>
<p>2</p>
<p>在webpack中，内联loader是指将CSS样式直接嵌入到JavaScript文件中，而不是将其作为独立的CSS文件引入。这样做的好处是可以减少HTTP请求，提高页面加载速度。在配置中使用内联loader需要借助一些插件。</p>
<h3 id="生命周期简图"><a href="#生命周期简图" class="headerlink" title="生命周期简图"></a>生命周期简图</h3><p><img src="/../images/plugin.jpg" alt="Webpack 插件生命周期"></p>
<h2 id="1-什么是Webpack？它的主要功能是什么？"><a href="#1-什么是Webpack？它的主要功能是什么？" class="headerlink" title="1. 什么是Webpack？它的主要功能是什么？"></a>1. 什么是Webpack？它的主要功能是什么？</h2><p>Webpack是一个<strong>前端模块打包工具</strong>。它可以将多个模块按照依赖关系进行静态分析，并生成一个或多个打包后的文件。Webpack的主要功能包括：</p>
<h3 id="1-模块打包"><a href="#1-模块打包" class="headerlink" title="1. 模块打包"></a>1. 模块打包</h3><p>将项目中的所有模块（JavaScript、CSS、图片等）当作一个整体，通过依赖关系将它们打包成一个或多个静态资源文件。</p>
<h3 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2. 依赖管理"></a>2. 依赖管理</h3><p>Webpack可以分析模块之间的依赖关系，根据配置的入口文件找出所有依赖的模块，并将其整合到打包结果中。</p>
<h3 id="3-文件转换"><a href="#3-文件转换" class="headerlink" title="3. 文件转换"></a>3. 文件转换</h3><p><code>Webpack</code>本身只能处理<code>JavaScript</code>模块，但通过<code>加载器（Loader）</code>的使用，可以将其他类型的文件（如CSS、LESS、图片等）转换为有效的模块，使其能够被打包到最终的结果中。</p>
<h3 id="4-代码拆分"><a href="#4-代码拆分" class="headerlink" title="4. 代码拆分"></a>4. 代码拆分</h3><p>Webpack支持将代码拆分成多个模块，按需加载，实现按需加载和提升应用性能。</p>
<h3 id="5-插件系统"><a href="#5-插件系统" class="headerlink" title="5. 插件系统"></a>5. 插件系统</h3><p>Webpack提供了丰富的插件系统，可以通过插件实现各种功能的扩展，例如压缩代码、自动生成HTML文件等。</p>
<p>总之，Webpack的主要功能是<strong>将项目中的多个模块打包成一个或多个静态资源文件，并提供了丰富的功能和插件系统来满足前端开发的需求</strong>。</p>
<p><img src="/../images/D2B5CA33BD970F64A6301FA75AE2EB22.png" alt="alt"></p>
<h2 id="2-Webpack的核心概念是什么？请解释entry、output、loader和plugin。"><a href="#2-Webpack的核心概念是什么？请解释entry、output、loader和plugin。" class="headerlink" title="2. Webpack的核心概念是什么？请解释entry、output、loader和plugin。"></a>2. Webpack的核心概念是什么？请解释entry、output、loader和plugin。</h2><blockquote>
<p>Webpack的核心概念包括entry（入口）、output（输出）、loader（加载器）和plugin（插件）。</p>
</blockquote>
<ol>
<li><strong>Entry（入口）</strong>：Webpack将从指定的入口文件开始分析和构建依赖关系树。<strong>入口可以是单个文件或多个文件</strong>，Webpack会根据入口配置找出所有的依赖模块。</li>
<li><strong>Output（输出）</strong>：指定Webpack打包后的文件输出的路径和文件名。可以通过配置<code>output</code>选项来指定输出文件的路径、名称和格式等。</li>
<li><strong>Loader（加载器）</strong>：<code>Webpack</code>本身只能处理<code>JavaScript</code>模块，但通过<code>Loader</code>的使用，可以处理其他类型的文件（如CSS、LESS、图片等）。Loader的作用是在模块加载时对其进行转换和处理。</li>
<li><strong>Plugin（插件）</strong>：插件用于扩展Webpack的功能。它可以在打包的不同阶段执行特定的任务。例如，可以使用插件来压缩代码、拆分代码、生成HTML文件等。插件通过在Webpack配置中引入并实例化，然后将其添加到plugins数组中。</li>
</ol>
<p>综上所述，Webpack的核心概念包括<code>entry、output、loader和plugin</code>。</p>
<ul>
<li>entry指定Webpack的入口文件</li>
<li>output定义打包输出的文件及路径</li>
<li>loader用于处理不同类型的文件</li>
<li>plugin用于扩展Webpack的功能</li>
</ul>
<p>这些概念共同协作，实现了模块打包和构建的功能。</p>
<h2 id="3-什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。"><a href="#3-什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。" class="headerlink" title="3. 什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。"></a>3. 什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。</h2><p><strong>Webpack的loader是用于处理模块文件的转换工具</strong>。</p>
<blockquote>
<p>它们可以将不同类型的文件（如CSS、LESS、图片等）转换为可以被Webpack处理的有效模块，以便将其包含在最终的打包结果中。</p>
</blockquote>
<p>以下是一些常用的Webpack loader及其作用：</p>
<ol>
<li><code>babel-loader</code>：将ES6+代码转换为ES5语法，以便在旧版本的浏览器中运行。</li>
<li><code>style-loader</code> 和 <code>css-loader</code>：用于处理CSS文件。css-loader主要负责处理样式文件中的<code>import</code>和<code>url</code>语句，而style-loader将转换后的CSS模块直接注入到HTML页面中。</li>
<li><code>file-loader</code> 和 <code>url-loader</code>：用于处理图片和其他资源文件。file-loader会为每一个文件生成一个对应的文件，而url-loader将小于设定大小的文件转换为base64编码的URL，减少HTTP请求。</li>
<li><code>sass-loader</code> 和 <code>less-loader</code>：用于处理Sass和Less预处理器。它们将Sass和Less代码转换为普通的CSS代码。</li>
<li><code>postcss-loader</code>：用于为CSS代码添加浏览器兼容性前缀，以确保在不同浏览器上的一致性。</li>
<li><code>html-loader</code>：用于处理HTML文件，将其中的图片等资源转换为Webpack可以识别的模块。</li>
</ol>
<p>这只是一些常用的Webpack loader，实际上还有很多其他的loader可以根据具体的需求进行选择和配置。使用适当的loader可以提高开发效率并优化最终打包结果。</p>
<h2 id="4-什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。"><a href="#4-什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。" class="headerlink" title="4. 什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。"></a>4. 什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。</h2><p>在Webpack中，插件（plugin）是<strong>用来扩展和定制构建过程的工具</strong>，可以用于处理和优化资源、自动化任务、注入变量等。</p>
<blockquote>
<p>插件一般是一个具有apply方法的JavaScript对象，通过在Webpack的配置中配置插件，可以在构建过程中执行额外的操作。</p>
</blockquote>
<p>以下是一些常用的Webpack插件及其作用：</p>
<ol>
<li><code>HtmlWebpackPlugin</code>：用于自动生成HTML文件，并将打包生成的所有资源（如CSS、JS文件）自动注入到生成的HTML文件中。</li>
<li><code>MiniCssExtractPlugin</code>：用于将CSS代码从打包生成的JS文件中提取出来，创建一个单独的CSS文件，可以实现CSS的异步加载和浏览器缓存优化。</li>
<li><code>TerserWebpackPlugin</code>：用于对JS代码进行压缩和混淆，减小文件体积，提高加载速度。</li>
<li><code>OptimizeCSSAssetsWebpackPlugin</code>：用于对提取出的CSS进行压缩和优化。</li>
<li><code>CleanWebpackPlugin</code>：用于在构建之前清空输出目录，避免旧文件的干扰。</li>
<li><code>CopyWebpackPlugin</code>：用于将静态文件从源目录复制到输出目录，例如将图片、字体等文件复制到打包后的文件夹中。</li>
<li><code>DefinePlugin</code>：用于定义全局变量，可以在代码中直接使用这些变量，例如配置环境变量、区分开发环境和生产环境等。</li>
<li><code>HotModuleReplacementPlugin</code>：用于启用模块热更新，实现在开发过程中无需刷新页面即可看到最新变更的效果。</li>
<li><code>CompressionWebpackPlugin</code>：用于对打包生成的文件进行gzip压缩，减小文件体积，提升网络传输速度。</li>
<li><code>ProvidePlugin</code>：用于自动加载模块，当代码中使用到某个模块时，会自动将模块引入，无需手动import。</li>
</ol>
<p>这只是一小部分常用的Webpack插件，实际上还有很多其他的插件可以根据需要进行使用和定制。使用合适的插件可以大大提高Webpack的功能和效率，以及优化构建过程和最终生成的资源文件。</p>
<h2 id="5-在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）？它们有什么区别？"><a href="#5-在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）？它们有什么区别？" class="headerlink" title="5. 在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）？它们有什么区别？"></a>5. 在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）？它们有什么区别？</h2><p><strong>代码分离（code splitting）和懒加载（lazy loading）是Webpack中用于优化资源加载的两种技术。</strong></p>
<blockquote>
<p>代码分离是将打包生成的代码文件拆分成多个较小的文件，而不是将所有代码打包到一个文件中。</p>
</blockquote>
<p>这样做的好处是可以<strong>提高初始加载速度，并减小每个页面的加载所需的数据量</strong>。通过代码分离，只需在需要时加载特定模块，提高了页面的响应速度和用户体验。</p>
<p><strong>懒加载是指在需要时才加载某个模块，而不是在初始加载时就将所有代码一次性加载完毕</strong>。通过懒加载，可以将页面分成多个模块，并根据需要动态地加载模块。这可以减少初始加载时间，只加载目前需要的模块，在用户与页面进行交互时再根据需要进行加载，提高了页面的性能和加载速度。</p>
<blockquote>
<p>两者的区别在于：</p>
</blockquote>
<ul>
<li><strong>代码分离是将代码文件拆分成较小的文件，其中每个文件可能包含多个模块</strong>。这样做可以在初始加载时减少数据量，但仍然需要一次性加载所需的文件。</li>
<li><strong>懒加载是将页面分成多个模块，在需要时才去加载相应的模块</strong>。这样做可以进一步减小初始加载时间，只加载当前可见的模块，随着用户与页面交互，再按需加载其他模块。</li>
</ul>
<p><strong>在Webpack中，可以通过配置和使用动态导入（Dynamic Imports）来实现代码分离和懒加载</strong>。这样可以根据需要将模块进行分割，并在需要时动态加载模块。通过代码分离和懒加载，可以提高页面的性能和加载速度，避免一次性加载过多的资源文件，从而提升用户体验。</p>
<h2 id="6-如何配置Webpack的开发环境和生产环境的不同配置？"><a href="#6-如何配置Webpack的开发环境和生产环境的不同配置？" class="headerlink" title="6. 如何配置Webpack的开发环境和生产环境的不同配置？"></a>6. 如何配置Webpack的开发环境和生产环境的不同配置？</h2><p><strong>在Webpack中，可以通过配置不同的Webpack配置文件或统一的配置文件来区分开发环境和生产环境的配置。</strong></p>
<p>一种常见的做法是<strong>创建两个独立的Webpack配置文件，分别针对开发环境和生产环境进行配置</strong>。一般来说，开发环境的配置更侧重于开发体验和调试工具，而生产环境的配置则更关注代码优化、压缩和资源的优化。</p>
<blockquote>
<p>例如，可以创建以下两个Webpack配置文件：</p>
</blockquote>
<h3 id="1-webpack-config-dev-js（开发环境配置文件）"><a href="#1-webpack-config-dev-js（开发环境配置文件）" class="headerlink" title="1. webpack.config.dev.js（开发环境配置文件）"></a>1. <code>webpack.config.dev.js</code>（开发环境配置文件）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-webpack-config-prod-js（生产环境配置文件）"><a href="#2-webpack-config-prod-js（生产环境配置文件）" class="headerlink" title="2. webpack.config.prod.js（生产环境配置文件）"></a>2. <code>webpack.config.prod.js</code>（生产环境配置文件）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>()],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeRedundantAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">useShortDoctype</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;styles.css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此示例中，开发环境的配置文件仅包含了开发服务器（<code>devServer</code>）和热模块替换（<code>hot module replacement</code>）的配置，而生产环境的配置文件则包含了代码压缩（<code>TerserWebpackPlugin</code>）和CSS提取（<code>MiniCssExtractPlugin</code>）等插件的配置。</p>
<p>另一种做法是使用同一个配置文件，并在其中根据环境变量来判断不同的配置。可以使用<code>webpack-merge</code>工具来合并共享的配置和环境特定的配置。以下是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.common&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> envConfig = <span class="built_in">require</span>(<span class="string">`./webpack.config.<span class="subst">$&#123;env&#125;</span>.js`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">webpackMerge</span>(commonConfig, envConfig);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>webpack.config.common.js</code>是共享的基本配置文件，而<code>webpack.config.dev.js</code>和<code>webpack.config.prod.js</code>分别是开发环境和生产环境的特定配置文件。根据传入的环境变量，可以决定加载哪个环境的配置文件。</p>
<p>在命令行中使用Webpack时，可以通过设置环境变量来指定所需的配置文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.config.js --env production</span><br></pre></td></tr></table></figure>

<p>以上是一些常见的配置不同环境的方法，你可以根据自己的需求选择适合的方式来配置Webpack的开发环境和生产环境。</p>
<h2 id="7-Webpack中的热重载（Hot-Module-Replacement）是什么？如何配置实现热更新？"><a href="#7-Webpack中的热重载（Hot-Module-Replacement）是什么？如何配置实现热更新？" class="headerlink" title="7. Webpack中的热重载（Hot Module Replacement）是什么？如何配置实现热更新？"></a>7. Webpack中的热重载（Hot Module Replacement）是什么？如何配置实现热更新？</h2><p><strong>热重载（Hot Module Replacement，HMR）是Webpack提供的一项功能，它允许在开发过程中，无需刷新整个页面，即可实时更新修改的模块。</strong></p>
<blockquote>
<p>通过热重载，可以提高开发效率，快速查看代码变化的结果，并保持应用的状态（如表单数据）。</p>
</blockquote>
<p>要配置实现热更新，需要进行以下步骤：</p>
<p><strong>1. 在Webpack配置文件中启用热模块替换。可通过配置<code>devServer.hot</code>选项为<code>true</code>来启用HMR：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 在入口文件中添加对HMR的支持。在入口文件中，需要添加HMR的逻辑以监听模块的变化，并告诉Webpack如何处理更新。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 配置Webpack插件。HMR需要搭配相应的插件使用，常用的是<code>webpack.HotModuleReplacementPlugin</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line">    <span class="comment">// ...其他插件</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成上述配置后，运行Webpack开发服务器时，<code>Webpack</code>会在文件发生变化时将更新的模块代码发送给浏览器，浏览器会在不刷新整个页面的情况下，替换掉相应的模块。</p>
<p>请注意，<strong>热重载只适用于开发环境，并不能直接用于生产环境</strong>。在生产环境中，需要使用Webpack生成的静态文件进行部署。</p>
<p>热重载可以提高开发效率，但在某些情况下可能会遇到一些问题，如状态丢失、事件绑定问题等。因此，对于某些情况下，可能需要手动刷新页面来确保正确的状态。</p>
<h2 id="8-解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。"><a href="#8-解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。" class="headerlink" title="8. 解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。"></a>8. 解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。</h2><p><strong>Webpack的文件指纹（file fingerprint）机制是指在打包生成静态资源时，为每个文件生成唯一的标识码</strong>。这个标识码通常是通过对文件内容进行 <code>hash</code> 计算得到的。一旦文件内容发生改变，其文件指纹也会发生改变，从而防止浏览器在缓存过期前使用旧的文件。</p>
<blockquote>
<p>文件指纹有以下几种常见的类型：</p>
</blockquote>
<ul>
<li><code>Hash</code>：每次打包时，Webpack 会给每个输出的文件生成一个 hash 值。只要文件内容发生变化，其 hash 值也会发生变化。</li>
<li><code>Chunkhash</code>：根据不同的入口文件进行依赖关系解析后，Webpack 会为每个 chunk 生成一个 hash 值。只有当前 chunk 内容发生变化时，其 hash 值才会发生变化。</li>
<li><code>Contenthash</code>：采用文件内容的 hash 值作为文件指纹，只有文件内容发生变化时，其 hash 值才会发生变化。适用于样式文件、图片文件等。</li>
</ul>
<p><strong>缓存机制是指浏览器在加载页面时，会将静态资源（如 JS、CSS、图片等）保存在本地，以便下次加载相同资源时可以直接使用缓存副本，从而提高网页加载速度。缓存机制分为强缓存和协商缓存两种方式。</strong></p>
<ul>
<li><strong>强缓存</strong>：通过设置 <code>Response Header</code> 中的 <code>Cache-Control</code> 或 <code>Expires</code> 字段，告诉浏览器静态资源的有效期。在有效期内，浏览器会直接从缓存获取资源，无需向服务器发起请求。</li>
<li><strong>协商缓存</strong>：通过设置 <code>Response Header</code> 中的 <code>Last-Modified</code> 和 <code>ETag</code> 字段，告诉浏览器静态资源的版本信息。在请求资源时，如果浏览器的缓存仍然有效，则会发送一个请求到服务器，服务器会根据请求中的 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 字段进行验证，返回 <code>304</code> 状态码，并告诉浏览器可以使用缓存，从而减少数据传输。</li>
</ul>
<h2 id="9-如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？"><a href="#9-如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？" class="headerlink" title="9. 如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？"></a>9. 如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？</h2><p><strong>Webpack提供了各种加载器（Loader）来处理不同类型的资源文件。下面是处理图片、CSS和字体文件的示例：</strong></p>
<h3 id="1-图片文件"><a href="#1-图片文件" class="headerlink" title="1. 图片文件"></a>1. 图片文件</h3><ul>
<li>安装 file-loader 或 url-loader：<code>npm install file-loader</code> 或 <code>npm install url-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>, <span class="comment">// 文件指纹配置</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;images/&#x27;</span>, <span class="comment">// 输出目录</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .png、.jpg 或 .gif 结尾的图片文件，并将它们输出到指定的目录中。</p>
<h3 id="2-CSS-文件"><a href="#2-CSS-文件" class="headerlink" title="2. CSS 文件"></a>2. CSS 文件</h3><ul>
<li>安装 style-loader 和 css-loader：<code>npm install style-loader css-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .css 结尾的 CSS 文件，并使用 style-loader 和 css-loader 进行加载和处理。</p>
<h3 id="3-字体文件"><a href="#3-字体文件" class="headerlink" title="3. 字体文件"></a>3. 字体文件</h3><ul>
<li>安装 file-loader 或 url-loader：<code>npm install file-loader</code> 或 <code>npm install url-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>, <span class="comment">// 文件指纹配置</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;fonts/&#x27;</span> <span class="comment">// 输出目录</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .woff、.woff2、.eot、.ttf 或 .otf 结尾的字体文件，并将它们输出到指定的目录中。</p>
<p>注意，在配置加载器时，你可以根据自己的需求自定义加载器的选项。这些加载器可以在Webpack配置中的 module.rules 中进行定义。</p>
<h2 id="10-Webpack的Tree-Shaking是什么？如何配置实现代码的无用代码剔除？"><a href="#10-Webpack的Tree-Shaking是什么？如何配置实现代码的无用代码剔除？" class="headerlink" title="10. Webpack的Tree Shaking是什么？如何配置实现代码的无用代码剔除？"></a>10. Webpack的Tree Shaking是什么？如何配置实现代码的无用代码剔除？</h2><p><strong>Webpack的Tree Shaking是一个用于删除代码中未被引用的未使用代码的优化技术。</strong></p>
<blockquote>
<p>它可以显著减小打包后的文件体积，提高网页加载速度。</p>
</blockquote>
<p>要配置Webpack实现代码的无用代码剔除，需要进行以下几个步骤：</p>
<ol>
<li>确保你的代码是使用ES6模块语法编写的，而不是CommonJS（require）语法。因为Tree Shaking只对ES6模块有效。</li>
<li>在Webpack配置文件中，通过设置<code>mode</code>为<code>production</code>，启用Webpack的生产模式，此时Tree Shaking功能会默认开启。</li>
<li>确保你的<code>package.json</code>文件中的<code>sideEffects</code>字段被正确配置。<code>sideEffects</code>字段告诉Webpack哪些文件是没有副作用的，可以进行Tree Shaking。如果你的应用是纯粹的JavaScript应用，可以将<code>sideEffects</code>设置为<code>&quot;sideEffects&quot;: false</code>。如果你的应用使用了一些有副作用的模块（例如CSS文件），你需要将这些模块添加到<code>sideEffects</code>字段中。这样Webpack就不会将这些有副作用的模块进行Tree Shaking。</li>
</ol>
<p>需要注意的是，<strong>Tree Shaking只适用于ES6模块语法，并且只能剔除未引用的代码，不能剔除被动态引用的代码</strong>（例如通过字符串拼接生成模块路径）。另外，一些特定的代码结构可能会导致Tree Shaking失效，例如使用<code>eval</code>、<code>with</code>等特殊语法。</p>
<p>配置完成后，运行Webpack打包构建，未被引用的代码将会被删除，从而减小文件体积。</p>
<h2 id="11-如何优化Webpack的构建速度？提供一些常见的优化策略。"><a href="#11-如何优化Webpack的构建速度？提供一些常见的优化策略。" class="headerlink" title="11. 如何优化Webpack的构建速度？提供一些常见的优化策略。"></a>11. 如何优化Webpack的构建速度？提供一些常见的优化策略。</h2><blockquote>
<p>优化Webpack的构建速度是一个常见的需求，下面是一些常见的优化策略：</p>
</blockquote>
<ol>
<li><strong>通过配置缓存</strong>：可以使用<code>cache-loader</code>或者<code>hard-source-webpack-plugin</code>来启用缓存，避免重复编译没有改动的文件。</li>
<li><strong>通过配置多线程&#x2F;并行构建</strong>：可以使用<code>thread-loader</code>或者<code>happypack</code>来在多个工作线程中并行处理任务，加快构建速度。</li>
<li><strong>减少文件的解析和处理</strong>：可以通过配置<code>resolve.extensions</code>来减少Webpack的文件解析，只处理特定格式的文件。另外，使用<code>include</code>和<code>exclude</code>选项来限制需要处理的文件范围。</li>
<li><strong>优化Loader的配置</strong>：可以使用<code>exclude</code>选项来排除不必要的目录，只对需要处理的目录使用对应的Loader。另外，可以使用<code>resolve.alias</code>来配置别名，减少模块查找时间。</li>
<li><strong>使用Tree Shaking</strong>：通过配置<code>mode</code>为<code>production</code>，并且在<code>package.json</code>中将<code>sideEffects</code>设置为<code>false</code>或者具体的文件列表，开启Tree Shaking功能，剔除掉未使用的代码。</li>
<li><strong>合理使用Webpack的插件</strong>：根据具体需求，合理选择和配置Webpack的插件，避免不必要的处理和压缩。</li>
<li><strong>使用DllPlugin和缓存</strong>：可以将一些不经常变动的库使用<code>DllPlugin</code>预先编译，并将结果文件缓存起来，这样可以避免每次构建都重新编译这些库。</li>
</ol>
<p>以上是一些常见的Webpack构建速度优化策略，根据具体的项目需求和情况选择合适的优化方式。</p>
<h2 id="12-Webpack的Resolve模块解析是什么？请解释resolve-modules、resolve-alias和resolve-extensions的作用。"><a href="#12-Webpack的Resolve模块解析是什么？请解释resolve-modules、resolve-alias和resolve-extensions的作用。" class="headerlink" title="12. Webpack的Resolve模块解析是什么？请解释resolve.modules、resolve.alias和resolve.extensions的作用。"></a>12. Webpack的Resolve模块解析是什么？请解释resolve.modules、resolve.alias和resolve.extensions的作用。</h2><p><strong>Webpack的Resolve模块解析是用于解析模块路径的配置选项。它可以帮助Webpack正确地确定模块的位置。</strong></p>
<ul>
<li><code>resolve.modules</code>用于指定模块的搜索路径。当Webpack在解析导入语句时，它会按照指定的顺序依次查找这些路径来确定模块的位置。默认情况下，Webpack会在当前工作目录和node_modules文件夹中查找。</li>
<li><code>resolve.alias</code>用于创建模块的路径别名。通过配置别名，可以让Webpack在导入模块时使用更简短的路径。这对于减少代码中的冗余路径非常有用。</li>
<li><code>resolve.extensions</code>用于指定可以省略的文件扩展名。当导入模块时没有指定文件扩展名时，Webpack会按照指定的顺序依次尝试添加扩展名来解析模块。这样可以让我们在导入模块时省略掉繁琐的扩展名，提高开发效率。</li>
</ul>
<p>通过合理配置这些选项，我们可以让Webpack更快地找到模块的位置，并且在导入模块时更加方便简洁。</p>
<h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>optimization它允许开发者来自定义和优化打包策略</p>
<p><strong>splitChunks</strong>: 这是代码分割的核心配置。通过它，你可以配置 Webpack 如何分割代码到不同的 chunk 中。<code>splitChunks</code> 提供了多个选项来定制代码分割的行为，比如 <code>chunks</code>（哪些 chunk 中的模块应该被考虑分割）、<code>minSize</code>（分割的最小大小）、<code>maxSize</code>（分割的最大大小）、<code>cacheGroups</code>（定义如何分组和命名分割后的 chunk）等。</p>
<p>当 <code>chunks</code> 配置为 <code>&#39;all&#39;</code> 时，它表示所有的 chunks（包括初始加载的 chunks 和异步加载的 chunks）中的模块都会被考虑进行代码分割。这意味着 Webpack 会尝试找出所有 chunks 中共用的模块，并将它们提取到单独的 chunk 中，以优化最终打包的结果。</p>
<h3 id="代码分割的好处不仅仅是减小包的体积-它还可以帮助我们"><a href="#代码分割的好处不仅仅是减小包的体积-它还可以帮助我们" class="headerlink" title="代码分割的好处不仅仅是减小包的体积,它还可以帮助我们:"></a>代码分割的好处不仅仅是减小包的体积,它还可以帮助我们:</h3><ol>
<li><p>按需加载代码,避免加载用户不需要的代码。</p>
</li>
<li><p>并行加载代码,提高加载速度。</p>
</li>
<li><p>更好地利用浏览器缓存。</p>
</li>
<li><p>更灵活地组织代码,提高代码的可维护性。</p>
<h4 id="3-1-如何实现代码分割"><a href="#3-1-如何实现代码分割" class="headerlink" title="3.1 如何实现代码分割"></a>3.1 如何实现代码分割</h4><p>在Webpack中,有两种主要的代码分割方式:</p>
<ol>
<li>入口点分割:通过配置多个入口点,Webpack会为每个入口点生成一个独立的包。</li>
<li>动态导入:通过使用动态导入语句(如<code>import()</code>)，Webpack会将动态导入的模块分割到一个独立的包中。</li>
</ol>
<p>除此之外,Webpack还提供了更高级的代码分割功能,如使用SplitChunksPlugin进行公共代码提取。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &#x27;all&#x27;,</span><br><span class="line">      minSize: 20000,</span><br><span class="line">      maxSize: 0,</span><br><span class="line">      minChunks: 1,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          priority: -10,</span><br><span class="line">        &#125;,</span><br><span class="line">        default: &#123;</span><br><span class="line">          minChunks: 2,</span><br><span class="line">          priority: -20,</span><br><span class="line">          reuseExistingChunk: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们详细解释几个比较重要的配置项:</p>
<ul>
<li><p><code>chunks</code>:表示哪些代码需要优化。这里设置为<code>all</code>,表示同步和异步代码都要优化。</p>
</li>
<li><p><code>minSize</code>:表示拆分前的最小模块大小。这里设置为20000字节(约20KB),避免生成过多的小文件。</p>
</li>
<li><pre><code>cacheGroups
</code></pre>
<p>:定义了拆分的缓存组。</p>
<ul>
<li><code>vendors</code>:用于拆分<code>node_modules</code>目录下的模块。</li>
<li><code>default</code>:默认的缓存组,用于拆分被多次引用的模块。</li>
</ul>
</li>
</ul>
<h4 id="hard-source-webpack-plugin"><a href="#hard-source-webpack-plugin" class="headerlink" title="hard-source-webpack-plugin"></a>hard-source-webpack-plugin</h4><p><code>hard-source-webpack-plugin</code> 是一个 Webpack 插件，它的主要作用是通过缓存已经构建过的模块，来加速后续的构建过程。在大型项目中，特别是那些有很多依赖和复杂配置的 Vue 项目中，构建时间可能会变得非常长。使用 <code>hard-source-webpack-plugin</code> 可以显著减少构建时间，提高开发效率。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/07/23/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：webpack使用"><a href="#title：webpack使用" class="headerlink" title="title：webpack使用"></a>title：webpack使用</h2><p>1</p>
<p>  npx webpack –mode&#x3D;development  .&#x2F;src&#x2F;main.js        若配置后进入口文件后 直接npx webpack</p>
<p><img src="/Yuanmingjian/../images/image-20230723214124615.png" alt="image-20230723214124615"></p>
<p>2</p>
<p>在webpack中，内联loader是指将CSS样式直接嵌入到JavaScript文件中，而不是将其作为独立的CSS文件引入。这样做的好处是可以减少HTTP请求，提高页面加载速度。在配置中使用内联loader需要借助一些插件。</p>
<h3 id="生命周期简图"><a href="#生命周期简图" class="headerlink" title="生命周期简图"></a>生命周期简图</h3><p><img src="/Yuanmingjian/../images/plugin.jpg" alt="Webpack 插件生命周期"></p>
<h2 id="1-什么是Webpack？它的主要功能是什么？"><a href="#1-什么是Webpack？它的主要功能是什么？" class="headerlink" title="1. 什么是Webpack？它的主要功能是什么？"></a>1. 什么是Webpack？它的主要功能是什么？</h2><p>Webpack是一个<strong>前端模块打包工具</strong>。它可以将多个模块按照依赖关系进行静态分析，并生成一个或多个打包后的文件。Webpack的主要功能包括：</p>
<h3 id="1-模块打包"><a href="#1-模块打包" class="headerlink" title="1. 模块打包"></a>1. 模块打包</h3><p>将项目中的所有模块（JavaScript、CSS、图片等）当作一个整体，通过依赖关系将它们打包成一个或多个静态资源文件。</p>
<h3 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2. 依赖管理"></a>2. 依赖管理</h3><p>Webpack可以分析模块之间的依赖关系，根据配置的入口文件找出所有依赖的模块，并将其整合到打包结果中。</p>
<h3 id="3-文件转换"><a href="#3-文件转换" class="headerlink" title="3. 文件转换"></a>3. 文件转换</h3><p><code>Webpack</code>本身只能处理<code>JavaScript</code>模块，但通过<code>加载器（Loader）</code>的使用，可以将其他类型的文件（如CSS、LESS、图片等）转换为有效的模块，使其能够被打包到最终的结果中。</p>
<h3 id="4-代码拆分"><a href="#4-代码拆分" class="headerlink" title="4. 代码拆分"></a>4. 代码拆分</h3><p>Webpack支持将代码拆分成多个模块，按需加载，实现按需加载和提升应用性能。</p>
<h3 id="5-插件系统"><a href="#5-插件系统" class="headerlink" title="5. 插件系统"></a>5. 插件系统</h3><p>Webpack提供了丰富的插件系统，可以通过插件实现各种功能的扩展，例如压缩代码、自动生成HTML文件等。</p>
<p>总之，Webpack的主要功能是<strong>将项目中的多个模块打包成一个或多个静态资源文件，并提供了丰富的功能和插件系统来满足前端开发的需求</strong>。</p>
<p><img src="/Yuanmingjian/../images/D2B5CA33BD970F64A6301FA75AE2EB22.png" alt="alt"></p>
<h2 id="2-Webpack的核心概念是什么？请解释entry、output、loader和plugin。"><a href="#2-Webpack的核心概念是什么？请解释entry、output、loader和plugin。" class="headerlink" title="2. Webpack的核心概念是什么？请解释entry、output、loader和plugin。"></a>2. Webpack的核心概念是什么？请解释entry、output、loader和plugin。</h2><blockquote>
<p>Webpack的核心概念包括entry（入口）、output（输出）、loader（加载器）和plugin（插件）。</p>
</blockquote>
<ol>
<li><strong>Entry（入口）</strong>：Webpack将从指定的入口文件开始分析和构建依赖关系树。<strong>入口可以是单个文件或多个文件</strong>，Webpack会根据入口配置找出所有的依赖模块。</li>
<li><strong>Output（输出）</strong>：指定Webpack打包后的文件输出的路径和文件名。可以通过配置<code>output</code>选项来指定输出文件的路径、名称和格式等。</li>
<li><strong>Loader（加载器）</strong>：<code>Webpack</code>本身只能处理<code>JavaScript</code>模块，但通过<code>Loader</code>的使用，可以处理其他类型的文件（如CSS、LESS、图片等）。Loader的作用是在模块加载时对其进行转换和处理。</li>
<li><strong>Plugin（插件）</strong>：插件用于扩展Webpack的功能。它可以在打包的不同阶段执行特定的任务。例如，可以使用插件来压缩代码、拆分代码、生成HTML文件等。插件通过在Webpack配置中引入并实例化，然后将其添加到plugins数组中。</li>
</ol>
<p>综上所述，Webpack的核心概念包括<code>entry、output、loader和plugin</code>。</p>
<ul>
<li>entry指定Webpack的入口文件</li>
<li>output定义打包输出的文件及路径</li>
<li>loader用于处理不同类型的文件</li>
<li>plugin用于扩展Webpack的功能</li>
</ul>
<p>这些概念共同协作，实现了模块打包和构建的功能。</p>
<h2 id="3-什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。"><a href="#3-什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。" class="headerlink" title="3. 什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。"></a>3. 什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。</h2><p><strong>Webpack的loader是用于处理模块文件的转换工具</strong>。</p>
<blockquote>
<p>它们可以将不同类型的文件（如CSS、LESS、图片等）转换为可以被Webpack处理的有效模块，以便将其包含在最终的打包结果中。</p>
</blockquote>
<p>以下是一些常用的Webpack loader及其作用：</p>
<ol>
<li><code>babel-loader</code>：将ES6+代码转换为ES5语法，以便在旧版本的浏览器中运行。</li>
<li><code>style-loader</code> 和 <code>css-loader</code>：用于处理CSS文件。css-loader主要负责处理样式文件中的<code>import</code>和<code>url</code>语句，而style-loader将转换后的CSS模块直接注入到HTML页面中。</li>
<li><code>file-loader</code> 和 <code>url-loader</code>：用于处理图片和其他资源文件。file-loader会为每一个文件生成一个对应的文件，而url-loader将小于设定大小的文件转换为base64编码的URL，减少HTTP请求。</li>
<li><code>sass-loader</code> 和 <code>less-loader</code>：用于处理Sass和Less预处理器。它们将Sass和Less代码转换为普通的CSS代码。</li>
<li><code>postcss-loader</code>：用于为CSS代码添加浏览器兼容性前缀，以确保在不同浏览器上的一致性。</li>
<li><code>html-loader</code>：用于处理HTML文件，将其中的图片等资源转换为Webpack可以识别的模块。</li>
</ol>
<p>这只是一些常用的Webpack loader，实际上还有很多其他的loader可以根据具体的需求进行选择和配置。使用适当的loader可以提高开发效率并优化最终打包结果。</p>
<h2 id="4-什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。"><a href="#4-什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。" class="headerlink" title="4. 什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。"></a>4. 什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。</h2><p>在Webpack中，插件（plugin）是<strong>用来扩展和定制构建过程的工具</strong>，可以用于处理和优化资源、自动化任务、注入变量等。</p>
<blockquote>
<p>插件一般是一个具有apply方法的JavaScript对象，通过在Webpack的配置中配置插件，可以在构建过程中执行额外的操作。</p>
</blockquote>
<p>以下是一些常用的Webpack插件及其作用：</p>
<ol>
<li><code>HtmlWebpackPlugin</code>：用于自动生成HTML文件，并将打包生成的所有资源（如CSS、JS文件）自动注入到生成的HTML文件中。</li>
<li><code>MiniCssExtractPlugin</code>：用于将CSS代码从打包生成的JS文件中提取出来，创建一个单独的CSS文件，可以实现CSS的异步加载和浏览器缓存优化。</li>
<li><code>TerserWebpackPlugin</code>：用于对JS代码进行压缩和混淆，减小文件体积，提高加载速度。</li>
<li><code>OptimizeCSSAssetsWebpackPlugin</code>：用于对提取出的CSS进行压缩和优化。</li>
<li><code>CleanWebpackPlugin</code>：用于在构建之前清空输出目录，避免旧文件的干扰。</li>
<li><code>CopyWebpackPlugin</code>：用于将静态文件从源目录复制到输出目录，例如将图片、字体等文件复制到打包后的文件夹中。</li>
<li><code>DefinePlugin</code>：用于定义全局变量，可以在代码中直接使用这些变量，例如配置环境变量、区分开发环境和生产环境等。</li>
<li><code>HotModuleReplacementPlugin</code>：用于启用模块热更新，实现在开发过程中无需刷新页面即可看到最新变更的效果。</li>
<li><code>CompressionWebpackPlugin</code>：用于对打包生成的文件进行gzip压缩，减小文件体积，提升网络传输速度。</li>
<li><code>ProvidePlugin</code>：用于自动加载模块，当代码中使用到某个模块时，会自动将模块引入，无需手动import。</li>
</ol>
<p>这只是一小部分常用的Webpack插件，实际上还有很多其他的插件可以根据需要进行使用和定制。使用合适的插件可以大大提高Webpack的功能和效率，以及优化构建过程和最终生成的资源文件。</p>
<h2 id="5-在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）？它们有什么区别？"><a href="#5-在Webpack中，什么是代码分离（code-splitting）和懒加载（lazy-loading）？它们有什么区别？" class="headerlink" title="5. 在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）？它们有什么区别？"></a>5. 在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）？它们有什么区别？</h2><p><strong>代码分离（code splitting）和懒加载（lazy loading）是Webpack中用于优化资源加载的两种技术。</strong></p>
<blockquote>
<p>代码分离是将打包生成的代码文件拆分成多个较小的文件，而不是将所有代码打包到一个文件中。</p>
</blockquote>
<p>这样做的好处是可以<strong>提高初始加载速度，并减小每个页面的加载所需的数据量</strong>。通过代码分离，只需在需要时加载特定模块，提高了页面的响应速度和用户体验。</p>
<p><strong>懒加载是指在需要时才加载某个模块，而不是在初始加载时就将所有代码一次性加载完毕</strong>。通过懒加载，可以将页面分成多个模块，并根据需要动态地加载模块。这可以减少初始加载时间，只加载目前需要的模块，在用户与页面进行交互时再根据需要进行加载，提高了页面的性能和加载速度。</p>
<blockquote>
<p>两者的区别在于：</p>
</blockquote>
<ul>
<li><strong>代码分离是将代码文件拆分成较小的文件，其中每个文件可能包含多个模块</strong>。这样做可以在初始加载时减少数据量，但仍然需要一次性加载所需的文件。</li>
<li><strong>懒加载是将页面分成多个模块，在需要时才去加载相应的模块</strong>。这样做可以进一步减小初始加载时间，只加载当前可见的模块，随着用户与页面交互，再按需加载其他模块。</li>
</ul>
<p><strong>在Webpack中，可以通过配置和使用动态导入（Dynamic Imports）来实现代码分离和懒加载</strong>。这样可以根据需要将模块进行分割，并在需要时动态加载模块。通过代码分离和懒加载，可以提高页面的性能和加载速度，避免一次性加载过多的资源文件，从而提升用户体验。</p>
<h2 id="6-如何配置Webpack的开发环境和生产环境的不同配置？"><a href="#6-如何配置Webpack的开发环境和生产环境的不同配置？" class="headerlink" title="6. 如何配置Webpack的开发环境和生产环境的不同配置？"></a>6. 如何配置Webpack的开发环境和生产环境的不同配置？</h2><p><strong>在Webpack中，可以通过配置不同的Webpack配置文件或统一的配置文件来区分开发环境和生产环境的配置。</strong></p>
<p>一种常见的做法是<strong>创建两个独立的Webpack配置文件，分别针对开发环境和生产环境进行配置</strong>。一般来说，开发环境的配置更侧重于开发体验和调试工具，而生产环境的配置则更关注代码优化、压缩和资源的优化。</p>
<blockquote>
<p>例如，可以创建以下两个Webpack配置文件：</p>
</blockquote>
<h3 id="1-webpack-config-dev-js（开发环境配置文件）"><a href="#1-webpack-config-dev-js（开发环境配置文件）" class="headerlink" title="1. webpack.config.dev.js（开发环境配置文件）"></a>1. <code>webpack.config.dev.js</code>（开发环境配置文件）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-webpack-config-prod-js（生产环境配置文件）"><a href="#2-webpack-config-prod-js（生产环境配置文件）" class="headerlink" title="2. webpack.config.prod.js（生产环境配置文件）"></a>2. <code>webpack.config.prod.js</code>（生产环境配置文件）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>()],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeRedundantAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">useShortDoctype</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;styles.css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此示例中，开发环境的配置文件仅包含了开发服务器（<code>devServer</code>）和热模块替换（<code>hot module replacement</code>）的配置，而生产环境的配置文件则包含了代码压缩（<code>TerserWebpackPlugin</code>）和CSS提取（<code>MiniCssExtractPlugin</code>）等插件的配置。</p>
<p>另一种做法是使用同一个配置文件，并在其中根据环境变量来判断不同的配置。可以使用<code>webpack-merge</code>工具来合并共享的配置和环境特定的配置。以下是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.common&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> envConfig = <span class="built_in">require</span>(<span class="string">`./webpack.config.<span class="subst">$&#123;env&#125;</span>.js`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">webpackMerge</span>(commonConfig, envConfig);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>webpack.config.common.js</code>是共享的基本配置文件，而<code>webpack.config.dev.js</code>和<code>webpack.config.prod.js</code>分别是开发环境和生产环境的特定配置文件。根据传入的环境变量，可以决定加载哪个环境的配置文件。</p>
<p>在命令行中使用Webpack时，可以通过设置环境变量来指定所需的配置文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.config.js --env production</span><br></pre></td></tr></table></figure>

<p>以上是一些常见的配置不同环境的方法，你可以根据自己的需求选择适合的方式来配置Webpack的开发环境和生产环境。</p>
<h2 id="7-Webpack中的热重载（Hot-Module-Replacement）是什么？如何配置实现热更新？"><a href="#7-Webpack中的热重载（Hot-Module-Replacement）是什么？如何配置实现热更新？" class="headerlink" title="7. Webpack中的热重载（Hot Module Replacement）是什么？如何配置实现热更新？"></a>7. Webpack中的热重载（Hot Module Replacement）是什么？如何配置实现热更新？</h2><p><strong>热重载（Hot Module Replacement，HMR）是Webpack提供的一项功能，它允许在开发过程中，无需刷新整个页面，即可实时更新修改的模块。</strong></p>
<blockquote>
<p>通过热重载，可以提高开发效率，快速查看代码变化的结果，并保持应用的状态（如表单数据）。</p>
</blockquote>
<p>要配置实现热更新，需要进行以下步骤：</p>
<p><strong>1. 在Webpack配置文件中启用热模块替换。可通过配置<code>devServer.hot</code>选项为<code>true</code>来启用HMR：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 在入口文件中添加对HMR的支持。在入口文件中，需要添加HMR的逻辑以监听模块的变化，并告诉Webpack如何处理更新。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 配置Webpack插件。HMR需要搭配相应的插件使用，常用的是<code>webpack.HotModuleReplacementPlugin</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line">    <span class="comment">// ...其他插件</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成上述配置后，运行Webpack开发服务器时，<code>Webpack</code>会在文件发生变化时将更新的模块代码发送给浏览器，浏览器会在不刷新整个页面的情况下，替换掉相应的模块。</p>
<p>请注意，<strong>热重载只适用于开发环境，并不能直接用于生产环境</strong>。在生产环境中，需要使用Webpack生成的静态文件进行部署。</p>
<p>热重载可以提高开发效率，但在某些情况下可能会遇到一些问题，如状态丢失、事件绑定问题等。因此，对于某些情况下，可能需要手动刷新页面来确保正确的状态。</p>
<h2 id="8-解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。"><a href="#8-解释一下Webpack的文件指纹（file-fingerprint）和缓存（caching）机制。" class="headerlink" title="8. 解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。"></a>8. 解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。</h2><p><strong>Webpack的文件指纹（file fingerprint）机制是指在打包生成静态资源时，为每个文件生成唯一的标识码</strong>。这个标识码通常是通过对文件内容进行 <code>hash</code> 计算得到的。一旦文件内容发生改变，其文件指纹也会发生改变，从而防止浏览器在缓存过期前使用旧的文件。</p>
<blockquote>
<p>文件指纹有以下几种常见的类型：</p>
</blockquote>
<ul>
<li><code>Hash</code>：每次打包时，Webpack 会给每个输出的文件生成一个 hash 值。只要文件内容发生变化，其 hash 值也会发生变化。</li>
<li><code>Chunkhash</code>：根据不同的入口文件进行依赖关系解析后，Webpack 会为每个 chunk 生成一个 hash 值。只有当前 chunk 内容发生变化时，其 hash 值才会发生变化。</li>
<li><code>Contenthash</code>：采用文件内容的 hash 值作为文件指纹，只有文件内容发生变化时，其 hash 值才会发生变化。适用于样式文件、图片文件等。</li>
</ul>
<p><strong>缓存机制是指浏览器在加载页面时，会将静态资源（如 JS、CSS、图片等）保存在本地，以便下次加载相同资源时可以直接使用缓存副本，从而提高网页加载速度。缓存机制分为强缓存和协商缓存两种方式。</strong></p>
<ul>
<li><strong>强缓存</strong>：通过设置 <code>Response Header</code> 中的 <code>Cache-Control</code> 或 <code>Expires</code> 字段，告诉浏览器静态资源的有效期。在有效期内，浏览器会直接从缓存获取资源，无需向服务器发起请求。</li>
<li><strong>协商缓存</strong>：通过设置 <code>Response Header</code> 中的 <code>Last-Modified</code> 和 <code>ETag</code> 字段，告诉浏览器静态资源的版本信息。在请求资源时，如果浏览器的缓存仍然有效，则会发送一个请求到服务器，服务器会根据请求中的 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 字段进行验证，返回 <code>304</code> 状态码，并告诉浏览器可以使用缓存，从而减少数据传输。</li>
</ul>
<h2 id="9-如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？"><a href="#9-如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？" class="headerlink" title="9. 如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？"></a>9. 如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？</h2><p><strong>Webpack提供了各种加载器（Loader）来处理不同类型的资源文件。下面是处理图片、CSS和字体文件的示例：</strong></p>
<h3 id="1-图片文件"><a href="#1-图片文件" class="headerlink" title="1. 图片文件"></a>1. 图片文件</h3><ul>
<li>安装 file-loader 或 url-loader：<code>npm install file-loader</code> 或 <code>npm install url-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>, <span class="comment">// 文件指纹配置</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;images/&#x27;</span>, <span class="comment">// 输出目录</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .png、.jpg 或 .gif 结尾的图片文件，并将它们输出到指定的目录中。</p>
<h3 id="2-CSS-文件"><a href="#2-CSS-文件" class="headerlink" title="2. CSS 文件"></a>2. CSS 文件</h3><ul>
<li>安装 style-loader 和 css-loader：<code>npm install style-loader css-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .css 结尾的 CSS 文件，并使用 style-loader 和 css-loader 进行加载和处理。</p>
<h3 id="3-字体文件"><a href="#3-字体文件" class="headerlink" title="3. 字体文件"></a>3. 字体文件</h3><ul>
<li>安装 file-loader 或 url-loader：<code>npm install file-loader</code> 或 <code>npm install url-loader</code></li>
<li>在Webpack配置文件中配置加载器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>, <span class="comment">// 文件指纹配置</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;fonts/&#x27;</span> <span class="comment">// 输出目录</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置将处理以 .woff、.woff2、.eot、.ttf 或 .otf 结尾的字体文件，并将它们输出到指定的目录中。</p>
<p>注意，在配置加载器时，你可以根据自己的需求自定义加载器的选项。这些加载器可以在Webpack配置中的 module.rules 中进行定义。</p>
<h2 id="10-Webpack的Tree-Shaking是什么？如何配置实现代码的无用代码剔除？"><a href="#10-Webpack的Tree-Shaking是什么？如何配置实现代码的无用代码剔除？" class="headerlink" title="10. Webpack的Tree Shaking是什么？如何配置实现代码的无用代码剔除？"></a>10. Webpack的Tree Shaking是什么？如何配置实现代码的无用代码剔除？</h2><p><strong>Webpack的Tree Shaking是一个用于删除代码中未被引用的未使用代码的优化技术。</strong></p>
<blockquote>
<p>它可以显著减小打包后的文件体积，提高网页加载速度。</p>
</blockquote>
<p>要配置Webpack实现代码的无用代码剔除，需要进行以下几个步骤：</p>
<ol>
<li>确保你的代码是使用ES6模块语法编写的，而不是CommonJS（require）语法。因为Tree Shaking只对ES6模块有效。</li>
<li>在Webpack配置文件中，通过设置<code>mode</code>为<code>production</code>，启用Webpack的生产模式，此时Tree Shaking功能会默认开启。</li>
<li>确保你的<code>package.json</code>文件中的<code>sideEffects</code>字段被正确配置。<code>sideEffects</code>字段告诉Webpack哪些文件是没有副作用的，可以进行Tree Shaking。如果你的应用是纯粹的JavaScript应用，可以将<code>sideEffects</code>设置为<code>&quot;sideEffects&quot;: false</code>。如果你的应用使用了一些有副作用的模块（例如CSS文件），你需要将这些模块添加到<code>sideEffects</code>字段中。这样Webpack就不会将这些有副作用的模块进行Tree Shaking。</li>
</ol>
<p>需要注意的是，<strong>Tree Shaking只适用于ES6模块语法，并且只能剔除未引用的代码，不能剔除被动态引用的代码</strong>（例如通过字符串拼接生成模块路径）。另外，一些特定的代码结构可能会导致Tree Shaking失效，例如使用<code>eval</code>、<code>with</code>等特殊语法。</p>
<p>配置完成后，运行Webpack打包构建，未被引用的代码将会被删除，从而减小文件体积。</p>
<h2 id="11-如何优化Webpack的构建速度？提供一些常见的优化策略。"><a href="#11-如何优化Webpack的构建速度？提供一些常见的优化策略。" class="headerlink" title="11. 如何优化Webpack的构建速度？提供一些常见的优化策略。"></a>11. 如何优化Webpack的构建速度？提供一些常见的优化策略。</h2><blockquote>
<p>优化Webpack的构建速度是一个常见的需求，下面是一些常见的优化策略：</p>
</blockquote>
<ol>
<li><strong>通过配置缓存</strong>：可以使用<code>cache-loader</code>或者<code>hard-source-webpack-plugin</code>来启用缓存，避免重复编译没有改动的文件。</li>
<li><strong>通过配置多线程&#x2F;并行构建</strong>：可以使用<code>thread-loader</code>或者<code>happypack</code>来在多个工作线程中并行处理任务，加快构建速度。</li>
<li><strong>减少文件的解析和处理</strong>：可以通过配置<code>resolve.extensions</code>来减少Webpack的文件解析，只处理特定格式的文件。另外，使用<code>include</code>和<code>exclude</code>选项来限制需要处理的文件范围。</li>
<li><strong>优化Loader的配置</strong>：可以使用<code>exclude</code>选项来排除不必要的目录，只对需要处理的目录使用对应的Loader。另外，可以使用<code>resolve.alias</code>来配置别名，减少模块查找时间。</li>
<li><strong>使用Tree Shaking</strong>：通过配置<code>mode</code>为<code>production</code>，并且在<code>package.json</code>中将<code>sideEffects</code>设置为<code>false</code>或者具体的文件列表，开启Tree Shaking功能，剔除掉未使用的代码。</li>
<li><strong>合理使用Webpack的插件</strong>：根据具体需求，合理选择和配置Webpack的插件，避免不必要的处理和压缩。</li>
<li><strong>使用DllPlugin和缓存</strong>：可以将一些不经常变动的库使用<code>DllPlugin</code>预先编译，并将结果文件缓存起来，这样可以避免每次构建都重新编译这些库。</li>
</ol>
<p>以上是一些常见的Webpack构建速度优化策略，根据具体的项目需求和情况选择合适的优化方式。</p>
<h2 id="12-Webpack的Resolve模块解析是什么？请解释resolve-modules、resolve-alias和resolve-extensions的作用。"><a href="#12-Webpack的Resolve模块解析是什么？请解释resolve-modules、resolve-alias和resolve-extensions的作用。" class="headerlink" title="12. Webpack的Resolve模块解析是什么？请解释resolve.modules、resolve.alias和resolve.extensions的作用。"></a>12. Webpack的Resolve模块解析是什么？请解释resolve.modules、resolve.alias和resolve.extensions的作用。</h2><p><strong>Webpack的Resolve模块解析是用于解析模块路径的配置选项。它可以帮助Webpack正确地确定模块的位置。</strong></p>
<ul>
<li><code>resolve.modules</code>用于指定模块的搜索路径。当Webpack在解析导入语句时，它会按照指定的顺序依次查找这些路径来确定模块的位置。默认情况下，Webpack会在当前工作目录和node_modules文件夹中查找。</li>
<li><code>resolve.alias</code>用于创建模块的路径别名。通过配置别名，可以让Webpack在导入模块时使用更简短的路径。这对于减少代码中的冗余路径非常有用。</li>
<li><code>resolve.extensions</code>用于指定可以省略的文件扩展名。当导入模块时没有指定文件扩展名时，Webpack会按照指定的顺序依次尝试添加扩展名来解析模块。这样可以让我们在导入模块时省略掉繁琐的扩展名，提高开发效率。</li>
</ul>
<p>通过合理配置这些选项，我们可以让Webpack更快地找到模块的位置，并且在导入模块时更加方便简洁。</p>
<h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>optimization它允许开发者来自定义和优化打包策略</p>
<p><strong>splitChunks</strong>: 这是代码分割的核心配置。通过它，你可以配置 Webpack 如何分割代码到不同的 chunk 中。<code>splitChunks</code> 提供了多个选项来定制代码分割的行为，比如 <code>chunks</code>（哪些 chunk 中的模块应该被考虑分割）、<code>minSize</code>（分割的最小大小）、<code>maxSize</code>（分割的最大大小）、<code>cacheGroups</code>（定义如何分组和命名分割后的 chunk）等。</p>
<p>当 <code>chunks</code> 配置为 <code>&#39;all&#39;</code> 时，它表示所有的 chunks（包括初始加载的 chunks 和异步加载的 chunks）中的模块都会被考虑进行代码分割。这意味着 Webpack 会尝试找出所有 chunks 中共用的模块，并将它们提取到单独的 chunk 中，以优化最终打包的结果。</p>
<h3 id="代码分割的好处不仅仅是减小包的体积-它还可以帮助我们"><a href="#代码分割的好处不仅仅是减小包的体积-它还可以帮助我们" class="headerlink" title="代码分割的好处不仅仅是减小包的体积,它还可以帮助我们:"></a>代码分割的好处不仅仅是减小包的体积,它还可以帮助我们:</h3><ol>
<li><p>按需加载代码,避免加载用户不需要的代码。</p>
</li>
<li><p>并行加载代码,提高加载速度。</p>
</li>
<li><p>更好地利用浏览器缓存。</p>
</li>
<li><p>更灵活地组织代码,提高代码的可维护性。</p>
<h4 id="3-1-如何实现代码分割"><a href="#3-1-如何实现代码分割" class="headerlink" title="3.1 如何实现代码分割"></a>3.1 如何实现代码分割</h4><p>在Webpack中,有两种主要的代码分割方式:</p>
<ol>
<li>入口点分割:通过配置多个入口点,Webpack会为每个入口点生成一个独立的包。</li>
<li>动态导入:通过使用动态导入语句(如<code>import()</code>)，Webpack会将动态导入的模块分割到一个独立的包中。</li>
</ol>
<p>除此之外,Webpack还提供了更高级的代码分割功能,如使用SplitChunksPlugin进行公共代码提取。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &#x27;all&#x27;,</span><br><span class="line">      minSize: 20000,</span><br><span class="line">      maxSize: 0,</span><br><span class="line">      minChunks: 1,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          priority: -10,</span><br><span class="line">        &#125;,</span><br><span class="line">        default: &#123;</span><br><span class="line">          minChunks: 2,</span><br><span class="line">          priority: -20,</span><br><span class="line">          reuseExistingChunk: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们详细解释几个比较重要的配置项:</p>
<ul>
<li><p><code>chunks</code>:表示哪些代码需要优化。这里设置为<code>all</code>,表示同步和异步代码都要优化。</p>
</li>
<li><p><code>minSize</code>:表示拆分前的最小模块大小。这里设置为20000字节(约20KB),避免生成过多的小文件。</p>
</li>
<li><pre><code>cacheGroups
</code></pre>
<p>:定义了拆分的缓存组。</p>
<ul>
<li><code>vendors</code>:用于拆分<code>node_modules</code>目录下的模块。</li>
<li><code>default</code>:默认的缓存组,用于拆分被多次引用的模块。</li>
</ul>
</li>
</ul>
<h4 id="hard-source-webpack-plugin"><a href="#hard-source-webpack-plugin" class="headerlink" title="hard-source-webpack-plugin"></a>hard-source-webpack-plugin</h4><p><code>hard-source-webpack-plugin</code> 是一个 Webpack 插件，它的主要作用是通过缓存已经构建过的模块，来加速后续的构建过程。在大型项目中，特别是那些有很多依赖和复杂配置的 Vue 项目中，构建时间可能会变得非常长。使用 <code>hard-source-webpack-plugin</code> 可以显著减少构建时间，提高开发效率。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[objice.defineProperty]]></title>
      <url>/2023/07/15/es6/object,defineoproperty/</url>
      <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h1><p>作用：在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p>
<h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p>参数：</p>
<ol>
<li>要添加属性的对象</li>
<li>要定义或修改的属性的名称或 [<code>Symbol</code>]</li>
<li>要定义或修改的属性描述符 看一个简单的例子</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">&#x27;lihua&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在person对象上添加属性namep,值为personName</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;namep&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//但是默认是不可枚举的(for in打印打印不出来)，可：enumerable: true</span></span><br><span class="line">    <span class="comment">//默认不可以修改，可：wirtable：true</span></span><br><span class="line">    <span class="comment">//默认不可以删除，可：configurable：true</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了get方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> personName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了set方法&#x27;</span>)</span><br><span class="line">        personName = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当读取person对象的namp属性时，触发get方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">namep</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当修改personName时，重新访问person.namep发现修改成功</span></span><br><span class="line">personName = <span class="string">&#x27;liming&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">namep</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对person.namep进行修改，触发set方法</span></span><br><span class="line">person.<span class="property">namep</span> = <span class="string">&#x27;huahua&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">namep</span>)</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure>

<p>通过这种方法，我们成功监听了person上的name属性的变化。</p>
]]></content>
      
        <categories>
            
            <category> web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> es </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cnava使用]]></title>
      <url>/2023/07/14/cnava/</url>
      <content type="html"><![CDATA[<p><img src="/../images/d36f6737954f4759b135c88afa216d76.jpeg" alt="img"></p>
<p>画布的长度宽度要通过在标签中属性来设置 不能通过样式去修改</p>
<p>svg 标签</p>
<p>使用方法和常用API<br>1 标签<br>2 默认宽300，高150，不用用Css设置宽高<br>3 获取方法var ctx &#x3D; cas.getcontext(“2d”),该方法返回CanvasRenderingContext2D的类型对象，利用该方法绘图</p>
<h6 id="4-基本绘图命令"><a href="#4-基本绘图命令" class="headerlink" title="4 基本绘图命令"></a>4 基本绘图命令</h6><p>设置开始绘图位置：ctx.moveTo(x,y);<br>设置直线到的位置：ctx.lineTo(x,y);<br>描边绘制：ctx.stroke();<br>填充绘制：ctx.fill();<br>自动闭合路径：ctx.closePath();<br>开启新的绘制：ctx.beginPath();<br>设置描边颜色：ctx.strokeStyle;<br>设置填充颜色：ctx.fillStyle;<br>保存开始设置：ctx.save();<br>重置到保存样式：ctx.restore();</p>
<h6 id="线型相关属性"><a href="#线型相关属性" class="headerlink" title="线型相关属性"></a>线型相关属性</h6><p>设置线宽：ctx.linewidth;(数字即可)<br>设置线末端类型：ctx.lineCap;(‘butt’ 表示两端使用方形结束,‘round’ 表示两端使用圆角结束,‘square’ 表示突出的圆角结束)<br>设置相交线的拐点：ctx.lineJoin;(‘round’ 使用圆角连接,‘bevel’ 使用平切连接,‘miter’ 使用直角转)<br>获得线段样式数组：ctx.getLineDash();<br>设置线段样式：ctx.setLineDash();(数组形式设置)<br>绘制线段偏移量：ctx.lineDashOffset;</p>
<h6 id="矩形绘图命令"><a href="#矩形绘图命令" class="headerlink" title="矩形绘图命令"></a>矩形绘图命令</h6><p>绘制矩形：ctx.rect;(因为还需要fill或者stroke才可以看见效果，所以直接使用下面两种)<br>绘制边框矩形：ctx.strokeRect(x,y,width,height);<br>绘制填充矩形：ctx.fillRect(x,y,width,height);<br>清除矩形区域：ctx.clearRect(x,y,width,height);</p>
<h6 id="圆弧绘制命令"><a href="#圆弧绘制命令" class="headerlink" title="圆弧绘制命令"></a>圆弧绘制命令</h6><p>绘制圆弧：ctx.arc(x,y,r,startAngle,endAngle,anticlockwise);参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选</p>
<h6 id="绘制文本命令"><a href="#绘制文本命令" class="headerlink" title="绘制文本命令"></a>绘制文本命令</h6><p>绘制填充文字：ctx.fillText(text,x,y);<br>绘制空心文字：ctx.strokeText(text,x,y);<br>设置字体样式：ctx.font;<br>设置字体水平位置：ctx.textAlign;(start(默认), end, left, right, center)<br>设置字体垂直位置：ctx.textBaseline;(top, middle, bottom, hanging, alphabetic, ideographic)</p>
<h6 id="绘制图片命令"><a href="#绘制图片命令" class="headerlink" title="绘制图片命令"></a>绘制图片命令</h6><p>绘制图片(3参数)：ctx.drawImage(img,casx,casy);<br>绘制图片(5参数)：ctx.drawImage(img,casx,casy,width,height);<br>绘制图片(9参数)：ctx.drawImage(img,x,y,width,height,casx,casy,caswidth,casheight);</p>
<h6 id="变换命令"><a href="#变换命令" class="headerlink" title="变换命令"></a>变换命令</h6><p>平移变换：ctx.translate(x,y);(x 表示水平移动, 正数向右, 负数向左;y 表示垂直移动, 正数向下, 负数向上)<br>旋转变化：ctx.ratate(radian);(参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转.)<br>缩放变化：ctx.scale(x,y);(x控制水平缩放倍率,y控制水平缩放倍率,传1不做缩放)<br>—</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[websocket的使用介绍]]></title>
      <url>/2023/07/09/websocket/</url>
      <content type="html"><![CDATA[<h3 id="一，什么是websocket"><a href="#一，什么是websocket" class="headerlink" title="一，什么是websocket"></a>一，什么是websocket</h3><p>WebSocket是HTML5下一种新的协&#x3D;&#x3D;议（websocket协议本质&#x3D;&#x3D;上是一个基于tcp的协议）<br>它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的<br>Websocket是一个持久化的协议</p>
<h3 id="二，websocket的原理"><a href="#二，websocket的原理" class="headerlink" title="二，websocket的原理"></a>二，websocket的原理</h3><p>websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信<br>在websocket出现之前，web交互一般是基于http协议的短连接或者长连接<br>websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”</p>
<h3 id="三，websocket与http的关系"><a href="#三，websocket与http的关系" class="headerlink" title="三，websocket与http的关系"></a>三，websocket与http的关系</h3><p> 相同点：</p>
<p>都是基于tcp的，都是可靠性传输协议<br>都是应用层协议<br>不同点：</p>
<p>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息<br>HTTP是单向的<br>WebSocket是需要浏览器和服务器握手进行建立连接的<br>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接<br> 联系：</p>
<p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的<br>总结（总体过程）：</p>
<p>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；</p>
<p><img src="/Yuanmingjian/../images/image-20240201091217609.png" alt="image-20240201091217609"></p>
<p>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；<br>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。</p>
<h3 id="四，websocket解决的问题"><a href="#四，websocket解决的问题" class="headerlink" title="四，websocket解决的问题"></a>四，websocket解决的问题</h3><p>1.http存在的问题<br>http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才进行相应的响应，因此本身对于实时通讯就是一种极大的障碍<br>http协议采用一次请求，一次响应，每次请求和响应就携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下<br>最重要的是，需要客户端主动发，服务端被动发，也就是一次请求，一次响应，不能实现主动发送<br>2.long poll(长轮询)<br>对于以上情况就出现了http解决的第一个方法——长轮询<br>基于http的特性，简单点说，就是客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询<br>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，实现了“伪·长连接”<br>张三取快递的例子，张三今天一定要取到快递，他就一直站在快递点，等待快递一到，立马取走<br> 从例子上来看有个问题：</p>
<p>假如有好多人一起在快递站等快递，那么这个地方是否足够大，（抽象解释：需要有很高的并发，同时有很多请求等待在这里）<br>总的来看：<br>推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。</p>
<p>服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。</p>
<p>3.Ajax轮询<br>基于http的特性，简单点说，就是规定每隔一段时间就由客户端发起一次请求，查询有没有新消息，如果有，就返回，如果没有等待相同的时间间隔再次询问<br>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，把这个过程放大n倍，本质上还是request &#x3D; response<br>举个形象的例子（假设张三今天有个快递快到了，但是张三忍耐不住，就每隔十分钟给快递员或者快递站打电话，询问快递到了没，每次快递员就说还没到，等到下午张三的快递到了，but，快递员不知道哪个电话是张三的，（可不是只有张三打电话，还有李四，王五），所以只能等张三打电话，才能通知他，你的快递到了）<br> 从例子上来看有两个问题：</p>
<p>假如说，张三打电话的时间间隔为10分钟，当他收到快递前最后一次打电话，快递员说没到，他刚挂掉电话，快递入库了（就是到了），那么等下一次时间到了，张三打电话知道快递到了，那么这样的通讯算不算实时通讯？很显然，不算，中间有十分钟的时间差，还不算给快递员打电话的等待时间（抽象的解释：每次request的请求时间间隔等同于十分钟，请求解析相当于等待）<br>假如说张三所在的小区每天要收很多快递，每个人都采取主动给快递员打电话的方式，那么快递员需要以多快的速度接到，其他人打电话占线也是问题（抽象解释：请求过多，服务端响应也会变慢）<br>总的来看，Ajax轮询存在的问题：<br>推送延迟。</p>
<p>服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。</p>
<p>推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高</p>
<h3 id="4-websocket的改进"><a href="#4-websocket的改进" class="headerlink" title="4.websocket的改进"></a>4.websocket的改进</h3><p>一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。</p>
<p>WebSocket有以下特点：</p>
<p>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。<br>HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）</p>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Messages&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;message in messages&quot; :key=&quot;message.id&quot;&gt;</span><br><span class="line">        &#123;&#123; message.text &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;inputMessage&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMessage()&quot;&gt;Send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      messages: [], // 初始化 messages 数组为空数组</span><br><span class="line">      inputMessage: &#x27;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.websocket = new WebSocket(&#x27;ws://localhost:8080&#x27;);</span><br><span class="line">    this.websocket.onmessage = this.handleMessage;</span><br><span class="line"></span><br><span class="line">    this.websocket.onopen = () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;连接成功&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage (event) &#123;</span><br><span class="line">      console.log(event);</span><br><span class="line">      if (event.data instanceof Blob)</span><br><span class="line">      &#123;</span><br><span class="line">        const reader = new FileReader()</span><br><span class="line">        reader.onload =()=&gt; &#123;</span><br><span class="line">          const textData = reader.result;</span><br><span class="line">          console.log(123);</span><br><span class="line">          // 获取文本数据</span><br><span class="line">          console.log(JSON.parse(textData));</span><br><span class="line">          const res = JSON.parse(textData)</span><br><span class="line">          this.messages.push(res);</span><br><span class="line">          // 在这里可以继续处理文本数据，比如将其转换为 JSON 格式等操作</span><br><span class="line">        &#125;;</span><br><span class="line">        reader.readAsText(event.data); // 将 Blob 数据读取为文本</span><br><span class="line">      &#125; else</span><br><span class="line">      &#123;</span><br><span class="line">        // 如果不是 Blob 数据，可以直接处理其他类型的数据</span><br><span class="line">        const message = JSON.parse(event.data);</span><br><span class="line">        this.messages.push(message);</span><br><span class="line">        console.log(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sendMessage () &#123;</span><br><span class="line">      const message = &#123;</span><br><span class="line">        id: Date.now(),</span><br><span class="line">        text: this.inputMessage,</span><br><span class="line">      &#125;;</span><br><span class="line">      this.websocket.send(JSON.stringify(message));</span><br><span class="line">      this.inputMessage = &#x27;&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.two &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 5rem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>node服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket = require(&#x27;ws&#x27;);</span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const cors = require(&#x27;cors&#x27;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line">const server = app.listen(8080, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Server started on port 8080&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const wss = new WebSocket.Server(&#123; server &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(&#x27;connection&#x27;, (ws) =&gt; &#123;</span><br><span class="line">  ws.on(&#x27;message&#x27;, (message) =&gt; &#123;</span><br><span class="line">    console.log(`Received message =&gt; $&#123;message&#125;`);</span><br><span class="line"></span><br><span class="line">    //clients代表不同的客户端 实现多端通信</span><br><span class="line">    wss.clients.forEach((client) =&gt; &#123;</span><br><span class="line">      if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">      client.send(message);</span><br><span class="line">        </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="SSE与websorket的区别"><a href="#SSE与websorket的区别" class="headerlink" title="SSE与websorket的区别"></a>SSE与websorket的区别</h4><p><img src="/Yuanmingjian/../images/image-20240411220807905.png" alt="image-20240411220807905"></p>
<p>客户端处理格式</p>
<p>客户端使用 <strong>EventSource</strong> 接口监听 <strong>SSE</strong> 消息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;path/to/sse&#x27;</span>);</span><br><span class="line">evtSource.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); <span class="comment">// 处理收到的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="后端需设置"><a href="#后端需设置" class="headerlink" title="后端需设置"></a>后端需设置</h4><h6 id="1-参数设置"><a href="#1-参数设置" class="headerlink" title="1. 参数设置"></a>1. 参数设置</h6><p>前文说到，SSE 本质是一个基于 http 协议的通信技术。</p>
<p>因此想要使用 <strong>SSE</strong> 技术构建需要服务器实时推送信息到客户端的连接，只需要将传统的 <strong>http 响应头的 contentType 设置为 text&#x2F;event-stream</strong> 。</p>
<p>并且为了保证客户端展示的是最新数据，需要将 <strong>Cache-Control 设置为 no-cache</strong> 。</p>
<p>在此基础上，<strong>SSE</strong> 本质是一个 TCP 连接，因此为了保证 SSE 的持续开启，需要将 <strong>Connection 设置为 keep-alive</strong> 。</p>
<p> res.setHeader(“Content-Type”, “text&#x2F;event-stream”); </p>
<p> res.setHeader(“Cache-Control”, “no-cache”); </p>
<p> res.setHeader(“Connection”, “keep-alive”);</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Uniapp的相关内容]]></title>
      <url>/2023/07/06/uniapp/%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="Uni-app中的事件总线"><a href="#Uni-app中的事件总线" class="headerlink" title="Uni-app中的事件总线"></a>Uni-app中的事件总线</h3><p>一、组件间的通讯<br>说到组件就离不开组件的通讯，这里组件的通讯主要分为以下三类：</p>
<p>父组件向子组件传递信息<br>子组件向父组件传递信息<br>兄弟组件之间传递信息<br>在这里父子组件之间的信息传递，与vue中父子组件的信息传递语法一致。</p>
<p>二、事件总线<br>1.应用场景<br>        除了父子组件传参之外，兄弟组件之间共享信息也是我们经常会遇到的。如果遇到这类问题，我们现在可以借助vuex，或者把数据统一放在他们父组件中处理。这两种方式都可以解决兄弟组件传递信息的问题。我们今天要介绍的是另一种方式-事件总线，事件总线也是我们开发过程中经常会用到的一种开发模式。</p>
<p>2.定义<br>        事件总线可以作为组件沟通的桥梁，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p>
<p>3.监听事件<br>uni.$on(eventName,callback)</p>
<pre><code>    监听全局的自定义事件。事件可以由 uni.$emit 触发，回调函数会接收所有传入事件触发函数的额外参数。
</code></pre>
<p>uni.$on(‘update’,function(data){</p>
<pre><code>console.log(&#39;监听到事件来自 update ，携带参数 msg 为：&#39; + data.msg);
</code></pre>
<p>})</p>
<p> 4.触发事件<br>        在uni中可以通过uni.$emit(eventName,OBJECT)来触发全局的自定事件。附加参数都会传给监听器回调。</p>
<p>代码示例</p>
<pre><code>uni.$emit(&#39;update&#39;,&#123;msg:&#39;页面更新&#39;&#125;)
</code></pre>
<p> 5.只监听一次——$once<br>        监听全局的自定义事件。事件可以由 uni.$emit 触发，但是只触发一次，在第一次触发之后移除监听器。</p>
<p>uni.$once(eventName,callback)</p>
<p>uni.$once(‘update’,(data)&#x3D;&gt;{</p>
<pre><code>    console.log(&#39;监听到事件来自 update ，携带参数 msg 为：&#39; + data.msg);

&#125;)
</code></pre>
<p>6.移除监听<br>uni.$off([eventName, callback])</p>
<p>移除全局自定义事件监听器。</p>
<p>注意事项</p>
<p>如果没有提供参数，则移除所有的事件监听器；<br>如果只提供了事件，则移除该事件所有的监听器；<br>如果同时提供了事件与回调，则只移除这个回调的监听器；<br>提供的回调必须跟$on的回调为同一个才能移除这个回调的监听器；</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>在uni-app中生命周期总的来说一共有三种类型<br>页面生命周期，其实就是小程序页面当中的生命周期。</p>
<p>页面生命周期	<br>onLoad	监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参）<br>onShow	监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面<br>onReady	监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发<br>onHide	监听页面隐藏<br>onUnload	监听页面卸载<br>onResize	监听窗口尺寸变化<br>onPullDownRefresh	监听用户下拉动作，一般用于下拉刷新<br>onReachBottom	页面滚动到底部的事件（不是scroll-view滚到底），常用于上拉加载下一页数据。如使用scroll-view导致页面级没有滚动，则触底事件不会被触发<br>onTabItemTap	点击 tab 时触发，参数为Object，具体见下方注意事项<br>onShareAppMessage	用户点击右上角分享<br>onPageScroll	监听页面滚动，参数为Object<br>onNavigationBarButtonTap	监听原生标题栏按钮点击事件，参数为Object<br>onBackPress	监听页面返回，返回 event &#x3D; {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack<br>onNavigationBarSearchInputChanged	监听原生标题栏搜索输入框输入内容变化事件<br>onNavigationBarSearchInputConfirmed	监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。<br>onNavigationBarSearchInputClicked	监听原生标题栏搜索输入框点击事件<br>应用生命周期就是对于整个uni进行操作的生命周期，对于这个生命周期一般都是在App.vue当中操作，</p>
<p>应用生命周期	<br>onLaunch	当uni-app 初始化完成时触发（全局只触发一次）<br>onShow	当 uni-app 启动，或从后台进入前台显示<br>onHide	当 uni-app 从前台进入后台<br>onUniNViewMessage	对 nvue 页面发送的数据进行监听<br>组件生命周期，其实也就是vue的生命周期，一般在uni-app当中在组件里面使用</p>
<p>组件生命周期	<br>beforeCreate	实例已经开始初始化之后调用 【数据初始化未完成，页面没有开始渲染】<br>created	实例创建完成之后调用 【组件创建完成，不代表组件已挂载到页面】<br>beforeMount	在挂载开始之前被调用。<br>mounted	挂载到实例上去之后调用。 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档<br>beforeUpdate	数据更新时调用，发生在虚拟 DOM 打补丁之前。<br>updated	由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>beforeDestroy	实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed	Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p><strong>为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范：</strong></p>
<p><strong>页面文件遵循 Vue 单文件组件 (SFC) 规范</strong><br><strong>组件标签靠近小程序规范，详见uni-app 组件规范</strong><br><strong>接口能力（JS API）靠近微信小程序规范，但需将前缀 wx 替换为 uni，详见uni-app接口规范</strong><br><strong>数据绑定及事件处理同 Vue.js 规范，同时补充了App及页面的生命周期</strong><br><strong>为兼容多端运行，建议使用flex布局进行开发</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue3学习]]></title>
      <url>/2023/07/01/vue/vue3%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20230701203654930.png" alt="image-20230701203654930"></p>
<p>1 注册自定义指令 可以将img-lazy绑定在图片上 来实现懒加载</p>
<p>2 封装组件  简单的数据显示就用props接收  复杂的部分就用插槽</p>
<p>3</p>
<p><img src="/../../images/image-20230702185345840.png" alt="image-20230702185345840"></p>
<p><img src="/../../images/image-20230702185937366.png" alt="image-20230702185937366"></p>
<p>4 vue3中可以直接引用$route $router</p>
<p>5 <em>v-infinite-scroll</em>&#x3D;”load”   elementplus提供的方法判断是否到底部 可用于商品加载</p>
<p>6 可选链 ？.</p>
<p>7 放大镜</p>
<p><img src="/../../images/image-20230703213645297.png" alt="image-20230703213645297"></p>
<p>8   使用 <script setup> 语法糖的组件是默认关闭的，也即通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <script setup> 中声明的绑定。<br>方法：为了在 <script setup> 语法糖组件中明确要暴露出去的属性，，使用 defineExpose 编译器宏将需要暴露出去的变量与方法放入暴露出去就可以<br>9 全局组件  通过插件的方式（install） 之后在main里面注册</p>
<p><img src="/../../images/image-20230704151441182.png" alt="image-20230704151441182"></p>
<p>10 请求头携带token<img src="/../../images/image-20230704164611963.png" alt="image-20230704164611963"></p>
<p>10</p>
<p><img src="/../../images/image-20230704165558834.png" alt="image-20230704165558834"></p>
<p>11 购物车 的按钮 全选 单选 等 结合pinan 实现同步  通过every find filter 等数组方法找到或计算等 pinna的数组对象 </p>
<p>​     <img src="/../../images/image-20230705131434477.png" alt="image-20230705131434477"></p>
<p>12 持续化pinna  插件  </p>
<p>13 用户退出登陆 除了清楚用户信息 也要     </p>
<p>14 登陆时 要把本地购物车和服务器的购物车 列表合并 在渲染一个新的列表</p>
<p>15 提交订单</p>
<p><img src="/../../images/image-20230705161301828.png" alt="image-20230705161301828"></p>
<p>16 倒计时函数</p>
<p><img src="/../../images/image-20230705164926351.png" alt="image-20230705164926351"></p>
<p><img src="/../../images/image-20230705164712571.png" alt="image-20230705164712571"></p>
<p>17 sku组件 难 </p>
<p>18  动态实现路由模板 理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">  &lt;transition&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;component :is=&quot;Component&quot; /&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>





<p><img src="/../../images/5ccd16fe2d1942e699bde7a7971c26a2tplv-k3u1fbpfcp-jj-mark3024000q75.webp" alt="生命周期.webp"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue的面试题]]></title>
      <url>/2023/06/19/%E9%9D%A2%E7%BB%8F/vue%20%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><a href="https://www.yuque.com/docs/share/56f5e89d-ee8f-4b54-bd9c-f835b979be31#">https://www.yuque.com/docs/share/56f5e89d-ee8f-4b54-bd9c-f835b979be31?#</a></p>
<h2 id="1-刷新浏览器后，vuex的数据是否存在？如何解决？"><a href="#1-刷新浏览器后，vuex的数据是否存在？如何解决？" class="headerlink" title="1.刷新浏览器后，vuex的数据是否存在？如何解决？"></a>1.刷新浏览器后，vuex的数据是否存在？如何解决？</h2><p>在vue项目中用vuex来做全局的状态管理， 发现当刷新网页后，保存在vuex实例store里的数据会丢失。</p>
<p><strong>原因</strong>：因为 store 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</p>
<p><strong>解决方法：</strong></p>
<p>a.使用vuex-along</p>
<p>vuex-along 的实质也是将 vuex 中的数据存放到 localStorage 或者 sessionStroage 中，只不过这个存取过程组件会帮我们完成，我们只需要用vuex的读取数据方式操作就可以了，简单介绍一下 vuex-along 的使用方法。</p>
<p>安装 vuex-along:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex-along --save</span><br></pre></td></tr></table></figure>

<p>配置 vuex-along: 在 store&#x2F;index.js 中最后添加以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueXAlong</span> <span class="keyword">from</span> <span class="string">&#x27;vuex-along&#x27;</span> <span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">//modules: &#123;</span></span><br><span class="line">        <span class="comment">//controler  //模块化vuex</span></span><br><span class="line">    <span class="comment">//&#125;,</span></span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title class_">VueXAlong</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;store&#x27;</span>,     <span class="comment">//存放在localStroage或者sessionStroage 中的名字</span></span><br><span class="line">        <span class="attr">local</span>: <span class="literal">false</span>,      <span class="comment">//是否存放在local中  false 不存放 如果存放按照下面session的配置</span></span><br><span class="line">        <span class="attr">session</span>: &#123; <span class="attr">list</span>: [], <span class="attr">isFilter</span>: <span class="literal">true</span> &#125; <span class="comment">//如果值不为false 那么可以传递对象 其中 当isFilter设置为true时， list 数组中的值就会被过滤调,这些值不会存放在seesion或者local中</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>b.使用 localStorage 或者 sessionStroage</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//在页面加载时读取sessionStorage里的状态信息</span></span><br><span class="line">    <span class="keyword">if</span> (sessionStorage.<span class="title function_">getItem</span>(<span class="string">&quot;store&quot;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">replaceState</span>(</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">          &#123;&#125;,</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>,</span><br><span class="line">          <span class="title class_">JSON</span>.<span class="title function_">parse</span>(sessionStorage.<span class="title function_">getItem</span>(<span class="string">&quot;store&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;store&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>Vuex 中的 replaceState 方法可以用来替换 Vuex 状态树中的整个状态对象。它接受一个新的状态对象作为参数，用来替换当前的状态对象。</p>
<p>替换状态对象可以用于状态数据的持久化，如在页面刷新时将 Vuex 中的状态保存到本地存储中，或者从本地存储中读取之前保存的状态信息，然后将其替换到 Vuex 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在页面加载时读取 sessionStorage 中的状态信息</span></span><br><span class="line"><span class="keyword">if</span> (sessionStorage.<span class="title function_">getItem</span>(<span class="string">&#x27;store&#x27;</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> savedState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(sessionStorage.<span class="title function_">getItem</span>(<span class="string">&#x27;store&#x27;</span>))</span><br><span class="line">  store.<span class="title function_">replaceState</span>(savedState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面刷新时保存状态信息到 sessionStorage 中</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentState = store.<span class="property">state</span></span><br><span class="line">  sessionStorage.<span class="title function_">setItem</span>(<span class="string">&#x27;store&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(currentState))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-vue路由中，history和hash两种模式有什么区别？"><a href="#3-vue路由中，history和hash两种模式有什么区别？" class="headerlink" title="3.vue路由中，history和hash两种模式有什么区别？"></a>3.vue路由中，history和hash两种模式有什么区别？</h2><h2 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a><strong>什么是前端路由？</strong></h2><p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。</p>
<p>为实现这一目标，我们需要做到以下两点：</p>
<ul>
<li>改变 url 且<code>不让</code>浏览器像服务器<code>发送请求</code>。</li>
<li>可以<code>监听、记录</code>到 url 的变化</li>
</ul>
<p>vue-router 中就有两种路由模式：hash 模式、history 模式</p>
<h3 id="hash模式："><a href="#hash模式：" class="headerlink" title="hash模式："></a>hash模式：</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>早期的前端路由的实现就是基于 location.hash 来实现的，location.hash 的值就是 URL 中 # 及后面的内容。它的实现原理就是监听 # 后面的内容来发起 Ajax 请求来进行局部更新，而不需要刷新整个页面。</li>
<li>使用 hashchange 事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：<ul>
<li>浏览器前进后退改变 URL</li>
<li>a 标签改变 URL</li>
<li>window.location 改变 URL</li>
</ul>
</li>
</ul>
<p>hash 模式是一种把前端路由的路径用井号 # 拼接在真实 URL 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 hashchange 事件。</p>
<p>总结一下 hash 模式的优缺点：</p>
<ul>
<li><strong>优点</strong>：浏览器兼容性较好，连 IE8 都支持</li>
<li><strong>缺点</strong>：路径在井号 # 的后面，比较丑        锚点功能缺失</li>
</ul>
<h3 id="history模式："><a href="#history模式：" class="headerlink" title="history模式："></a>history模式：</h3><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>history 提供了 <strong>pushState 和 replaceState</strong> 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li>
<li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过 pushState&#x2F;replaceState 或 a 标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState&#x2F;replaceState 的调用和 a 标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li>
<li>pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数</li>
</ul>
<p>history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求。</p>
<p>history API 提供了丰富的函数供开发者调用，我们不妨把控制台打开，然后输入下面的语句来观察浏览器地址栏的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>(&#123;&#125;, <span class="literal">null</span>, <span class="string">&#x27;/b&#x27;</span>) <span class="comment">// 替换路由</span></span><br><span class="line">history.<span class="title function_">pushState</span>(&#123;&#125;, <span class="literal">null</span>, <span class="string">&#x27;/a&#x27;</span>) <span class="comment">// 路由压栈</span></span><br><span class="line">history.<span class="title function_">back</span>() <span class="comment">// 返回</span></span><br><span class="line">history.<span class="title function_">forward</span>() <span class="comment">// 前进</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">2</span>) <span class="comment">// 后退2次</span></span><br></pre></td></tr></table></figure>

<p>上面的代码监听了 popstate 事件，该事件能监听到：</p>
<ul>
<li>用户点击浏览器的前进和后退操作</li>
<li>手动调用 history 的 back、forward 和 go 方法</li>
</ul>
<p>监听不到：</p>
<ul>
<li>history 的 pushState 和 replaceState方法</li>
</ul>
<p>这也是为什么上面的 toA 和 toB 函数内部需要手动调用 render 方法的原因。另外，大家可能也注意到 light-server 的命令多了 –historyindex ‘&#x2F;history.html’ 参数，这是干什么的呢？</p>
<p>浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。上面的参数的意思就是如果后端资源不存在就返回 history.html 的内容。</p>
<p>因此在线上部署基于 history API 的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。以最常用的 Nginx 为例，只需要在配置的 location &#x2F; 中增加下面一行即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try_files $uri /index.<span class="property">html</span>;</span><br></pre></td></tr></table></figure>



<h4 id="总结一下-history-模式的优缺点："><a href="#总结一下-history-模式的优缺点：" class="headerlink" title="总结一下 history 模式的优缺点："></a>总结一下 history 模式的优缺点：</h4><ul>
<li><strong>优点</strong>：路径比较正规，没有井号 #</li>
<li><strong>缺点</strong>：兼容性不如 hash，且需要服务端支持，否则一刷新页面就404了</li>
</ul>
<ol>
<li><p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li><p>history模式：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
<h2 id="4-vue的最大优势是什么？"><a href="#4-vue的最大优势是什么？" class="headerlink" title="4.vue的最大优势是什么？"></a>4.vue的最大优势是什么？</h2><p>Vue 作为一款轻量级框架、简单易学、 数据绑定、组件化、数据和结构的分离、<strong>虚拟 DOM</strong>、运行速度快，并且作者是 中国人尤雨溪，对应的 API 文档对国内开发者优化，作为前端开发人员的首选入 门框架，Vue 有很多优势:<br>Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。 Vue.js 最突出的优势在于可以对数据进行<strong>双向绑定</strong>。 相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。 Vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom， 这样大大加快了访问速度和提升用户体验。<br>而且他的第三方 UI 组件库使用起来节省很多开发时间，从而提升开发效率。  </p>
<h2 id="5-mvvm-和-mvc-区别是什么-哪些场景适合"><a href="#5-mvvm-和-mvc-区别是什么-哪些场景适合" class="headerlink" title="5.mvvm 和 mvc 区别是什么?哪些场景适合?"></a>5.mvvm 和 mvc 区别是什么?哪些场景适合?</h2><p>1)MVVM 基本定义<br>MVVM 即 Model-View-ViewModel 的简写。即模型-视图-视图模型。模 </p>
<p>型(Model)指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型 (ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向: 一是将模型(Model)转化成视图(View)，即将后端传递的数据转化成所看到的页 面。实现的方式是:数据绑定。二是将视图(View)转化成模型(Model)，即将所看 到的页面转化成后端的数据。实现的方式是:DOM 事件监听。这两个方向都实 现的，我们称之为数据的双向绑定。 </p>
<p>\2) MVC 基本定义<br>MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V </p>
<p>指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。 使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。MVC 和 MVVM 的区别并不是 VM 完全 取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念， ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller， 其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是 业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。 </p>
<p>MVC 中的控制器是连接模型和视图的<strong>中介</strong>，用户的所有请求都会先经过控制器，然后再由控制器决定调用哪个模型或者视图来处理这个请求。</p>
<p>3)使用场景<br>MVC 和 MVVM 其实区别并不大。都是一种设计思想。主要就是 MVC 中 </p>
<p>C<strong>ontroller 演变成 MVVM 中的 viewModel，MVVM 主要解决了 MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</strong><br><strong>区别:Vue 数据驱动，通过数据来显示视图层而不是节点操作。 场景:数据操 作比较多的场景，需要大量操作 DOM 元素时，采用 MVVM 的开发方式，会更加 便捷，让开发者更多的精力放在数据的变化上，解放繁琐的操作 DOM 元素。</strong></p>
<p><strong>MVVM 中的视图模型扮演了控制器的角色，但是它与控制器的不同之处在于：视图模型更加专注于处理视图和数据之间的交互流程，而不需要过多关心控制应用程序的逻辑流程。此外，由于采用双向绑定的方式，MVVM 能够更加简化和优化视图和模型之间的通信，提高了代码的可读性和维护性。</strong></p>
<h2 id="7-vue组件间是如何进行传值的？"><a href="#7-vue组件间是如何进行传值的？" class="headerlink" title="7.vue组件间是如何进行传值的？"></a>7.vue组件间是如何进行传值的？</h2><p>1)父组件向子组件传递数据 。</p>
<p>父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属 性并把数据绑定在自定义属性上，在子组件添加参数 props 接收即可 </p>
<p>2)子组件向父组件传递数据 。</p>
<p>子组件通过 Vue 实例方法$emit 进行触发并且可以携带参数，父组件监听使 用@(v-on)进行监听，然后进行方法处理 。</p>
<p>3)非父子组件之间传递数据<br>1、引入第三方 new Vue 定义为 eventBus<br>2、在组件中 created 中订阅方法 eventBus.$on(“自定义事件名”,methods 中的方 法名)<br>3、在另一个兄弟组件中的 methods 中写函数，在函数中发布 eventBus 订阅 的方法 eventBus.$emit(“自定义事件名”) 4、在组件的 template 中绑定事件(比如 click) ]</p>
<p>Vue 组件间可以利用 props、<em>e<strong>mi</strong>t</em>、refs、event bus、Vuex、插槽 等方式进行传值。</p>
<h2 id="8-vue生命周期分为几个阶段？"><a href="#8-vue生命周期分为几个阶段？" class="headerlink" title="8.vue生命周期分为几个阶段？"></a>8.vue生命周期分为几个阶段？</h2><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化 数据、编译模板、挂载 Dom→渲染、更新→渲染、卸载等一系列过程，我们称这 是 Vue 的生命周期。					 			</p>
<p>1)beforeCreate </p>
<p>在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前 被调用。 </p>
<p>2)created 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置:数据观 </p>
<p>测 (data observer)， 属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段 还没开始，$el 属性目前不可见。<br>3)beforeMount </p>
<p>在挂载开始之前被调用:相关的 render 函数首次被调用。 </p>
<p>4)mounted </p>
<p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 </p>
<p>5)beforeUpdate </p>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问 现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间 不被调用，因为只有初次渲染会在服务端进行。<br>6)updated </p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p> 7)activated </p>
<p>keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。</p>
<p> 8)deactivated </p>
<p>keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。</p>
<p> 9)beforeDestroy </p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染 期间不被调用。 </p>
<p>10)destroyed<br>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有 的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间 不被调用。<br>11)errorCaptured(2.5.0+ 新增) </p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数:错误对 象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 </p>
<h2 id="10-请说下封装vue组件的过程。"><a href="#10-请说下封装vue组件的过程。" class="headerlink" title="10.请说下封装vue组件的过程。"></a>10.请说下封装vue组件的过程。</h2><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立 的模块，解决了我们传统项目开发:效率低、难维护、复用性等问题。<br>1)分析需求:确定业务需求，把页面中可以服用的结构，样式以及功能，单独 抽离成一个文件，实现复用<br>2)具体步骤:</p>
<ol>
<li>使用 Vue.component 方法注册组件，子组件需要数据，可以在 props 中接 受定义，而子组件修改好数据后，想把数据传递给父组件。可以采用$emit 方法 向外抛数据</li>
<li>如果需要给组件传入模板，则定义为插槽 slot</li>
<li>如果需要 父组件主动调用子组件的方法 可以在 methods 选项中开放方法</li>
</ol>
<h2 id="11-vue组件中的data为什么必须是函数？"><a href="#11-vue组件中的data为什么必须是函数？" class="headerlink" title="11.vue组件中的data为什么必须是函数？"></a>11.vue组件中的data为什么必须是函数？</h2><p>1、每个组件都是 Vue 的实例。<br>2、组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一 个会影响其他。<br>3、组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有 的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式， 就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。 </p>
<p>在 Vue 组件中，data 选项用于定义组件的内部状态，但其必须是一个函数而不是一个对象，<strong>这个设计是为了保证每个组件实例都有自己独立的状态，并且在不同的组件实例之间不会相互影响。</strong></p>
<p>具体来说，当 data 选项设置为一个对象时，由于 JavaScript 对象是引用类型，因此如果多个组件实例共享同一个对象，则它们的状态会相互影响。而将 data 选项设置为一个函数时，每个组件实例都会调用该函数来生成其对应的状态对象，从而确保了每个组件实例都拥有自己独立的状态数据。另外，将 data 选项设置为一个函数还有以下几个好处：</p>
<ol>
<li>可以在函数中添加额外的逻辑，例如计算属性、响应式数据等。</li>
<li>可以将 data 函数的返回值作为其他组件选项的默认值，例如 computed、methods 等。</li>
<li>可以让组件的单元测试更加方便，通过直接调用 data 函数，可以确保每次测试时组件都拥有独立的状态数据。</li>
</ol>
<h2 id="vue的diff"><a href="#vue的diff" class="headerlink" title="vue的diff"></a>vue的diff</h2><p><img src="/../../../images/image-20240220145343198.png" alt="image-20240220145343198"></p>
<h2 id="Pinia和Vuex"><a href="#Pinia和Vuex" class="headerlink" title="Pinia和Vuex"></a>Pinia和Vuex</h2><p>在API设计方面，Pinia和Vuex确实有所不同，而这正是它们各自特点的体现。</p>
<p>Pinia的设计灵感来源于React Hooks，它为状态管理提供了一个函数式的方法。在Pinia中，我通过<code>defineStore</code>函数来定义和初始化状态。这个函数返回一个store对象，这个对象包含了状态（<code>state</code>）、计算属性（<code>getters</code>）、动作（<code>actions</code>）等。我可以在组件中直接调用这个store对象来访问和修改状态，这使得状态管理非常直观和简单。由于它基于Vue 3的Composition API，因此它很好地结合了Vue的响应式系统，使得状态的变化能够实时反映在组件上。</p>
<p>相比之下，Vuex在API设计上采用了基于mutations和actions的模式。在Vuex中，我首先需要定义一个store对象，这个对象包含了状态的初始值、mutations（用于修改状态的方法）和actions（可以包含任意异步操作，通过提交mutations来修改状态）。这种模式虽然提供了更多的控制和灵活性，但也需要编写更多的代码来实现相同的功能。例如，当我想修改状态时，我必须先定义一个mutation，然后在需要的地方提交这个mutation。这种方式虽然提供了明确的状态变化流程，但相对来说更加繁琐。</p>
<p><strong>所以，总结一下</strong>，</p>
<p>Pinia通过类似于React Hooks的API设计，使得状态管理更加直观和简单。它减少了不必要的代码和复杂性，让我可以更专注于业务逻辑的实现。而Vuex则提供了更多的控制和灵活性，但可能需要更多的代码来实现相同的功能。选择哪一个取决于项目的具体需求和团队的偏好。</p>
<h3 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h3><p><img src="/../../../images/image-20240314181911669.png" alt="image-20240314181911669"></p>
<p>data和methods最早只能在creat方法中</p>
<p>beforemount 此函数执行的时候 模板已经在内存渲染好了 但是还未挂载页面 </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[哲玄飞书面试题]]></title>
      <url>/2023/06/03/%E9%9D%A2%E7%BB%8F/%E5%93%B2%E8%BD%A9%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<ol>
<li><p>为什么 0.1 + 0.2 不等于 0.3？</p>
<p> js 中的 Number 类型的数据都是双精度浮点型保存在内存中的，遵循的是ieee754 标准，由于0.1 转化为 2进制是一个无限循环的，但是内存保存的位数有限，所以第一次这里会精度丢失一次，再者 0.1+0.2 时，在执行加操作时要对阶，0.1的阶数比0.2 小，所以 0.1的尾数位要右移，所以这里也会造成精度的丢失，所以最后导致了 0.1+0.2 不等于0.3</p>
</li>
<li><p>如何判断js 的数据类型  </p>
<p>   基本数据类型用 typeof   引用数据类型用instanceof    3   objecrt.prototype.tostring.call()   </p>
</li>
<li><p>如何判断两个对象相等？ </p>
<p>  答：1**严格相等运算符 (&#x3D;&#x3D;&#x3D; ) 仅仅比较是否同一个地址 **     2 JSON.Stringify（不比较地址比较属性值）使用深度比较方法：如果需要比较对象的属性值是否相等，可以使用深度比较方法，例如 Lodash 库中的 <code>_.isEqual</code> 方法或者 JSON 序列化            3object,IS 类似&#x3D;&#x3D;&#x3D;</p>
<p>  ​     </p>
</li>
<li><p>如何判断空对象</p>
<h5 id="答：1-for-in-配合-hasOwnProperty"><a href="#答：1-for-in-配合-hasOwnProperty" class="headerlink" title="答：1. for in 配合 hasOwnProperty"></a>答：1. for in 配合 hasOwnProperty</h5><p> 使用 <code>for in</code> 对当前对象进行遍历：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEmptyObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmptyObj</span>(obj))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> 由于 <code>for in</code> 在进行对象遍历时，会遍历对象原型上的属性，而我们只希望得到其自身的属性，这时可以使用 <code>hasOwnProperty</code> 来实现，如下：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEmptyObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(o)) &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmptyObj</span>(obj))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 缺点：<code>for in</code> 不能遍历不可枚举的属性</p>
</li>
</ol>
<h5 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2  JSON.stringify"></a>2  JSON.stringify</h5><p>​        const obj &#x3D; {}; console.log(JSON.stringify(obj) &#x3D;&#x3D;&#x3D; ‘{}’)  &#x2F;</p>
<p>​        缺点：如果存在 <code>undefined</code>、任意的函数以及 symbol 值，在      序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被  转换成 <code>null</code>（出现在数组中时）</p>
<p>如下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) === <span class="string">&#x27;&#123;&#125;&#x27;</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="3-Object-keys"><a href="#3-Object-keys" class="headerlink" title="3. Object.keys"></a>3. Object.keys</h5><p><code>Object.keys</code> 会返回对象自身可枚举属性组成的数组，而不会遍历原型上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>缺点：<code>Object.keys</code> 和 <code>for in</code> 都只能遍历可枚举属性，不能遍历不可枚举的属性。</p>
<h5 id="4-Object-getOwnPropertyNames"><a href="#4-Object-getOwnPropertyNames" class="headerlink" title="4. Object.getOwnPropertyNames"></a>4. Object.getOwnPropertyNames</h5><p>使用 <code>Object.getOwnPropertyNames</code> 可以得到对象自身的所有属性名组成的数组(包括不可枚举属性)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj))  <span class="comment">// [ &#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>缺点：不能获取 <code>Symbol</code> 值作为名称的属性，以上的 <code>JSON.stringify</code>、<code>for in</code> 以及 <code>Object.keys</code> 方法也不能获取<code>Symbol</code> 值作为名称的属性，示例如下：</p>
<p>已知 <code>Object.getOwnPropertyNames</code> 唯一的缺点是不能获取 <code>Symbol</code> 值作为名称的属性，而 <code>Object.getOwnPropertySymbols</code> 只能获取由 <code>Symbol</code> 值作为名称的属性，两者相结合是不是就可以完美解决了 即reflect.ownkeys</p>
<h5 id="3-Reflect-ownKeys"><a href="#3-Reflect-ownKeys" class="headerlink" title="3 Reflect.ownKeys"></a>3 Reflect.ownKeys</h5><p><code>Reflect.ownKeys</code> 方法返回一个由目标对象自身的属性组成的数组，它的返回值等同于 <code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  [a]: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj3, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> obj4 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj1).<span class="property">length</span> === <span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj2).<span class="property">length</span> === <span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj3).<span class="property">length</span> === <span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj4).<span class="property">length</span> === <span class="number">0</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="主线程的渲染都会对-setTimeout-和-setInterval-的执行时间产生影响，但是-setTimeout-的影响小一点。所以我们可以使用-setTimeout-来实现倒计时"><a href="#主线程的渲染都会对-setTimeout-和-setInterval-的执行时间产生影响，但是-setTimeout-的影响小一点。所以我们可以使用-setTimeout-来实现倒计时" class="headerlink" title="主线程的渲染都会对 setTimeout 和 setInterval 的执行时间产生影响，但是 setTimeout 的影响小一点。所以我们可以使用 setTimeout 来实现倒计时."></a>主线程的渲染都会对 <code>setTimeout</code> 和 <code>setInterval</code> 的执行时间产生影响，但是 <code>setTimeout</code> 的影响小一点。所以我们可以使用 <code>setTimeout</code> 来实现倒计时.</h4><p>原因 每个 <code>setTimeout</code> 产生的任务会直接 <code>push</code> 到任务队列中；而 <code>setInterval</code> 在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器渲染过程]]></title>
      <url>/2023/06/02/%E9%9D%A2%E7%BB%8F/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<hr>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<hr>
<p>渲染的第一步是<strong>解析 HTML</strong>。</p>
<p>解析过程中遇到 CSS 解析 CSS(浏览器会解析CSS样式表，并将其转换为浏览器可以理解的结构，通常是一个叫做CSSOM（CSS Object Model）的树形结构)，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。<strong>这就是 CSS 不会阻塞 HTML 解析的根本原因。</strong></p>
<p>如果主线程解析到<code>script</code>位置，<strong>会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停</strong>。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM（CSS Object Model） 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中  。</p>
<hr>
<p>渲染的下一步是<strong>样式计算</strong>。 渲染树</p>
<p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<hr>
<p>接下来是<strong>布局</strong>，布局完成后会得到布局树。 布局树</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<hr>
<p>下一步是<strong>分层</strong></p>
<p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p>
<hr>
<p>再下一步是<strong>绘制</strong></p>
<p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<hr>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<hr>
<p>分块完成后，进入<strong>光栅化</strong>阶段。</p>
<p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。GPU加速</p>
<p>光栅化的结果，就是一块一块的位图（合成器帧 像素点的信息） </p>
<p>栅化过程之后，会生成<strong>合成器帧（</strong>compositor frame），这个帧随后会传递给合成器线程。</p>
<p><img src="/../../images/image-20240410123054675.png" alt="image-20240410123054675"></p>
<p><img src="/../../images/image-20240410123437563.png" alt="image-20240410123437563"></p>
<hr>
<p>最后一个阶段就是<strong>画</strong>了</p>
<p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。 相对于屏幕          布局确定的是相对与页面的位置</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<p>合成器线程主要负责将多个图层（layers）合并成一个最终的图像，这些图层可能来自页面的不同部分，或者来自浏览器的UI元素（如滚动条、地址栏等）。合成器线程的工作是独立于主线程（包括JS引擎线程和GUI渲染线程）的，这有助于实现平滑的滚动和动画效果，因为这些操作可以在不阻塞主线程的情况下进行。</p>
<p>合成器线程生成<strong>最终的图像帧</strong>后，这个帧会被传递给GPU进程进行渲染。GPU进程接收合成器帧，并使用GPU硬件加速来执行实际的渲染操作，将像素数据绘制到屏幕上。这个过程发生在浏览器进程的外部，由GPU硬件来执行，因此可以非常高效地处理大量的像素数据。</p>
<h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p>
<h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<p>大概流程</p>
<p>dom树、stylesheet、布局树、分层、光栅化、合成   <strong>标准回答</strong> 浏览器拿到HTML，先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。  加分回答 分层的目的：避免整个页面渲染，把页面分成多个图层，尤其是动画的时候，把动画独立出一个图层，渲染时只渲染该图层就ok，transform，z-index等，浏览器会自动优化生成图层 光栅化目的：页面如果很长但是可视区很小，避免渲染非可视区的样式造成资源浪费，所以将每个图层又划分成多个小个子，当前只渲染可视区附近区域</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于 chrome 119.0.6012.0（正式版本）canary (arm64)</p>
<ol>
<li>阻塞通常发生在 html 解析 和 页面渲染阶段</li>
<li>文档解析时，浏览器会有额外线程找出需要下载的外部资源，提前开始下载，html解析阻塞不 会影响外部资源下载</li>
<li><strong>css，当 link css 放在 head 时，css 的下载不会阻塞 html 的解析，但会阻塞页面的渲染，当 link 放在 body 时，阻塞 html 解析，不阻塞已解析部分的渲染</strong></li>
<li>script，静态script标签的下载和执行阻塞html的解析，但会先渲染已解析部分；script 之前有 link css 时，会等待css下载执行完成再执行</li>
<li>动态创建的script标签不会阻塞html解析，创建完成立即开始下载，下载完成立即执行，执行时阻塞html解析</li>
</ol>
<h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li><p>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</p>
</li>
<li><p>然后对 CSS 进行解析，生成 CSSOM 规则树。</p>
</li>
<li><p>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p>
</li>
<li><p>布局:当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p>
</li>
<li><p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p>
</li>
</ul>
<p>大致过程如图所示：</p>
<p><img src="/../../images/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png" alt="img"></p>
<p><strong>注意：</strong>这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<p>（1）尽量将JavaScript文件放在body的最后</p>
<p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p>
<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
<ul>
<li><p><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</p>
</li>
<li><p><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</p>
</li>
<li><p><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</p>
</li>
</ul>
<p><strong>（2）针对CSS：</strong>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li><p><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</p>
</li>
<li><p><a href=""><strong>@import</strong> </a> ：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</p>
</li>
<li><p><strong>style</strong>：GUI直接渲染</p>
</li>
</ul>
<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p><strong>（3）针对DOM树、CSSOM树：</strong></p>
<p>可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li><p>HTML文件的代码层级尽量不要太深</p>
</li>
<li><p>使用语义化的标签，来避免不标准语义化的特殊处理</p>
</li>
<li><p>减少CSSD代码的层级，因为选择器是从左向右进行解析的</p>
</li>
</ul>
<p><strong>（4）减少回流与重绘：</strong></p>
<ul>
<li><p>操作DOM时，尽量在低层级的DOM节点进行操作</p>
</li>
<li><p>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</p>
</li>
<li><p>使用CSS的表达式</p>
</li>
<li><p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>
</li>
<li><p>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>
</li>
<li><p>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</p>
</li>
<li><p>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p>
</li>
<li><p>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</p>
</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<p>（1）关键资源的数量。</p>
<p>（2）关键路径长度。</p>
<p>（3）关键字节的数量。</p>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<p>（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>
<p>（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>
<p>（3）优化关键字节数以缩短下载时间（往返次数）。</p>
<p>（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h3 id="敲下回车"><a href="#敲下回车" class="headerlink" title="敲下回车"></a>敲下回车</h3><p><img src="/../../images/image-20231229232807428.png" alt="image-20231229232807428"></p>
<p> 输入地址，浏览器查找域名的 IP 地址。 浏览器向 该 IP 地址的web 服务器发送一个 HTTP 请求，在发送请求之前浏览器和服务器建立TCP的三次握手，判断是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求，如果是HTTP协商缓存向后端发送请求且和后端服务器对比，在有效期内，服务器返回304，直接从浏览器获取数据，如果不在有效期内服务器返回200，返回新数据。  请求发送出去服务器返回重定向，浏览器再按照重定向的地址重新发送请求。  如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。  如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。  渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，(进入合成线程)再将图层分成图块，（栅格化线程）图块给栅格化线程 进行栅格化 把图块放入内存gpu  当图块栅格化完成之后   把图块信息（内存中的位置 页面的位置）发给合成器线程   （合成器线程）  利用这些信息 生成合成器帧  通过ipc给浏览器进程 再给gpu进程 渲染展示到屏幕上</p>
<p>1、URL解析：判断浏览器输入的是搜索内容还是URL；2、查找缓存：如果能找到缓存则直接返回页面，如果没有缓存则需要发送网络请求页面；3、DNS域名解析；4、三次握手建立TCP连接；5、发起HTTP请求 看是否有强制缓存和协商缓存；6、服务器响应并返回结果；7、通过四次挥手手释放TCP连接；8、浏览器渲染；9、js引擎解析 … 展开   </p>
<p>一个完整的渲染流程大致可总结为如下：</p>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>
<li>创建render树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
</ol>
<p>栅化过程之后，会生成<strong>合成器帧（</strong>compositor frame），这个帧随后会传递给合成器线程。</p>
<p>合成器线程主要负责将多个图层（layers）合并成一个最终的图像，这些图层可能来自页面的不同部分，或者来自浏览器的UI元素（如滚动条、地址栏等）。合成器线程的工作是独立于主线程（包括JS引擎线程和GUI渲染线程）的，这有助于实现平滑的滚动和动画效果，因为这些操作可以在不阻塞主线程的情况下进行。</p>
<p>合成器线程生成<strong>最终的图像帧</strong>后，这个帧会被传递给GPU进程进行渲染。GPU进程接收合成器帧，并使用GPU硬件加速来执行实际的渲染操作，将像素数据绘制到屏幕上。这个过程发生在浏览器进程的外部，由GPU硬件来执行，因此可以非常高效地处理大量的像素数据。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node编写用户基本信息接口（登陆、注册）]]></title>
      <url>/2023/05/30/nodejs/userinfo/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db/index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入处理密码的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户基本信息的处理函数</span></span><br><span class="line"></span><br><span class="line">*<span class="built_in">exports</span>*.<span class="property">getUserInfo</span> = <span class="function">(<span class="params">*req*, *res*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定义查询用户信息的 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sql = <span class="string">`select id, username, nickname, email, user_pic from ev_users where id=?`</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 调用 db.query() 执行 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> db.<span class="title function_">query</span>(sql, *req*.<span class="property">user</span>.<span class="property">id</span>, <span class="function">(<span class="params">*err*, *results*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*err*) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(*err*)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是查询的结果可能为空</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*results*.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;获取用户信息失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户信息获取成功</span></span><br><span class="line"></span><br><span class="line">  *res*.<span class="title function_">send</span>(&#123;</span><br><span class="line"></span><br><span class="line">   <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">   <span class="attr">message</span>: <span class="string">&#x27;获取用户信息成功！&#x27;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="attr">data</span>: *results*[<span class="number">0</span>],</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户基本信息的处理函数</span></span><br><span class="line"></span><br><span class="line">*<span class="built_in">exports</span>*.<span class="property">updateUserInfo</span> = <span class="function">(<span class="params">*req*, *res*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定义待执行的 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sql = <span class="string">`update ev_users set ? where id=?`</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 调用 db.query() 执行 SQL 语句并传递参数</span></span><br><span class="line"></span><br><span class="line"> db.<span class="title function_">query</span>(sql, [*req*.<span class="property">body</span>, *req*.<span class="property">body</span>.<span class="property">id</span>], <span class="function">(<span class="params">*err*, *results*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*err*) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(*err*)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是影响行数不等于 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*results*.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更新用户的基本信息失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">  *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更新用户信息成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户密码的处理函数</span></span><br><span class="line"></span><br><span class="line">*<span class="built_in">exports</span>*.<span class="property">updatePassword</span> = <span class="function">(<span class="params">*req*, *res*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 根据 id 查询用户的信息</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sql = <span class="string">`select * from ev_users where id=?`</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 执行根据 id 查询用户的信息的 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> db.<span class="title function_">query</span>(sql, *req*.<span class="property">user</span>.<span class="property">id</span>, <span class="function">(<span class="params">*err*, *results*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*err*) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(*err*)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断结果是否存在</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*results*.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;用户不存在！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断密码是否正确</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> compareResult = bcrypt.<span class="title function_">compareSync</span>(*req*.<span class="property">body</span>.<span class="property">oldPwd</span>, *results*[<span class="number">0</span>].<span class="property">password</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!compareResult) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;旧密码错误！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义更新密码的 SQL 语句</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sql = <span class="string">`update ev_users set password=? where id=?`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对新密码进行加密处理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newPwd = bcrypt.<span class="title function_">hashSync</span>(*req*.<span class="property">body</span>.<span class="property">newPwd</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 db.query() 执行 SQL 语句</span></span><br><span class="line"></span><br><span class="line">  db.<span class="title function_">query</span>(sql, [newPwd, *req*.<span class="property">user</span>.<span class="property">id</span>], <span class="function">(<span class="params">*err*, *results*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (*err*) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(*err*)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断影响的行数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (*results*.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更新密码失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">   *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更新密码成功&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户头像的处理函数</span></span><br><span class="line"></span><br><span class="line">*<span class="built_in">exports</span>*.<span class="property">updateAvatar</span> = <span class="function">(<span class="params">*req*, *res*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1. 定义更新头像的 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sql = <span class="string">`update ev_users set user_pic=? where id=?`</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2. 调用 db.query() 执行 SQL 语句</span></span><br><span class="line"></span><br><span class="line"> db.<span class="title function_">query</span>(sql, [*req*.<span class="property">body</span>.<span class="property">avatar</span>, *req*.<span class="property">user</span>.<span class="property">id</span>], <span class="function">(<span class="params">*err*, *results*</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*err*) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(*err*)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 影响的行数是否等于 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*results*.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更换头像失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">  *res*.<span class="title function_">cc</span>(<span class="string">&#x27;更换头像成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p>如果 <code>/api1/login</code> 路径的请求没有触发身份认证，有以下几个可能的原因：</p>
<ol>
<li>中间件的顺序：请确保 <code>expressJWT</code> 中间件的使用在 <code>userRouter</code> 上面。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy Codeapp.use(expressJWT(&#123;secret: config.jwtSecretKey,algorithms: [&#x27;HS256&#x27;]&#125;)</span><br><span class="line">  .unless(&#123; path: [/^\/api2\//, &#x27;/api1/login&#x27;] &#125;));</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api1&#x27;, userRouter);</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[调用百度api]]></title>
      <url>/2023/05/17/%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6api/</url>
      <content type="html"><![CDATA[<p>获取access token</p>
<p><img src="/../images/image-20230517162310623.png" alt="image-20230517162310623"></p>
<p>24.52fc847ab0a12a52281f1571b98a3cad.2592000.1686903722.282335-33656361</p>
<p><a href="https://ai.baidu.com/ai-doc/REFERENCE/Lkru0zoz4">通用参考 - 鉴权认证机制 | 百度AI开放平台 (baidu.com)</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>/2023/05/16/git/</url>
      <content type="html"><![CDATA[<p><img src="/../images/image-20230516162914801.png" alt="image-20230516162914306"></p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><img src="/../images/16b9d385970c7b6ctplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<ul>
<li>本地仓库是对于远程仓库而言的。</li>
<li>本地仓库 &#x3D; 工作区 + 版本区</li>
<li>工作区即磁盘上的文件集合。</li>
<li>版本区(版本库)即<code>.git</code>文件</li>
<li>版本库 &#x3D; 暂存区(stage) + 分支(master) + 指针Head<ul>
<li>以我使用最频繁的git命令为例，即提交到github为例。</li>
<li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li>
<li><code>git add .</code> 表示把工作区的所有文件全部提交到版本区里面的<strong>暂存区</strong></li>
<li>当然你也可以通过 <code>git add ./xxx/</code> 一条一条分批添加到暂存区。</li>
<li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的<strong>所有</strong>文件提交到仓库区，暂存区空空荡荡。</li>
<li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来。</li>
<li><code>git push -u origin master</code> 把仓库区的文件提交到远程仓库里。</li>
<li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。会有这样的信息<code>nothing to commit, working tree clean</code></li>
</ul>
</li>
</ul>
<h1 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h1><p>以前不熟悉git命令的时候，我提交项目到github上都是直接在网页上直接拉取文件提交上去的。有点羞耻。</p>
<p><img src="/../images/16b9c23ee01835cetplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<ol>
<li><code>git init</code> .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个<code>.git</code>文件。</li>
<li><code>git add .</code> 后面的一个点表示把这个文件全部提交到暂存区。</li>
<li><code>git add ./readme.md/</code> 表示把这个文件下面的readme.md文件提交到暂存区。</li>
<li><code>git commit -m &quot;你要评论一点什么东西&quot;</code> <code>git commit</code>的意思是把暂存区的全部文件提交到本地仓库。<code>-m</code>后接评论。</li>
<li><code>git remote add origin https://github.com/name/name_cangku.git</code>表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。<code>name</code>是你的github名字，<code>name_cangku</code>是你的仓库名。<strong>注意</strong>不要把后面的<code>.git</code>给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。</li>
<li><code>git push -u origin master</code> 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。</li>
<li>最后提到的是，在<code>git commit -m &quot;&quot;</code>之前，可以重复<code>git add</code>到暂存区。但是<code>git commit</code>会把你之前存放在暂存区的全部文件<strong>一次性</strong>全部提交到本地仓库。</li>
</ol>
<h1 id="版本的回溯与前进"><a href="#版本的回溯与前进" class="headerlink" title="版本的回溯与前进"></a>版本的回溯与前进</h1><p>提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，Git会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用<code>git reset --hard + 版本号</code>即可。 版本号可以用<code>git log</code>来查看，每一次的版本都会产生不一样的版本号。回溯之后，<code>git log</code>查看一下发现离我们最近的那个版本已经不见了。但是我还想要前进到最近的版本应该如何？只要<code>git reset --hard + 版本号</code>就行。退一步来讲，虽然我们可以通过<code>git reset --hard + 版本号</code>,靠记住版本号来可以在不同的版本之间来回穿梭。<strong>但是</strong>,有时候把版本号弄丢了怎么办？<code>git reflog</code>帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过<code>git reset</code>来版本穿梭了。</p>
<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><ul>
<li>场景1：在工作区时，你修改了一个东西，你想撤销修改，<code>git checkout -- file</code>。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本替换工作区的版本。</li>
<li>场景2：你修改了一个内容，并且已经<code>git add</code>到暂存区了。想撤销怎么办？回溯版本，<code>git reset --hard + 版本号</code>,再<code>git checkout -- file</code>,替换工作区的版本。</li>
<li>场景3：你修改了一个内容，并且已经<code>git commit</code>到了<code>master</code>。跟场景2一样，版本回溯，再进行撤销。</li>
</ul>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul>
<li>如果你<code>git add</code>一个文件到暂存区，然后在工作区又把文件删除了，Git会知道你删除了文件。如果你要把版本库里的文件删除，<code>git rm</code> 并且<code>git commit -m &quot;xxx&quot;</code>.</li>
<li>如果你误删了工作区的文件，怎么办？使用撤销命令，<code>git checkout --&lt;file&gt;</code>就可以。<strong>这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></li>
</ul>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p><img src="/../images/16b9e012079c4724tplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<p>在没有其他分支插进来时，只有一个master主分支。每次你<code>git push -u origin master</code> 提交就是增加一条时间轴，master也会跟着移动。</p>
<p><img src="/../images/16b9e11b1115072btplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<p>创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支master还在原来的位置。</p>
<p><img src="/../images/16b9e1ce1d3c3b03tplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<p>理论分析完，看一下命令怎么写。</p>
<ul>
<li>创建分支<code>other</code>,切换到<code>other</code>分支。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch other</span><br><span class="line">git checkout other</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前所有分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* other</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p>当前的分支会有一个<code>*</code></p>
<ul>
<li>用<code>other</code>提交</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./xxx/</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>other</code>分支完成，切换回<code>master</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<ul>
<li>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</li>
<li><strong>合并分支</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge other</span><br></pre></td></tr></table></figure>

<ul>
<li>合并完成之后，就可以在master分支上查看到文件了。</li>
<li>删除<code>other</code>分支。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d other</span><br></pre></td></tr></table></figure>

<ul>
<li>我由此想到，在以后工作中，应该是一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组长合并一下完成了的分支。哦，完美！</li>
</ul>
<h2 id="解决合并分支问题"><a href="#解决合并分支问题" class="headerlink" title="解决合并分支问题"></a>解决合并分支问题</h2><p><img src="/../images/16ba102bd434afc6tplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<p>假如有这样一种情况，分支<code>other</code>已经<code>commit</code>了，<strong>但是</strong>此时指针指回<code>master</code>时，并且<code>master</code>没有合并，而是<code>git add / commit</code> 提交了。这样，就产生了冲突，主分支<code>master</code>文件内容与<code>other</code>分支的内容不一样。合并不起来！所以，</p>
<ul>
<li><p>修改文件的内容，让其保持一致。</p>
</li>
<li><p><code>git add</code> <code>git commit</code> 提交。</p>
</li>
<li><p>分支合并了。</p>
<p><img src="/../images/16ba11a0ba73803dtplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
</li>
<li><p><code>git log --graph</code> 查看分支合并图</p>
</li>
<li><p><code>git branch -d other</code> 删除分支，任务结束。</p>
</li>
</ul>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul>
<li><code>git merge --no-ff other</code> 禁用<code>Fast forward</code>模式，因为使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失。</li>
</ul>
<h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><blockquote>
<p>廖雪峰老师提到，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，<code>git stash</code>,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，<code>git checkout other</code>回到自己的分支。用<code>git stash list</code>查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作：</p>
</blockquote>
<ul>
<li><code>git stash apply</code>恢复却不删除<code>stash</code>内容，<code>git stash drop</code>删除<code>stash</code>内容。</li>
<li><code>git stash pop</code>恢复的同时把stash内容也删了.</li>
<li>此时，用<code>git stash list</code>查看，看不到任何<code>stash</code> 内容。<br> <strong>总结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</strong></li>
</ul>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul>
<li><code>git branch -d + 分支</code>有可能会删除失败，因为Git会保护没有被合并的分支。</li>
<li><code>git branch -D + 分支</code> 强行删除，丢弃没被合并的分支。</li>
</ul>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ul>
<li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li>
<li><code>git remote -v</code>显示更详细的信息</li>
<li><code>git push -u origin master</code>推送<code>master</code>分支到<code>origin</code>远程仓库。</li>
<li><code>git push -u origin other</code> 推送<code>other</code>到<code>origin</code>远程仓库。</li>
</ul>
<h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><p><img src="/../images/16ba20c43f386f7ctplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p>
<p>产生上图的冲突时，</p>
<ul>
<li><p><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。在进行<code>git pull</code></p>
</li>
<li><p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p> 也失败了，还要指定分支之间的链接，这一步Git会提醒你怎么做。然后再</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>。</p>
<blockquote>
<p><strong>廖雪峰老师的总结：多人协作的工作模式通常是这样：</strong></p>
</blockquote>
<ul>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新不匹配（其他开发者修改 或者push 的版本号不匹配），需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li>
</ul>
<h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2></li>
<li><p><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观.缺点是本地的分叉提交已经被修改过了。</p>
</li>
<li><p>最后在进行<code>git push -u origin master</code></p>
</li>
<li><p><code>rebase</code>的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote>
<p>比如一个APP要上线，通常在版本库中打一个标签(tag), 这样，就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br> Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。<br> <code>tag</code>其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如<code>tag v2.1</code>就是把历史上的一个版本的东西叫做<code>v2.1</code></p>
</blockquote>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>步骤：</p>
<ul>
<li><code>git branch</code>查看当前分支,<code>git checkout master</code>切换到<code>master</code>分支。</li>
<li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li>
<li>默认标签是打在最新提交的<code>commit</code>上的。如果想要打标签在以前的<code>commit</code>上，要<code>git log</code>找到历史提交的<code>commit</code> id.</li>
<li>如果一个<code>commt id</code>是<code>du2n2d9</code>,执行<code>git tag v1.0 du2n2d9</code>就把这个版本打上了<code>v1.0</code>的标签了。</li>
<li><code>git tag</code> 查看所有标签，可以知道历史版本的<code>tag</code></li>
<li>标签不是按时间顺序列出，而是按字母排序的。</li>
<li><code>git show &lt;tagname&gt;</code> 查看标签信息。</li>
<li><code>git tag -a &lt;标签名&gt; -m &quot;&lt;说明&gt;&quot;</code>,创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字。用<code>show</code>可以查看说明。</li>
</ul>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ul>
<li><code>git tag -d v1.0</code> 删除标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</li>
<li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li>
<li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li>
<li>如果标签推送到远程。<code>git tag -d v1.0</code> 先删除本地标签v1.0。<code>git push origin :refs/tags/v1.0</code>删除远程标签v1.0</li>
</ul>
<h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><ul>
<li><p><code>git config --global color.ui true</code>让Git显示颜色，会让命令输出看起来更醒目</p>
</li>
<li><p>忽略特殊文件 创建一个<code>.gitignore</code>文件，把需要忽略的文件名填进去。Git就会自动忽略这些文件。我也在学习中遇到过这样的问题，比如<code>node_modules</code>文件就可以忽略。</p>
</li>
<li><blockquote>
<p>忽略文件原则：忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p>
</blockquote>
</li>
<li><p>强制提交已忽略的的文件。<code>git add -f &lt;file&gt;</code></p>
</li>
<li><p><code>git check-ignore -v &lt;file&gt;</code>检查为什么Git会忽略该文件。</p>
</li>
<li><p><strong>给Git命令配别名</strong>,这个有点骚，就是你以后想输入<code>git rebase</code>时,你给它一个“外号”，就叫它<code>git nb</code>。以后你可以通过<code>git nb</code>来代替<code>git rebase</code>。具体怎么转换可以去<a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">廖雪峰老师的网站</a>看。因为水平有限，我觉得先把正常的Git命令搞清楚来就很不错了。</p>
</li>
</ul>
<h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1><ul>
<li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li>
<li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li>
<li><code>git init</code> 初始化你的仓库</li>
<li><code>git add .</code> 把工作区的文件全部提交到暂存区</li>
<li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li>
<li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li>
<li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li>
<li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li>
<li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li>
<li><code>git status</code>查看当前仓库的状态</li>
<li><code>git diff</code> 查看文件修改的具体内容</li>
<li><code>git log</code> 显示从最近到最远的提交历史</li>
<li><code>git clone + 仓库地址</code>下载克隆文件</li>
<li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li>
<li><code>git reflog</code> 显示命令历史</li>
<li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li>
<li><code>git rm</code> 删除版本库的文件</li>
<li><code>git branch</code> 查看当前所有分支</li>
<li><code>git branch &lt;分支名字&gt;</code> 创建分支</li>
<li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li>
<li><code>git merge &lt;分支名字&gt;</code> 合并分支</li>
<li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li>
<li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li>
<li><code>git log --graph</code> 查看分支合并图</li>
<li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li>
<li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li>
<li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li>
<li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li>
<li><code>git stash drop</code> 删除<code>stash</code>内容</li>
<li><code>git stash pop</code> 恢复的同时把stash内容也删了</li>
<li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li>
<li><code>git remote -v</code> 显示更详细的信息</li>
<li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li>
<li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li>
<li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li>
<li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li>
<li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li>
<li><code>git show &lt;tagName&gt;</code> 查看标签信息</li>
<li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li>
<li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li>
<li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li>
<li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li>
<li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li>
<li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li>
<li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li>
<li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件</li>
</ul>
<h2 id="2-push远程后-如何撤销"><a href="#2-push远程后-如何撤销" class="headerlink" title="2 push远程后 如何撤销"></a>2 push远程后 如何撤销</h2><p> 1）使用<code>git log</code>找到commit的版本号；</p>
<p>2）<code>git reset --hard &lt;版本号&gt;</code>，撤回本地到需要的版本;</p>
<p>3）<code>git push</code>重新提交会报错；落后于远程版本</p>
<p>4）使用<code>git push --force</code></p>
<p>如果你在本地修改了与远程仓库相同的文件，并且这些文件也在远程仓库中被修改过，那么在执行 <code>git pull</code> 时可能会出现合并冲突，需要手动解决这些冲突。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[异步的理解]]></title>
      <url>/2023/05/16/%E9%9D%A2%E7%BB%8F/%E5%BC%82%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20230516131731497.png" alt="image-20230516131731497"></p>
<h3 id="watcheffect的异步问题"><a href="#watcheffect的异步问题" class="headerlink" title="watcheffect的异步问题"></a>watcheffect的异步问题</h3><p><a href="https://juejin.cn/post/7310786618391265317?searchId=2024012513544494A7395B5D4564820312">watchEffect 中的异步问题 - 掘金 (juejin.cn)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">watchEffect(async () =&gt; &#123;</span><br><span class="line">  // 远程去获取 url 地址</span><br><span class="line">  url.value = await fetchVideoUrl();</span><br><span class="line">  // 通过 video 的 ref，拿到 video，设置倍率</span><br><span class="line">  videoRef.value.playbackRate = speed.value;</span><br><span class="line">  // 用于检查 watchEffect 执行</span><br><span class="line">  console.log(&#x27;0&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Vue watchEffect 是一个用于追踪响应式依赖的函数。</p>
<p>它可以让你在一个函数中使用响应式的数据，例如 ref 或 reactive 创建的对象，然后当这些数据变化时，自动重新执行这个函数。</p>
<p>它相当于将watch的依赖源和回调函数合并，不需要指定具体要观察的数据。</p>
<p>其实问题就在于 watchEffect <strong>只能收集同步代码的依赖</strong>，如果 watchEffect 中有异步代码，当遇到异步时就会停止依赖的收集。</p>
<p>套用到我们的代码中来说，就是你运行 watchEffect 就会立即运行它包含的函数，但是代码中 <code>url.value = await fetchVideoUrl();</code> 是异步代码且在第一行，所以 watchEffect 并没有收集到任何依赖。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node处理跨域]]></title>
      <url>/2023/03/26/es6/call/</url>
      <content type="html"><![CDATA[<h2 id="本节介绍"><a href="#本节介绍" class="headerlink" title="本节介绍"></a>本节介绍</h2><p>本节是“实现 <code>call</code> 函数”这道题的讲解，在面试场景中，光是能说清楚 <code>this</code> 的指向是不够的，面试官很喜欢考查 <code>call</code>、<code>apply</code> 和 <code>bind</code> 这三个函数的用法和原理，本节我们就先从 <code>call</code> 这个函数开始学起，在讲解 <code>call</code> 函数的原理的同时，也会介绍一些它的常用使用场景。</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>call 原理</li>
<li>call 使用场景</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在讲解之前，先给出本题的答案，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCall</span>(<span class="params">fn, context = <span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  context.<span class="property">fn</span> = fn;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h2><p>在尝试去实现 <code>call</code> 函数之前，我们再来回顾一下它的用法，<code>call</code> 函数是为了改变 <code>this</code> 的指向，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">userName</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(); <span class="comment">// 直接调用，this 指向 window，输出 &#x27;xxx&#x27;</span></span><br><span class="line">fn.<span class="title function_">call</span>(person); <span class="comment">// 用 call，this 指向 person，输出 &#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>call</code> 是写到 <code>Function.prototype</code> 上的方法，而本节我们要实现的 <code>myCall</code> 是把函数当作参数传递进去，两者只是调用形式不同，原理都是一样的。</p>
<p>我们尝试来实现一下显式改变 <code>this</code> 指向的功能，调用对象中的函数，<code>this</code> 指向为这个对象，所以我们需要做的操作是：</p>
<ul>
<li>把函数 <code>fn</code> 挂载到要指向的对象 <code>context</code> 上。</li>
<li>执行 <code>context.fn</code>，执行完了删除 <code>context</code> 上的 <code>fn</code> 函数，避免对传入对象的属性造成污染。</li>
</ul>
<p>代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCall</span>(<span class="params">fn, context</span>) &#123;</span><br><span class="line">  <span class="comment">// 把函数 fn 挂载到对象 context 上。</span></span><br><span class="line">  context.<span class="property">fn</span> = fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 context.fn</span></span><br><span class="line">  context.<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行完了删除 context 上的 fn 函数，避免对传入对象的属性造成污染。</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">userName</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myCall</span>(fn, person); <span class="comment">// 输出 &#x27;zhangsan&#x27;</span></span><br><span class="line"><span class="title function_">myCall</span>(fn, <span class="variable language_">window</span>); <span class="comment">// 输出 &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，仅仅三行代码，我们就实现了 <code>call</code> 函数的核心功能。</p>
<p>不过这里面有一些其他细节需要处理，比如：</p>
<ul>
<li>要处理 <code>context</code> 不传值的情况，传一个默认值 <code>window</code>。</li>
<li>处理函数 <code>fn</code> 的参数，执行 <code>fn</code> 函数时把参数携带进去。</li>
<li>获取执行函数 <code>fn</code> 产生的返回值，最终返回这个返回值。</li>
</ul>
<p>最终实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要处理 context 不传值的情况，传一个默认值 window。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCall</span>(<span class="params">fn, context = <span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  context.<span class="property">fn</span> = fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理函数 fn 的参数，执行 fn 函数时把参数携带进去。</span></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取执行函数 fn 产生的返回值。</span></span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终返回这个返回值</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span> + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myCall</span>(fn, obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 执行函数 fn，输出 16</span></span><br></pre></td></tr></table></figure>

<p>这样我们就实现了 <code>call</code> 函数该有的功能，原生的 <code>call</code> 函数是写到 <code>Function.prototype</code> 上的方法，我们也尝试在函数的原型上实现一个 <code>myCall</code> 函数，只需稍加改造即可，代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写到函数的原型上，就不需要把要执行的函数当作参数传递进去</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的 this 就是这个要执行的函数</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 参数少了一个，slice(2) 改为 slice(1)</span></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span> + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">myCall</span>(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 执行函数 fn，输出 16</span></span><br></pre></td></tr></table></figure>

<h2 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h2><h3 id="处理边缘情况"><a href="#处理边缘情况" class="headerlink" title="处理边缘情况"></a>处理边缘情况</h3><p>上文在函数原型上实现的 <code>myCall</code> 函数，还有优化的空间，有一些边缘的情况，可能会导致报错，比如把要指向的对象指向一个原始值，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="title function_">myCall</span>(<span class="number">0</span>); <span class="comment">// Uncaught TypeError: context.fn is not a function</span></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/1bef7f4d353b7932d9abe6a9d8048bd2-0.jpeg" alt="图片描述"></p>
<p>这时，就需要参考一下原生的 <code>call</code> 函数是如何解决的这个问题，我们打印出来看一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(type, <span class="string">&quot;-&gt;&quot;</span>, <span class="variable language_">this</span>.<span class="property">userName</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="number">0</span>, <span class="string">&quot;number&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="number">1n</span>, <span class="string">&quot;bigint&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">false</span>, <span class="string">&quot;boolean&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;string&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(a, <span class="string">&quot;symbol&quot;</span>);</span><br><span class="line">fn.<span class="title function_">call</span>([], <span class="string">&quot;引用类型&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/4f2155870f923a15f650f61f0abd4229-0.jpeg" alt="图片描述"></p>
<p>可以看到，<code>undefined</code> 和 <code>null</code> 指向了 <code>window</code>，原始类型和引用类型都是 <code>undefined</code>。</p>
<p>其实是因为，原始类型指向对应的包装类型，引用类型就指向这个引用类型，之所以输出值都是 <code>undefined</code>，是因为这些对象上都没有 <code>userName</code> 属性。</p>
<p>改造一下我们的 <code>myCall</code> 函数，实现原始类型的兼容，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="variable language_">window</span>; <span class="comment">// undefined 和 null 指向 window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="title class_">Object</span>(context); <span class="comment">// 原始类型就包装一下</span></span><br><span class="line">  &#125;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有另外一种边缘情况，假设对象上本来就有一个 <code>fn</code> 属性，执行下面的调用，对象上的 <code>fn</code> 属性会被删除，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">userName</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">myCall</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">fn</span>); <span class="comment">// 输出 undefined，本来应该输出 123</span></span><br></pre></td></tr></table></figure>

<p>因为对象上本来的 <code>fn</code> 属性和 <code>myCall</code> 函数内部临时定义的 <code>fn</code> 属性重名了。</p>
<p>还记得 <code>Symbol</code> 的作用吗，可以用 <code>Symbol</code> 来防止对象属性名冲突问题，继续改造 <code>myCall</code> 函数，代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context = <span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="variable language_">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="title class_">Object</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&quot;fn&quot;</span>); <span class="comment">// 用 symbol 处理一下</span></span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> res = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，一个功能尽可能完善的 <code>myCall</code> 函数，终于写完了。</p>
<h3 id="call-使用场景"><a href="#call-使用场景" class="headerlink" title="call 使用场景"></a>call 使用场景</h3><p><code>call</code> 的使用场景非常多，所有调用 <code>call</code> 的使用场景都是为了显式地改变 <code>this</code> 的指向，能用 <code>call</code> 解决的问题也能用 <code>apply</code> 解决，因为它们俩只是传参形式不同。下面一起来看 <code>call</code> 常用的四个使用场景。</p>
<h4 id="1-精准判断一个数据类型"><a href="#1-精准判断一个数据类型" class="headerlink" title="1.精准判断一个数据类型"></a>1.精准判断一个数据类型</h4><p>精准地判断一个数据的类型，可以用到 <code>Object.prototype.toString.call(xxx)</code>。</p>
<p>调用该方法，统一返回格式 <code>[object Xxx]</code> 的字符串，用来表示该对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)); <span class="comment">// &quot;[object Function]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>)); <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())); <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Error</span>())); <span class="comment">// &#x27;[object Error]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])); <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Map</span>())); <span class="comment">// &#x27;[object Map]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Set</span>())); <span class="comment">// &#x27;[object Set]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakMap</span>())); <span class="comment">// &#x27;[object WeakMap]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakSet</span>())); <span class="comment">// &#x27;[object WeakSet]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)); <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1n</span>)); <span class="comment">// &#x27;[object BigInt]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)); <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>))); <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里需要调用 <code>call</code> 就是为了显式地改变 <code>this</code> 指向为我们的目标变量。</p>
<p>如果不改变 <code>this</code> 指向为我们的目标变量 <code>xxx</code>，<code>this</code> 将永远指向调用的 <code>Object.prototype</code>，也就是原型对象，对原型对象调用 <code>toString</code> 方法，结果永远都是 <code>[object Object]</code>，如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>([]); <span class="comment">// 输出 &#x27;[object Object]&#x27;  不调用 call，this 指向 Object.prototype，判断类型为 Object。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// 输出 &#x27;[object Array]&#x27;   调用 call，this 指向 []，判断类型为 Array</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(<span class="number">1</span>); <span class="comment">// 输出 &#x27;[object Object]&#x27; 不调用 call，this 指向 Object.prototype，判断类型为 Object。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>); <span class="comment">// 输出 &#x27;[object Number]&#x27; 调用 call，this 指向包装对象 Number &#123;1&#125;，判断类型为 Number</span></span><br></pre></td></tr></table></figure>

<h4 id="2-伪数组转数组"><a href="#2-伪数组转数组" class="headerlink" title="2.伪数组转数组"></a>2.伪数组转数组</h4><p>伪数组转数组，在 es6 之前，可以使用 <code>Array.prototype.slice.call(xxx)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 也可以这么写 const args = [].slice.call(arguments)</span></span><br><span class="line">  args.<span class="title function_">push</span>(<span class="number">1</span>); <span class="comment">// 可以使用数组上的方法了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>原理同精准判断一个数据类型相同，如果不改变 <code>this</code> 指向为目标伪数组，<code>this</code> 将永远指向调用的 <code>Array.prototype</code>，就不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 slice 方法原理理解为什么要调用 call</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span> = <span class="keyword">function</span> (<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  start = start || <span class="number">0</span>;</span><br><span class="line">  end = end || <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]); <span class="comment">// 这里的 this 就是伪数组，所以要调用 call</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-ES5-实现继承"><a href="#3-ES5-实现继承" class="headerlink" title="3.ES5 实现继承"></a>3.ES5 实现继承</h4><p>在一个子构造函数中，你可以通过调用父构造函数的 <code>call</code> 方法来实现继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码示例中，构造函数 <code>Student</code> 中会拥有构造函数 <code>Person</code> 中的 <code>name</code> 属性，<code>grade</code> 属性是 <code>Student</code> 自己的。</p>
<p>这里的代码如果换成 ES6 的，就等价于下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>关于继承，同学们掌握 ES6 的实现方式就好，ES5 的做了解即可，因为现在大家基本上都用 ES6 的写法了，如果想对 ES5 的继承有深入研究，可以去看一下《JavaScript 高级程序设计（第 4 版）》原型和原型链相关的章节。</p>
<h4 id="4-处理回调函数-this-丢失问题"><a href="#4-处理回调函数-this-丢失问题" class="headerlink" title="4.处理回调函数 this 丢失问题"></a>4.处理回调函数 this 丢失问题</h4><p>执行下面的代码，回调函数会导致 <code>this</code> 丢失。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">userName</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayName</span>(); <span class="comment">// 输出 &#x27;zhangsan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(obj.<span class="property">sayName</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure>

<p>导致这样现象的原因是回调函数执行的时候 <code>this</code> 指向已经是 <code>window</code> 了，所以输出 <code>undefined</code>。</p>
<p>可以使用 <code>call</code> 改变 <code>this</code> 指向，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">userName</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayName</span>(); <span class="comment">// 输出 &#x27;zhangsan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">callback, context</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义一个 context 参数，可以把上下文传进去</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    callback.<span class="title function_">call</span>(context); <span class="comment">// 显式改变 this 值，指向传入的 context</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(obj.<span class="property">sayName</span>, obj); <span class="comment">// 输出 &#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h2><p>本节我们介绍了 <code>call</code> 函数的实现原理，最关键的点就是要显式地改变 <code>this</code> 的指向，其余全部都是在处理一些边界情况。</p>
<p>在知识延伸部分，我们介绍了 <code>call</code> 函数一些常用的使用场景，所有调用 <code>call</code> 的使用场景还是为了显式地改变 <code>this</code> 的指向。</p>
<p>需要注意的是，能用 <code>call</code> 解决的问题也能用 <code>apply</code> 解决，因为它们俩只是传参形式不同。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[slice在回溯中的影响  思考]]></title>
      <url>/2023/03/24/es6/js%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%AD%20slice%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      <content type="html"><![CDATA[<p>20 js的递归中给结果数组加入 要用current .slice() 而不能用current  </p>
<p><img src="/../../images/image-20230324185522807.png" alt="image-20230324185522807"></p>
<p>在使用回溯算法进行组合或排列时，我们通常需要创建和操作当前组合或排列的数组。由于 JavaScript 中数组是引用类型，这意味着在进行组合或排列过程中，如果直接对当前组合或排列的数ssssss合或排列的结果。</p>
<p>例如，在找到一个由输入数组 <code>arr</code> 中所有顺序相关元素的组合时，我们通常会定义一个回溯函数，将当前组合作为参数传入函数，并在函数中进行组合或排列。在这种情况下，我们需要在回溯函数中使用的新组合数组，由于需要作为参数传入函数，因此不能直接拷贝当前组合数组（<strong>因为这将使当前组合的任何变化都反映在已经存储的组合数组上</strong>），而是应该使用 <code>arr.slice()</code> 创建一个新数组，并对新数组进行操作。这样，对新数组的所有更改都不会反映在已经存储的组合数组中，保证了最终的结果的正确性。</p>
<p>举例：</p>
<p>`&#96;&#96;javascript<br>function findAllCombinations(arr, start, end, current, result) {<br>  if (current.length &gt; 0) {<br>    <strong>result.push(current.slice());</strong> &#x2F;&#x2F; 将当前组合加入结果<br>  }</p>
<p>  for (let i &#x3D; start; i &lt;&#x3D; end; i++) {<br>    current.push(arr[i]);<br>    findAllCombinations(arr, i + 1, end, current.slice(), result); &#x2F;&#x2F; 递归到下一个元素，并使用当前组合的副本<br>    current.pop();<br>  }<br>}</p>
<p>const arr &#x3D; [1, 2, 3];<br>const result &#x3D; [];</p>
<p>findAllCombinations(arr, 0, arr.length - 1, [], result);</p>
<p>console.log(result); &#x2F;&#x2F; 输出 [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]<br>`&#96;&#96;</p>
<p>在上面的代码中，我们定义了一个查找 <code>arr</code> 数组中所有组合的函数 <code>findAllCombinations</code>。函数定义了5个参数，其中两个是结果变量，其他三个是对组合进行操作的参数。</p>
<p>在函数的核心循环中，我们将 <code>current</code> 数组的拷贝传递给函数，以避免在使用 <code>current</code> 进行操作时更改原始组合数组。比如，我们递归调用 <code>findAllCombinations</code> 函数时传递的组合数组就要使用 <code>current.slice()</code> 而不是 <code>current</code>。 最后，函数将所有组合存储在 <code>result</code> 数组中，并在函数结束后返回该数组。</p>
<p>这样，就可以确保不会因为直接更改已经存储的组合数据而导致寻找不完整或重复的组合。</p>
<h4 id="不拷贝arr的副本-直接将数组加入结果中发生的影响"><a href="#不拷贝arr的副本-直接将数组加入结果中发生的影响" class="headerlink" title="不拷贝arr的副本  直接将数组加入结果中发生的影响"></a>不拷贝arr的副本  直接将数组加入结果中发生的影响</h4><p> 如果您不使用 <code>arr.slice()</code>，而是直接将 <code>arr</code> 作为当前组合进行操作并将其添加到结果数组中，可能会对结果产生意外的影响。我们可以看一下下面的示例代码：</p>
<p>`&#96;&#96;javascript<br>function findAllCombinations(arr, start, end, current, result) {<br> if (current.length &gt; 0) {<br>  result.push(current); &#x2F;&#x2F; <strong>将当前组合加入结果，这里不使用 arr.slice()</strong><br> }</p>
<p> for (let i &#x3D; start; i &lt;&#x3D; end; i++) {<br>  current.push(arr[i]);<br>  findAllCombinations(arr, i + 1, end, current, result);<br>  current.pop();<br> }<br>}</p>
<p>const arr &#x3D; [1, 2, 3];<br>const result &#x3D; [];</p>
<p>findAllCombinations(arr, 0, arr.length - 1, [], result);</p>
<p>console.log(result); &#x2F;&#x2F; 输出 [[], [1], [1, 2], [1, 2, 3], [1, 2], [1, 3], [1, 3], [2], [2, 3], [2], [3], [3]]<br>`&#96;&#96;</p>
<p>在上面的代码中，我们定义了一个查找 <code>arr</code> 数组中所有组合的函数 <code>findAllCombinations</code>，其中对于已经生成的组合数组没有使用 <code>arr.slice()</code>。这意味着在这里我们直接将 <code>current</code> 数组添加到结果数组中，而不是添加它的拷贝。由于数组是引用类型，这可能导致我们改变 <code>current</code> 数组进而产生一些奇怪的结果。</p>
<p>输出结果表明，在组合中添加一个元素之后，组合数组的其他部分也被莫名其妙地更改了。这是因为 <code>current</code> 数组直接被添加到了结果数组中，而不是 <code>arr.slice()</code> 的拷贝，所以添加新元素时，也添加并更改了已经存储在结果数组中的组合数组。</p>
<p>在使用回溯算法时，为了避免出现这种错误，通常会使用 <code>arr.slice()</code> 创建一个当前组合的副本，以确保在添加新元素时不会改变原始组合数据。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[linux的vim操作]]></title>
      <url>/2023/03/11/linux/vim/</url>
      <content type="html"><![CDATA[<p>inux编辑器-vim使用<br>Linux操作系统下常用的编辑器之一,类似的工具还有nano等~</p>
<p> vim是多模式编辑器，在此之前的版本是vi；vim是vi的升级版本，它不仅兼容了vi的所有指令，而且还加入了一些新的特新，如语法高亮等。</p>
<p>vim的基本概念<br>vim常用的三种模式，分别是命令行模式（Command mode）、插入模式（Insert mode）和底行模式（Last line mode），各模式的功能区分如下：</p>
<p>正常&#x2F;普通&#x2F;命令模式（Normal mode）<br>         控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到Last line mode</p>
<p>插入模式（Insert mode）<br>        只有在Insert mode下，才可以做文字输入，按[ESC]键可回到命令行模式，该模式是我们用到的最频繁的模式</p>
<p>末行模式（Last line mode）<br>        文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。在命令模式下，shift + ：即可进入该模式。</p>
<p>要查看你的所有模式：打开vim，底行模式直接输入  help vim-modes 命令即可！</p>
<p>vim的基本操作<br>进入vim，在系统提示符输入vim及文件名称后，就进入vim全屏幕编辑画面<br>        $ vim  test.c</p>
<p>要注意的是，在进入vim之后，是处于正常模式之中！</p>
<p>正常模式切换至插入模式<br>输入 a<br>输入 i<br>输入 o<br>插入模式切换至正常模式<br>        键盘输入[ESC]键即可转到正常模式</p>
<p>正常模式切换至末行模式<br>        [shift + ;],其实就是输入[:]</p>
<p>从底行模式下，退出vim及保存文件<br>：w （保存当前文件）<br>：wq （保存文件并退出vim）<br>：q！（强制退出vim，不保存文件）</p>
<p>标题 vim三种模式之间的转换<br>vim正常模式命令集<br>插入模式<br>按 i 切换进入插入模式 insert mode ，按“i”进入插入模式后是从光标当前位置开始输入文件；<br>按 a 进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；<br>按 o 进入插入模式后，是插入新的一行，从行首开始输入文字。</p>
<p>从插入模式切换为命令模式<br>按[ESC]键<br>移动光标<br>vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母 h 、 j 、 k 、 l ，分别控制光标左、下、上、右移一格<br>按 G ：移动到文章的最后<br>按  $  ：移动到光标所在行的“行尾”<br>按 ^ ：移动到光标所在行的“行首”<br>按 w ：光标跳到下个字的开头<br>按 e ：光标跳到下个字的字尾<br>按 b ：光标回到上个字的开头<br>按 #l ：光标移到该行的第#个位置，如：5l,56l<br>按 gg ：进入到文本开始<br>按  shift＋g ：进入文本末端<br>按 ctrl  + b ：屏幕往“后”移动一页<br>按 ctrl +  f ：屏幕往“前”移动一页<br>按 ctrl +  u ：屏幕往“后”移动半页<br>按  ctrl + d：屏幕往“前”移动半页<br>删除文字<br> x ：每按一次，删除光标所在位置的一个字符<br> #x ：例如， 6x 表示删除光标所在位置的“后面（包含自己在内）”6个字符<br> X ：大写的X，每按一次，删除光标所在位置的“前面”一个字符<br> #X ：例如， 20X 表示删除光标所在位置的“前面”20个字符<br> dd ：删除光标所在行<br> #dd ：从光标所在行开始删除#行<br>复制<br> yw ：将光标所在之处到字尾的字符复制到缓冲区中。<br> #yw ：复制#个字到缓冲区<br> yy ：复制光标所在行到缓冲区。<br> #yy ：例如， 6yy 表示拷贝从光标所在的该行“往下数”6行文字。<br> p：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。<br>替换<br> r：替换光标所在处的字符。<br> R ：替换光标所到之处的字符，直到按下[ESC]键为止。<br>撤销上一次操作<br> u ：如果您误执行一个命令，可以马上按下 u ，回到上一个操作。按多次“u”可以执行多次恢复。<br> ctrl + r : 撤销的恢复<br>更改<br> cw ：更改光标所在处的字到字尾处<br> c#w：例如， c3w 表示更改3个字<br>跳至指定的行<br>ctrl + g  列出光标所在行的行号。<br>#G ：例如，15G ，表示移动光标至文章的第15行行首。<br>vim末行模式命令集<br>在使用末行模式之前，请记住先按[ESC]键确定已处在正常模式，再按[:]冒号即可进入末行模式。</p>
<p><strong>列出行号</strong><br>        <strong>set nu ： 输入 set nu 后，会在文件中的每一行前面列出行号</strong></p>
<p><strong>跳到文件中的某一行</strong></p>
<p>： # 号表示一个数字，再冒号后输入一个数字，再按回车键就会跳到该行</p>
<p>查找字符<br> &#x2F;关键字 : 先按 &#x2F; 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 n 会往后寻找到您要的关键字为止。<br> ?关键字 ：先按 ? 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 n 会往前寻找到您要的关键字为止。<br>保存文件<br>        w : 在冒号输入字母 w 就可以将文件保存起来</p>
<p>离开vim<br> q ：按 q 就是退出，如果无法离开vim，可以在 q 后跟一个 ! 强制离开vim。<br> wq ：一般建议离开时，搭配 w 一起使用，这样在退出的时候还可以保存文件。<br>简单vim配置<br>配置文件的位置<br>在目录 &#x2F;etc&#x2F; 下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效。<br>而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：“.vimrc”。例如，&#x2F;root目录下，通常已经存在一个.vimrc文件,如果不存在，则创建之。<br>切换用户成为自己执行 su ，进入自己的主工作目录,执行 cd ~<br>打开自己目录下的.vimrc文件，执行 vim .vimrc<br>常用配置选项<br>设置语法高亮： syntax on<br>显示行号： set  nu<br>设置缩进的空格数为4： set shiftwidth &#x3D; 4</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[echart的使用（省份地图下砖）]]></title>
      <url>/2023/03/02/%E5%BA%93/echart/</url>
      <content type="html"><![CDATA[<p>全局引入</p>
<p>import  echarts from ‘echarts’;</p>
<p>Vue.prototype.$echarts &#x3D; <em>echarts</em>;</p>
<p>Vue.use(<em>echarts</em>)</p>
<p><a href="https://juejin.cn/post/6981452258579841037">vue2 vue3中使用Echarts - 掘金 (juejin.cn)</a></p>
<p><a href="https://blog.csdn.net/Twinkle_sone/article/details/123958183?ops_request_misc=%7B%22request_id%22:%22167774407616800182195992%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167774407616800182195992&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123958183-null-null.142%5Ev73%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=vueecharts%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE%E4%B8%8B%E9%92%BB&spm=1018.2226.3001.4187">(326条消息) vue + echarts实现中国地图省份下钻联动_echarts地图下钻_JYeontu的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Twinkle_sone/article/details/123958183?ops_request_misc=%7B%22request_id%22:%22167774407616800182195992%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167774407616800182195992&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123958183-null-null.142%5Ev73%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=vueecharts%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE%E4%B8%8B%E9%92%BB&spm=1018.2226.3001.4187">(326条消息) vue + echarts实现中国地图省份下钻联动_echarts地图下钻_JYeontu的博客-CSDN博客</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/02/28/vue/%E9%9A%8F%E7%AC%94/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>对ajax请求进行拦截<br>在请求头添加token<br>对ajax响应数据进行拦截<br>统一处理请求失败的情况, 这样就不需要在每个组件里处理失败的情况<br>有些接口需要登录才能访问, 在没登录的情况下跳转到登录页面<br>&#x2F;**</p>
<ul>
<li>配置axios的拦截器</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> * */  </span><br><span class="line">   <span class="keyword">let</span> env = <span class="string">&#x27;prod&#x27;</span>;  <span class="comment">//dev开发, test测试, prod生产</span></span><br><span class="line">      <span class="keyword">let</span> baseURL;</span><br><span class="line">   <span class="keyword">if</span>(env === <span class="string">&#x27;dev&#x27;</span>) &#123;</span><br><span class="line">      baseURL = <span class="string">&#x27;http://localhost:3003&#x27;</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">      baseURL = <span class="string">&#x27;http://test.huruqing.cn:3003&#x27;</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   baseURL = <span class="string">&#x27;http://huruqing.cn:3003&#x27;</span>;</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    baseURL,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span></span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置请求拦截</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">    <span class="comment">// 添加token</span></span><br><span class="line">    <span class="comment">// config.headers[&quot;token&quot;] = &quot;gg12j3h4ghj2g134kj1g234gh12jh34k12h34g12kjh34kh1g&quot;;</span></span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="string">&#x27;发送请求失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置响应拦截</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">666</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;网络异常,请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url,data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> service.<span class="title function_">get</span>(url,&#123;<span class="attr">params</span>:data&#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    ...service,</span><br><span class="line">    get</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> ————————————————<br> 版权声明：本文为CSDN博主「牛马小先锋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a href="https://blog.csdn.net/weixin_45838066/article/details/123171886">https://blog.csdn.net/weixin_45838066/article/details/123171886</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[回溯算法]]></title>
      <url>/2023/02/23/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">回溯算法 + 剪枝（回溯经典例题详解） - 组合总和 - 力扣（LeetCode）</a><a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">回溯算法 + 剪枝（回溯经典例题详解） - 组合总和 - 力扣（LeetCode）</a></p>
<p>全排列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`var arr = [1, 2, 3,4,5]`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`function at(*arr*) &#123;`</span></span><br><span class="line"></span><br><span class="line"> <span class="string">`var res=**new** *Set*();`</span></span><br><span class="line"></span><br><span class="line"> <span class="string">`var pai=function pai(*old*,*tar*)&#123;`</span></span><br><span class="line"></span><br><span class="line">​    <span class="string">`if(*tar*.length==0)&#123;`</span></span><br><span class="line"></span><br><span class="line">​    <span class="string">`res.add(*old*)`</span></span><br><span class="line"></span><br><span class="line">​    <span class="string">`&#125;`</span></span><br><span class="line"></span><br><span class="line">​    <span class="string">`for (let index = 0; index &lt; *tar*.length; index++) &#123;`</span></span><br><span class="line"></span><br><span class="line">​      <span class="string">`var copy=[...*tar*]`</span></span><br><span class="line"></span><br><span class="line">​      <span class="string">`copy.splice(index,1)`</span></span><br><span class="line"></span><br><span class="line">​      <span class="string">`pai(*old*+*tar*[index],copy)`</span><span class="comment">//循环进去不断</span></span><br><span class="line"></span><br><span class="line">​    <span class="string">`&#125;`</span></span><br><span class="line"></span><br><span class="line">   <span class="string">`&#125;`</span></span><br><span class="line"></span><br><span class="line">   <span class="string">`pai([],*arr*)`</span></span><br><span class="line"></span><br><span class="line">   <span class="string">`console.log(res);`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`at(arr)</span></span><br></pre></td></tr></table></figure>

<p>&#96;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[split和join]]></title>
      <url>/2023/02/22/es6/split%E5%92%8Cjoin/</url>
      <content type="html"><![CDATA[<h2 id="join–数组转字符串"><a href="#join–数组转字符串" class="headerlink" title="join–数组转字符串"></a>join–数组转字符串</h2><pre><code>    语法:    arrayObject.join(&quot;指定分割符&quot;);   

                如果用’‘，则没有分割符，       

                如果什么都不写，只用()，则默认为&quot;,&quot;
</code></pre>
<p>实例:  var arrObject &#x3D; [“大零”,”丁一”,”赵二”,”张三”,”李四”,”王五”,”钱六”]</p>
<pre><code>      arrObject.join() = &quot;大零,丁一,赵二,张三,李四,王五,钱六&quot;,

      arrObject.join(&quot;---&quot;) = &quot;大零---丁一---赵二---张三---李四---王五---钱六&quot;,
</code></pre>
<h3 id="split–字符串转字符串数组"><a href="#split–字符串转字符串数组" class="headerlink" title="split–字符串转字符串数组"></a>split–字符串转字符串数组</h3><pre><code>    语法:    arrayObject.split(&quot;指定分割符&quot;/正则表达式,指定返回的长度);           

                &quot;指定分割符&quot;/正则表达式&quot;：必需。如果用&quot;&quot;空字符串，则每个字符都会被分割。

                 指定返回的长度：非必需。没有则默认全部返回，有则返回对应长度的数组，负数则默认全部返回。
</code></pre>
<p>实例:  var String &#x3D; “How are you?”</p>
<pre><code>      String.split(&quot;&quot;) = [&quot;H&quot;, &quot;o&quot;, &quot;w&quot;, &quot; &quot;, &quot;a&quot;, &quot;r&quot;, &quot;e&quot;, &quot; &quot;, &quot;y&quot;, &quot;o&quot;, &quot;u&quot;, &quot;?&quot;]

      String.split(&quot; &quot;) = [&quot;How&quot;, &quot;are&quot;, &quot;you?&quot;]

      String.split(/\s+/) = [&quot;How&quot;, &quot;are&quot;, &quot;you?&quot;]

      String.split(&quot; &quot;,2) = [&quot;How&quot;, &quot;are&quot;]

      String.split(&quot; &quot;,2) = [&quot;How&quot;, &quot;are&quot;]

      String.split(&quot;are&quot;) = [&quot;How &quot;, &quot; you?&quot;]
</code></pre>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[下一个排列]]></title>
      <url>/2023/02/20/leetcode/%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20230220220018990.png" alt="image-20230220220018990"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextPermutation = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> k=nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]&lt;=nums[k-<span class="number">1</span>] )</span><br><span class="line"></span><br><span class="line">   k--</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">  nums.<span class="title function_">reverse</span>()</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br><span class="line">   <span class="keyword">let</span> t=nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span>(nums[t]&lt;=nums[k-<span class="number">1</span>])</span><br><span class="line">   t--</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(t);</span><br><span class="line">   <span class="keyword">var</span> temp=nums[k-<span class="number">1</span>]</span><br><span class="line">   nums[k-<span class="number">1</span>]=nums[t]</span><br><span class="line">   nums[t]=temp</span><br><span class="line">   <span class="keyword">let</span> s=nums.<span class="title function_">slice</span>(k).<span class="title function_">reverse</span>()</span><br><span class="line">   nums=nums.<span class="title function_">slice</span>(<span class="number">0</span>,k)</span><br><span class="line">   nums=nums.<span class="title function_">concat</span>(s)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从右往左两次遍历 第一次找降序的位置 第二次找比降序的那个数稍微大一点的数  之后将降序后面的数字逆序  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/02/20/axios%E7%9A%84data%20params%20headers%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：axios的data-params-headers的区别"><a href="#title：axios的data-params-headers的区别" class="headerlink" title="title：axios的data params headers的区别"></a>title：axios的data params headers的区别</h2><h3 id="params："><a href="#params：" class="headerlink" title="params："></a>params：</h3><p>params的对象参数名和值，axios的源码会把参数和值，拼接在ulr？后面拼接给后台（query查询字符串）</p>
<p>eg：先查看接口文档</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除文章分类的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteArtCateAPI = <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/my/cate/del&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="data"><a href="#data" class="headerlink" title="data:"></a>data:</h3><p>data的对象参数和值，axios源码会把参数和值，拼接·在请求体（body参数）</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> registerAPI = <span class="keyword">function</span>(<span class="params">&#123; username, password, repassword &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/reg&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="comment">// axios传参params，data</span></span><br><span class="line">    <span class="comment">// params的对象参数名和值，axios的源码会把参数和值，拼接在ulr？后面拼接给后台（query查询字符串）</span></span><br><span class="line">    <span class="comment">// data的对象参数和值，axios源码会把参数和值，拼接·在请求体（body参数）</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      username,</span><br><span class="line">      password,</span><br><span class="line">      repassword</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>将传递的参数挂载到请求头上</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="comment">// 获取用户信息接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUserInfoAPI = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/my/userinfo&#x27;</span></span><br><span class="line">    <span class="comment">// method不写默认为‘get’方法请求</span></span><br><span class="line">    <span class="comment">// 传递给后台：params（查询字符串query），data（请求体body），headers（请求头）</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="comment">// this.$store.state.token这里的this不是组件对象，不能用this.$store拿到store对象</span></span><br><span class="line">      <span class="title class_">Authorization</span>: store.<span class="property">state</span>.<span class="property">token</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[map的基本使用]]></title>
      <url>/2023/02/17/js%E9%AB%98%E7%BA%A7/map%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关键词：map</p>
<p>项目中我们常常会遇到要对后端返回的数据进行修改，从而达到符合我们前端开发人员的需要，其中map是常用到的对数组元素进行修改的重要函数。</p>
<p>提示：以下是本篇文章正文内容，下面案例可供参考</p>
<p>一、概念<br>map() 方法定义在JavaScript的Array中，<strong>它返回一个新的数组</strong>，数组中的元素为原始数组调用函数处理后的值。值得注意的是：1、map()函数不会对空数组进行检测；2、map()函数不会改变原始数组，它形成的是 一个新的数组</p>
<p>二、相关语法<br>array.map(function(currentValue, index, arr), thisIndex)—<br>参数说明：</p>
<p>function(currentValue, index, arr)：必须。为一个函数，数组中的每个元素都会执行这个函数。其中函数参数：<br>currentValue：必须。表述当前元素的的值(item)<br>index：可选。当前元素的索引也就是第几个数组元素。<br>arr：可选。当前元素属于的数组对象<br>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作”this”的值<br>三、示例<br>例1：对原数组元素进行平方后再赋值给新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let newArray = array.map((item) =&gt; &#123;</span><br><span class="line">    return item * item;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">con</span><br></pre></td></tr></table></figure>

<p>sole.log(newArray)  &#x2F;&#x2F; [1, 4, 9, 16, 25]</p>
<p>例2：将int类型的数据换成字符串类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">tableData</span> = list.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.<span class="property">leaseStatus</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                  item.<span class="property">leaseStatus</span> = <span class="string">&#x27;已租&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">leaseStatus</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                  item.<span class="property">leaseStatus</span> = <span class="string">&#x27;未租&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">leaseStatus</span> === <span class="number">2</span>) &#123;</span><br><span class="line">                  item.<span class="property">leaseStatus</span> = <span class="string">&#x27;已租&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">data</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">                  item = <span class="string">&#x27;暂无记录&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[生成括号]]></title>
      <url>/2023/02/16/leetcode/%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>、</p>
<p><img src="/../../images/image-20230216225029873.png" alt="image-20230216225029873"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        generateAll(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span> * n], <span class="number">0</span>, combinations);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateAll</span><span class="params">(<span class="type">char</span>[] current, <span class="type">int</span> pos, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == current.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">String</span>(current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current[pos] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            generateAll(current, pos + <span class="number">1</span>, result);</span><br><span class="line">            current[pos] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            generateAll(current, pos + <span class="number">1</span>, result);</span><br><span class="line">            <span class="comment">//类似满二叉树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">char</span>[] current)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: current) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++balance;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --balance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>二<img src="/../../images/image-20230216225046564.png" alt="image-20230216225046564"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/02/03/vue/%E9%9A%8F%E7%AC%94/%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>在仓库action中 发送请求api</p>
<p>编程式路由跳转相比声明式子内存消耗小  一般用到事件委托和自定义事件</p>
<p>重写封装ajdx是为了加请求前函数和数据响应后函数 可以写一些业务逻辑</p>
<p>swiper 轮播图  创建swiper实例之前结构（动态从仓库收取的数据可能导致问题）必须完整  否则会出现错误    swiper实例就帮不能写在mounted里  解决方案一 用定时器（事件循环）把实例化放在从仓库取数据的后面   二 用watch＋next Tick</p>
<p>mock数据 通过mockjs模块实现 模拟数据</p>
<p><strong>永远不要把v-if 和 v-for 同时用在一个元素上,因为v-for的优先级高于v-if,当v-if去判断条件时,v-for已经遍历结束</strong></p>
<p>vuex中的getter相当于简化仓库中的数据</p>
<p>search中 发多次请求的  之前只能发一次请求 因为把发送请求放在了mounted中  只需要监听路由参数里面的数据变化 执行参数再次合并 在发送请求  </p>
<p>路由的两个生命周期钩子</p>
<p>监听属性中    <em>data{}里面定义的数据在这里监听不加this</em>  里面的￥route也不用加this</p>
<p>箭头函数没有大括号会隐式返回值 加了大括号不会返回</p>
<p>模块化中给小仓库开启命名空间 直接在两种方式获取 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">computed</span>:&#123;</span><br><span class="line">​    <span class="comment">//  ...mapGetters(&quot;search&quot;,[&quot;goodsList&quot;])</span></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">   <span class="title function_">goodsList</span>(<span class="params"></span>)&#123;</span><br><span class="line">​    <span class="keyword">return</span> *<span class="variable language_">this</span>*.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&quot;search/goodsList&quot;</span>]</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>



<p>search 板块中的难点就在于联系nva（左侧目录） nva先从vuex中得到数据  然后给a添加自定义属性   :<em>data-categoryName</em>&#x3D;”c2.categoryName”       之后通 过路由传参把数据发送给search组件 这其中涉及到要合并参数 以及多次点击 多次发送请求需要在先将之前的数据搞成undifined      这种方法对象如果只有一层 也可以直接在函数中传v-for得item对象</p>
<p><img src="/../../../images/image-20230226213506425.png" alt="image-20230226213506425"></p>
<p> Vue2.0项目引入字体库font-awesome<br>vue2.0安装字体库 font-awesome</p>
<p>&#x2F;&#x2F;安装font-awesome<br>npm install font-awesome –save</p>
<p>import ‘font-awesome&#x2F;css&#x2F;font-awesome.css’</p>
<p><i class="fa fa-camera-retro fa-lg"></i></p>
<p>使用v4版本的图标</p>
<p>也可以直接使用阿里在线图库 前加iconfont</p>
<p>vuex actiongs传递多参数的处理方法：调用的时候第二个参数写成多个元素的对象如  this.$store.dispatch(“tset”,{id,name})</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[for in 和 for of 的区别]]></title>
      <url>/2023/01/31/es6/for%20in%E5%92%8Cfor%20of%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>一句话概括：for in是遍历（object）键名，for of是遍历（array）键值。</p>
<p>文章的内容大部分来自MDN。</p>
<p>for…in<br>for…in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array和Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf() 方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p>
<p><img src="/../../images/image-20230729210101424.png" alt="image-20230729210101424"></p>
<p><img src="/../../images/image-20230729210047446.png" alt="image-20230729210047446"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>for…of<br>for…of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p>
<p>const array1 &#x3D; [‘a’, ‘b’, ‘c’];</p>
<p>for (const val of array1) {<br>  console.log(val);<br>}</p>
<p>&#x2F;&#x2F; a<br>&#x2F;&#x2F; b<br>&#x2F;&#x2F; c<br>f<strong>or of不可以遍历普通对象，想要遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法</strong></p>
<p>for…of与for…in的区别<br>无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。</p>
<p>for…in语句以任意顺序迭代对象的可枚举属性。</p>
<p>for…of 语句遍历可迭代对象定义要迭代的数据。</p>
<p>以下示例显示了与Array一起使用时，for…of循环和for…in循环之间的区别。<em>Object</em>.prototype.objCustom &#x3D; function() {}; </p>
<ul>
<li></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>*.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arrCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>*.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">objCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">iterable.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (iterable.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2, &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;___________&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  3, 5, 7</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>区别①：for of无法循环遍历对象</li>
<li>区别②：遍历输出结果不同  for in循环遍历的是数组的键值(索引)，而for of循环遍历的是数组的值。</li>
<li>for in 会遍历自定义属性，for of不会</li>
</ol>
<p>​       给数组添加一个自定义属性name，并且赋值”数组”。然后进行遍历输出的，会发现新定义的属性也被for in输出来了，而for of并不会对name进行输出。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/01/31/leetcode/lianbiao/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>递归</p>
<p>标签：链表<br>本题的递归和非递归解法其实原理类似，都是更新每两个点的链表形态完成整个链表的调整<br>其中递归解法可以作为典型的递归解决思路进行讲解<br>递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个 f(x)。</p>
<p>其中我们应该关心的主要有三点：</p>
<p> <strong><strong>返回值</strong><br>           <strong>调用单元做了什么</strong><br>           终止条件</strong><br>在本题中：</p>
<p>返回值：交换完成的子链表<br>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换<br>终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[大文件上传]]></title>
      <url>/2023/01/31/%E9%9D%A2%E7%BB%8F/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7177045936298786872?share_token=52922dc4-fa43-4863-9682-75fd531500de">面试官：你如何实现大文件上传 - 掘金 (juejin.cn)</a></p>
<h4 id="创建分片-增量hash"><a href="#创建分片-增量hash" class="headerlink" title="创建分片   增量hash"></a>创建分片   增量hash</h4><p><img src="/../../images/image-20240316145619372.png" alt="image-20240316145619372"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件上传</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uploadFile</span> = <span class="keyword">async</span> (<span class="params">file</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 设置文件名</span></span><br><span class="line">    fileName = file.<span class="property">name</span>;</span><br><span class="line">    <span class="comment">// 获取文件hash值</span></span><br><span class="line">    fileHash = <span class="keyword">await</span> <span class="title function_">getHash</span>(file);</span><br><span class="line">    <span class="comment">// 获取切片</span></span><br><span class="line">    chunks = <span class="title function_">createChunks</span>(file);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">uploadChunks</span>(chunks)</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">mergeRequest</span>(fileHash, fileName)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">mag</span>: <span class="string">&quot;文件上传错误&quot;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量上传切片</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uploadChunks</span> = (<span class="params">chunks, maxRequest = <span class="number">6</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunks.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>([]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> requestSliceArr = []</span><br><span class="line">        <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; chunks.<span class="property">length</span>) &#123;</span><br><span class="line">            requestSliceArr.<span class="title function_">push</span>(chunks.<span class="title function_">slice</span>(start, start + maxRequest))</span><br><span class="line">            start += maxRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> requestReaults = [];</span><br><span class="line">        <span class="keyword">let</span> requestErrReaults = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">request</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; requestSliceArr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(requestReaults)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> sliceChunks = requestSliceArr[index];</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">                sliceChunks.<span class="title function_">map</span>(<span class="function"><span class="params">chunk</span> =&gt;</span> <span class="title function_">uploadHandler</span>(chunk))</span><br><span class="line">            ).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                requestReaults.<span class="title function_">push</span>(...(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(res) ? res : []))</span><br><span class="line">                index++;</span><br><span class="line">                <span class="title function_">request</span>()</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                requestErrReaults.<span class="title function_">push</span>(...(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(err) ? err : []))</span><br><span class="line">                <span class="title function_">reject</span>(requestErrReaults)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">request</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>上传完之后 告诉服务器上传的hash和文件名 让他把文件合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传文件</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">handleUpload</span> = <span class="keyword">async</span> (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (!fileName) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&quot;请先选择文件&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (chunkList.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&quot;文件拆分中，请稍后...&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 计算hash</span></span><br><span class="line">   <span class="keyword">const</span> hash = <span class="keyword">await</span> <span class="title function_">calculateHash</span>(chunkList)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件的hash为：&quot;</span>, hash)</span><br><span class="line">   <span class="title function_">setFileHash</span>(hash)</span><br><span class="line">   <span class="comment">//验证是否已经上传 或者已经上传了多少</span></span><br><span class="line">   <span class="keyword">const</span> &#123; shouldUpload, uploadedChunkList &#125; = <span class="keyword">await</span> <span class="title function_">verfileIsExist</span>(hash, <span class="title function_">getFileSuffix</span>(fileName));</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(shouldUpload)</span><br><span class="line">   <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&quot;文件已存在，无需重复上传&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> uploadedChunkIndexList = [];</span><br><span class="line">   <span class="comment">//已经上传了多少</span></span><br><span class="line">   <span class="keyword">if</span> (uploadedChunkList &amp;&amp; uploadedChunkList.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     uploadedChunkIndexList = uploadedChunkList.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> arr = item.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">parseInt</span>(arr[arr.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(uploadedChunkIndexList)</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&quot;已上传的区块号：&quot;</span> + uploadedChunkIndexList.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> chunksData = chunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">     <span class="attr">chunk</span>: chunk,</span><br><span class="line">     <span class="attr">hash</span>: hash + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">     <span class="attr">progress</span>: <span class="number">0</span></span><br><span class="line">   &#125;)).<span class="title function_">filter</span>(<span class="function"><span class="params">item2</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 过滤掉已上传的块</span></span><br><span class="line">     <span class="keyword">const</span> arr = item2.<span class="property">hash</span>.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span> uploadedChunkIndexList.<span class="title function_">indexOf</span>(<span class="built_in">parseInt</span>(arr[arr.<span class="property">length</span> - <span class="number">1</span>])) === -<span class="number">1</span>;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(chunksData)</span><br><span class="line">   <span class="comment">// 保存分片数据</span></span><br><span class="line">   <span class="title function_">setChunkList</span>(chunksData)</span><br><span class="line">   <span class="comment">// 开始上传分片</span></span><br><span class="line">   <span class="title function_">uploadChunks</span>(chunksData, hash)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/01/30/vue/%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：vue的随笔"><a href="#title：vue的随笔" class="headerlink" title="title：vue的随笔"></a>title：vue的随笔</h2><p>router的push多次调用会报错 因为他是一个promise对象</p>
<p>push是router类的原 型方法  this.$router是其一个实例对象</p>
<p>call和aplly的区别     </p>
<p>vuex中的gitter相当于简化仓库中的数据</p>
<p>search中 发多次请求的  之前只能发一次请求 因为把发送请求放在了mounted中  只需要监听路由参数里面的数据变化 执行参数再次合并 在发送请求  </p>
<p>路由的两个生命周期钩子</p>
<p>监听属性中    <em>data{}里面定义的数据在这里监听不加this</em>  里面的￥route也不用加this</p>
<p>箭头函数没有大括号会隐式返回值 加了大括号不会返回</p>
<p>模块化中给小仓库开启命名空间 直接在两种方式获取 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="attr">computed</span>:&#123;</span><br><span class="line">​    <span class="comment">//  ...mapGetters(&quot;search&quot;,[&quot;goodsList&quot;])</span></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">   <span class="title function_">goodsList</span>(<span class="params"></span>)&#123;</span><br><span class="line">​    <span class="keyword">return</span> *<span class="variable language_">this</span>*.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&quot;search/goodsList&quot;</span>]</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>导入部分，引入非 default 时，使用花括号；全部导入不用花括号。</strong>  引入整个模块不用花括号  引入部分 就花括号</p>
<p>data 里面使用方法要加this 求求了别忘了</p>
<h5 id="Vue多页面使用同一个echarts，只会出现一个"><a href="#Vue多页面使用同一个echarts，只会出现一个" class="headerlink" title="Vue多页面使用同一个echarts，只会出现一个"></a>Vue多页面使用同一个echarts，只会出现一个</h5><p>原因：首先echarts的创建方式，是通过获取元素的id初始化echarts实例，所以在渲染时，两个元素的id相同只会出现一个echarts图表</p>
<h1 id="element-UI中el-select下拉框可搜索时候，filter-method自定义搜索方法"><a href="#element-UI中el-select下拉框可搜索时候，filter-method自定义搜索方法" class="headerlink" title="element-UI中el-select下拉框可搜索时候，filter-method自定义搜索方法"></a>element-UI中el-select下拉框可搜索时候，filter-method自定义搜索方法</h1><p><img src="/../../images/image-20230309223656123.png" alt="image-20230309223656123"></p>
<p>问：什么时候 进updated方法？</p>
<p>​    答：只有事先设置好的data变量如下arrData改变并且要在页面重新渲染完成之后,才会进updated方法，</p>
<p>光改变arrData但不渲染页面是不会进的.</p>
<p><code>$attrs</code> 和 <code>$listeners</code> 都是 Vue 实例上的特殊属性，用于在组件中进行属性和事件的传递。</p>
<ol>
<li><code>$attrs</code> 属性：<ul>
<li>作用：<code>$attrs</code> 包含了父组件传递给子组件的所有非 prop 特性&#x2F;属性。这些非 prop 特性通常是父组件上没有被声明为 prop 的特性。</li>
<li>使用场景：当你希望将父组件上的一些特性传递给子组件的一个内部元素（例如 <code>&lt;el-button&gt;</code> 组件），可以使用 <code>v-bind=&quot;$attrs&quot;</code> 将 <code>$attrs</code> 对象中的所有属性绑定到该元素上。</li>
<li>注意事项：默认情况下，子组件会将接收到的 <code>$attrs</code> 应用到根元素上，并通过 <code>$attrs</code> 传递下去。如果你不希望将某个特性应用到根元素上，那么可以在子组件的模板中使用 <code>inheritAttrs: false</code> 选项，并显式地将特性传递给指定的元素。</li>
</ul>
</li>
<li><code>$listeners</code> 属性：<ul>
<li>作用：<code>$listeners</code> 包含了父组件传递给子组件的所有事件监听器。</li>
<li>使用场景：当你希望将父组件上的事件监听器传递给子组件的一个内部元素时，可以使用 <code>v-on=&quot;$listeners&quot;</code> 将 <code>$listeners</code> 对象中的所有事件监听器绑定到该元素上。</li>
<li>注意事项：默认情况下，子组件会将接收到的 <code>$listeners</code> 应用到根元素上，并通过 <code>$listeners</code> 传递下去。但是，你也可以在子组件的模板中选择性地将事件监听器应用到指定的元素。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>$attrs</code> 和 <code>$listeners</code> 是 Vue 提供的用于在组件中进行属性和事件的传递的特殊属性。它们能够帮助简化组件之间的交互和通信。</p>
<p>应用：封装button 带有title</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin:10px&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;HintButton&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&quot;title&quot;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>







<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>1，在 Vue 3 的 <code>&lt;script setup&gt;</code> 语法糖中，<code>ref</code> 和 <code>reactive</code> 会自动解包，使你可以更方便地使用它们来实现响应式数据。</p>
<p>2  使用 <script setup> 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <script setup> 中声明的绑定。可以通过 defineExpose 编译器宏来显式指定在 <script setup> 组件中要暴露出去的属性：</p>
<p>3 在 <script setup> 使用 slots 和 attrs 的情况应该是相对来说较为罕见的，因为可以在模板中直接通过 $slots 和 $attrs 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用：</p>
<p>当使用 <script setup> 的时候，任何在 <script setup> 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用</p>
<h3 id="父组件调用子组件的事件"><a href="#父组件调用子组件的事件" class="headerlink" title="父组件调用子组件的事件"></a>父组件调用子组件的事件</h3><h4 id="父组件调用子组件事件"><a href="#父组件调用子组件事件" class="headerlink" title="父组件调用子组件事件"></a>父组件调用子组件事件</h4><p>父组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码&lt;!-- 父组件 app.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;par&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 使用 ref 指令关联子组件 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;childRef&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&quot;./child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//定义子组件实例，名称要和上面的ref相同</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> childRef = <span class="title function_">ref</span>(<span class="literal">null</span>); @@@@@@</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//访问demo组件的方法或对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//获取到子组件的 title 数据 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> title = childRef.<span class="property">value</span>.<span class="property">state</span>.<span class="property">title</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//调用子组件的 play方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  childRef.<span class="property">value</span>.<span class="title function_">submit</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<p>子组件通过<a href="https://link.juejin.cn/?target=https://so.csdn.net/so/search?q=defineExpose&spm=1001.2101.3001.7020">defineExpose</a>暴露对象和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码&lt;!--子组件名称  child.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; state.title &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//定义一个变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">title</span>: <span class="string">&quot;标题&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//定义一个方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">submit</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  state.<span class="property">title</span> = <span class="string">&quot;你调用了子组件的方法&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//暴露state和play方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineExpose</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  state,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  submit</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&lt;/script</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>/2023/01/27/js%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%20%E6%8E%98%E9%87%91/</url>
      <content type="html"><![CDATA[<h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h3 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">outFun2</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> inVariable = &quot;内层变量<span class="number">2</span>&quot;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">outFun2</span>();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line">console<span class="selector-class">.log</span>(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以体会到作用域的概念，变量inVariable在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现。</p>
<h3 id="2-全局作用域和函数作用域"><a href="#2-全局作用域和函数作用域" class="headerlink" title="2.全局作用域和函数作用域"></a>2.全局作用域和函数作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> outVariable = &quot;我是最外层变量&quot;; <span class="comment">//最外层变量</span></span><br><span class="line">function <span class="built_in">outFun</span>() &#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="selector-tag">var</span> inVariable = &quot;内层变量&quot;;</span><br><span class="line">    function <span class="built_in">innerFun</span>() &#123; <span class="comment">//内层函数</span></span><br><span class="line">        console<span class="selector-class">.log</span>(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">innerFun</span>();</span><br><span class="line">&#125;</span><br><span class="line">console<span class="selector-class">.log</span>(outVariable); <span class="comment">//我是最外层变量</span></span><br><span class="line"><span class="built_in">outFun</span>(); <span class="comment">//内层变量</span></span><br><span class="line">console<span class="selector-class">.log</span>(inVariable); <span class="comment">//inVariable is not defined</span></span><br><span class="line"><span class="built_in">innerFun</span>(); <span class="comment">//innerFun is not defined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outFun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    variable = <span class="string">&quot;未定义直接赋值的变量&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable2 = <span class="string">&quot;内层变量2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outFun2</span>();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(variable); <span class="comment">//未定义直接赋值的变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inVariable2); <span class="comment">//inVariable2 is not defined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>所有window对象的属性拥有全局作用域</li>
</ul>
<p>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。</p>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 张三写的代码中</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = &#123;a: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李四写的代码中</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = &#123;x: <span class="literal">true</span>&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在<code>(function()&#123;....&#125;)()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p>
<p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">doSomething</span>()&#123;</span><br><span class="line">    <span class="selector-tag">var</span> blogName=&quot;浪里行舟&quot;;</span><br><span class="line">    function <span class="built_in">innerSay</span>()&#123;</span><br><span class="line">        <span class="built_in">alert</span>(blogName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">innerSay</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">alert</span>(blogName); <span class="comment">//脚本错误</span></span><br><span class="line"><span class="built_in">innerSay</span>(); <span class="comment">//脚本错误</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。我们看个例子，用泡泡来比喻作用域可能好理解一点：</p>
<p><img src="/../../images/169590b8c66f551btplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<p>最后输出的结果为 2, 4, 12</p>
<ul>
<li>泡泡1是全局作用域，有标识符foo；</li>
<li>泡泡2是作用域foo，有标识符a,bar,b；</li>
<li>泡泡3是作用域bar，仅有标识符c。</li>
</ul>
<p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 bug 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p>
<h3 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3.块级作用域"></a>3.块级作用域</h3><p>块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ol>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ol>
<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部</li>
</ul>
<p>let&#x2F;const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let&#x2F;const 声明放置到顶部，以便让变量在整个代码块内部可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">condition</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// value 在此处不可用</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>禁止重复声明</li>
</ul>
<p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">count</span> = <span class="number">30</span><span class="comment">;</span></span><br><span class="line">let <span class="attr">count</span> = <span class="number">40</span><span class="comment">; // Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declared</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>循环中的绑定块作用域的妙用</li>
</ul>
<p>开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">console<span class="selector-class">.log</span>(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line">for (<span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10</span>; <span class="selector-tag">i</span>++) &#123;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-attr">[i]</span> = function () &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="selector-tag">i</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[6]</span>(); // <span class="number">10</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line">for (let <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10</span>; <span class="selector-tag">i</span>++) &#123;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-attr">[i]</span> = function () &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="selector-tag">i</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[6]</span>(); // <span class="number">6</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (let <span class="attr">i</span> = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">  let <span class="attr">i</span> = <span class="string">&#x27;abc&#x27;</span><span class="comment">;</span></span><br><span class="line">  console.log(i)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="1-什么是自由变量"><a href="#1-什么是自由变量" class="headerlink" title="1.什么是自由变量"></a>1.什么是自由变量</h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">function fn() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">200</span></span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="selector-tag">a</span>) // 这里的<span class="selector-tag">a</span>在这里就是一个自由变量</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="selector-tag">b</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="2-什么是作用域链"><a href="#2-什么是作用域链" class="headerlink" title="2.什么是作用域链"></a>2.什么是作用域链</h3><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">function <span class="built_in">F1</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">200</span></span><br><span class="line">    function <span class="built_in">F2</span>() &#123;</span><br><span class="line">        <span class="selector-tag">var</span> c = <span class="number">300</span></span><br><span class="line">        console<span class="selector-class">.log</span>(a) <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">        console<span class="selector-class">.log</span>(b) <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">        console<span class="selector-class">.log</span>(c) <span class="comment">// 本作用域的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F2</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">F1</span>()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="3-关于自由变量的取值"><a href="#3-关于自由变量的取值" class="headerlink" title="3.关于自由变量的取值"></a>3.关于自由变量的取值</h3><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> x = <span class="number">10</span></span><br><span class="line">function <span class="built_in">fn</span>() &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">show</span>(f) &#123;</span><br><span class="line">  <span class="selector-tag">var</span> x = <span class="number">20</span></span><br><span class="line">  (function() &#123;</span><br><span class="line">    <span class="built_in">f</span>() <span class="comment">//10，而不是20</span></span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">show</span>(fn)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，<strong>无论fn函数将在哪里调用</strong>。</p>
<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:<strong>要到创建这个函数的那个域”。 作用域中取值,这里强调的是“创建”，而不是“调用”</strong>，切记切记——其实这就是所谓的”静态作用域”</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    console.<span class="title function_ invoke__">log</span>(a + b) <span class="comment">//30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">fn</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">  <span class="title">b</span> = 200</span></span><br><span class="line"><span class="function"><span class="title">x</span>(<span class="params"></span>) //<span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">复制代码</span></span><br></pre></td></tr></table></figure>

<p>fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30</p>
<h2 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h2><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p>
<p>我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p>
<h3 id="解释阶段："><a href="#解释阶段：" class="headerlink" title="解释阶段："></a>解释阶段：</h3><ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<h3 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h3><ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<p>JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>
<p>作用域和执行上下文之间最大的区别是： <strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p>
<p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[js执行上下文与作用域的区别]]></title>
      <url>/2023/01/27/js%E9%AB%98%E7%BA%A7/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>每个上下文都有一个关联的变量对象   在这个上下文所有变量和函数都存在这个对象上 </p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>函数每调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就有不同的参数。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">fn</span>(x) &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(arguments)</span><br><span class="line">  console<span class="selector-class">.log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fn</span>(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">fn</span>(<span class="number">10</span>) <span class="comment">// 不同的调用可能有不同的参数复制代码</span></span><br></pre></td></tr></table></figure>

<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除（当然了闭包并不会乖乖就范），<strong>处于活动状态的执行上下文环境只有一个</strong>。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个压栈出栈的过程--执行上下文栈</span></span><br><span class="line"><span class="number">1</span> let <span class="selector-tag">a</span> = <span class="number">10</span>, fn, <span class="comment">// 1、进入全局上下文环境</span></span><br><span class="line"><span class="number">2</span>    bar = <span class="built_in">function</span>(x) &#123;</span><br><span class="line"><span class="number">3</span>      let <span class="selector-tag">b</span> = <span class="number">5</span></span><br><span class="line"><span class="number">4</span>      <span class="built_in">fn</span>(x + b) <span class="comment">// 3、进入fn函数上下文环境</span></span><br><span class="line"><span class="number">5</span>    &#125;</span><br><span class="line"><span class="number">6</span> fn = <span class="built_in">function</span>(y) &#123;</span><br><span class="line"><span class="number">7</span>  let c = <span class="number">5</span></span><br><span class="line"><span class="number">8</span>  console<span class="selector-class">.log</span>(y + c)</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="built_in">bar</span>(<span class="number">10</span>) <span class="comment">// 2、进入bar函数上下文环境复制代码</span></span><br></pre></td></tr></table></figure>

<p>（1）执行代码之前，首先创建全局上下文环境。（活动状态）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局上下文环境</span></span><br><span class="line"><span class="attr">a</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">fn</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">bar</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">this</span>: <span class="variable language_">window</span>复制代码</span><br></pre></td></tr></table></figure>

<p>然后执行代码，代码到10行之前，上下文环境中的变量都在执行过程中被赋值。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 全局上下文环境</span><br><span class="line"><span class="symbol">a:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">fn:</span> <span class="keyword">function</span></span><br><span class="line"><span class="symbol">bar:</span> <span class="keyword">function</span></span><br><span class="line"><span class="symbol">this:</span> window复制代码</span><br></pre></td></tr></table></figure>

<p>（2）然后执行到11行，调用bar函数。跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bar执行上下文环境</span><br><span class="line"><span class="section">b: undefined</span></span><br><span class="line"><span class="section">x: 10</span></span><br><span class="line"><span class="section">arguments: [10]</span></span><br><span class="line"><span class="section">this: window复制代码</span></span><br></pre></td></tr></table></figure>

<p>然后将bar执行上下文环境压栈，设置为活动状态（当前唯一）</p>
<p>（3）然后执行到第4行，调用fn函数。调到fn函数内部，执行函数体语句之前，会创建一个新的执行上下文环境</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// fn执行上下文环境</span><br><span class="line"><span class="section">c: undefined</span></span><br><span class="line"><span class="section">y: 15</span></span><br><span class="line"><span class="section">arguments: [15]</span></span><br><span class="line"><span class="section">this: window复制代码</span></span><br></pre></td></tr></table></figure>

<p>然后将fn执行上下文环境压栈，设置为活动状态（当前唯一）</p>
<p>（4）fn执行完毕后，调用fn函数生成的fn上下文环境出栈，被销毁。然后bar执行完毕后，调用bar函数生成的上下文环境出栈，被销毁。然后剩下全局上下文环境，出栈销毁。</p>
<p><img src="/../../images/16ee4ae1c2c3ec37tplv-t2oaga2asx-zoom-in-crop-mark4536000.png" alt="执行上下文环境切换过程"></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>JS没有块级作用域，除了全局作用域，函数会创建自己的作用域。作用域在函数定义时就已经确定了，不是在函数调用确定（区别于执行上下文环境，当然this也是上下文环境里的成分）</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line">let x = <span class="number">100</span></span><br><span class="line">    <span class="comment">// fn作用域</span></span><br><span class="line">    function <span class="built_in">fn</span>(x) &#123;</span><br><span class="line">        <span class="comment">// bar作用域</span></span><br><span class="line">        function <span class="built_in">bar</span>(x) &#123;</span><br><span class="line">          console<span class="selector-class">.log</span>(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">let f1 = <span class="built_in">fn</span>(<span class="number">5</span>)</span><br><span class="line">let f2 = <span class="built_in">fn</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>() <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">f2</span>() <span class="comment">// 10复制代码</span></span><br></pre></td></tr></table></figure>

<p>作用域只是一个“地盘”，<strong>其中没有变量</strong>。<strong>变量是通过作用域对应的执行上下文环境中的变量对象来实现的</strong>。所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。有闭包存在时，一个作用域存在两个上下文环境也是有的。</p>
<p>同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，<strong>所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。</strong></p>
<p><strong>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在</strong>其中找到变量的值。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。</p>
<blockquote>
<p>自由变量：比如a，是在fn作用域使用，但是并没有在fn作用域定义，这就是自由变量。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b) <span class="comment">// a是自由变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="title function_">fn</span>(), b = <span class="number">200</span></span><br><span class="line"><span class="title function_">x</span>()   复制代码</span><br></pre></td></tr></table></figure>

<p>那么自由变量是如何得到的呢？这就引出了作用域链。</p>
<p>bar要取得a的值，就要到创建bar这个函数的作用域中取值（这里是fn作用域），fn作用域也没有a，就到创建fn这个函数的作用域中取值（这里是全局作用域），找到了就结束了。这就是作用域链。</p>
<p>立即执行函数的this指向的是 window</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[最大子序列和]]></title>
      <url>/2023/01/26/leetcode/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums=[-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dp=[]  <span class="comment">//dp</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">   dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>]+nums[i],nums[i])</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(res&lt;dp[i])</span><br><span class="line"></span><br><span class="line">​    res=dp[i]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">maxSubArray</span>(nums)</span><br></pre></td></tr></table></figure>

<p>动态五步 1 dp含义（dp以i为结尾的nums[i]的最大连续子序列和）</p>
<p>​         2递推公式  dp[i]&#x3D;Math.max(dp[i-1]+nums[i],nums[i])</p>
<p>  3初始化 dp[0]&#x3D;nums[0]</p>
<p> 4遍历顺序</p>
<p> 5 打印</p>
<h3 id="二-分治法"><a href="#二-分治法" class="headerlink" title="二 分治法"></a>二 分治法</h3><p>将一个数组分成一个个很小的问题</p>
<p>一分为二 </p>
<p>要与递归一起用</p>
<p><img src="/../../images/image-20230126112326638.png" alt="image-20230126112326638"></p>
<p><strong>分治法的思路是这样的，其实也是分类讨论。</strong></p>
<p>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p>
<p>第 1 部分：子区间 [left, mid]；<br>第 2 部分：子区间 [mid + 1, right]；<br>第 3 部分：包含子区间 [mid , mid + 1] 的子区间，即 nums[mid] 与 nums[mid + 1] 一定会被选取。<br>对这三个部分求最大值即可。</p>
<p>说明：考虑第 3 部分跨越两个区间的连续子数组的时候，由于 nums[mid] 与 nums[mid + 1] 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值，具体请见「参考代码 6」。</p>
<p>public class Solution {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSubArraySum(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxCrossingSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123; <span class="comment">//求中间区域的</span></span><br><span class="line">    <span class="comment">// 一定会包含 nums[mid] 这个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">    <span class="comment">// 走到最边界，看看最值是什么</span></span><br><span class="line">    <span class="comment">// 计算以 mid 结尾的最大的子数组的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">            leftSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">    <span class="comment">// 计算以 mid+1 开始的最大的子数组的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">            rightSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxSubArraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> max3(maxSubArraySum(nums, left, mid),</span><br><span class="line">                maxSubArraySum(nums, mid + <span class="number">1</span>, right),</span><br><span class="line">                maxCrossingSum(nums, left, mid, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max3</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> num3)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(num1, Math.max(num2, num3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1<a href="https://www.bilibili.com/video/BV1Ez4y1S7WP/?spm_id_from=333.337.search-card.all.click&vd_source=7ad9fb1ef74e4aea138584b5b0deb6f6">Leetcode力扣 53 手画图解版｜最大子序和 Maximum Subarray_哔哩哔哩_bilibili</a></p>
<p>2<a href="https://www.bilibili.com/video/BV19V4y1F7b5/?spm_id_from=333.337.search-card.all.click&vd_source=7ad9fb1ef74e4aea138584b5b0deb6f6">看起来复杂，其实是简单动态规划 | LeetCode：53.最大子序和_哔哩哔哩_bilibili</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[三数之和与target最相近的是]]></title>
      <url>/2023/01/24/leetcode/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E4%B8%8Etarget%20%E6%9C%80%E7%9B%B8%E8%BF%91%E7%9A%84%E6%98%AF/</url>
      <content type="html"><![CDATA[<p>对于一个数组的n个数，选三个数 其和与target最接近</p>
<p>排序加双指针                 i j k   遍历i   j和k作为指针移动 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k0</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">j0</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/01/23/vue/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title-vue3-快速上手"><a href="#title-vue3-快速上手" class="headerlink" title="title:vue3 快速上手"></a>title:vue3 快速上手</h2><h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />



<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li>实现原理: <ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p><strong>watchEffect有点像computed：</strong></p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div>





































<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#x27;Demo&#x27;,</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay)&#123;</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">					return&#123;</span><br><span class="line">						get()&#123;</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						&#125;,</span><br><span class="line">						set(newValue)&#123;</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;&#123;</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							&#125;,delay)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">			return &#123;</span><br><span class="line">				keyword</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>















<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>













<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[深浅复制]]></title>
      <url>/2023/01/23/es6/%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、堆栈、基本数据类型、引用数据类型"><a href="#一、堆栈、基本数据类型、引用数据类型" class="headerlink" title="一、堆栈、基本数据类型、引用数据类型"></a>一、堆栈、基本数据类型、引用数据类型</h3><p>在了解深浅拷贝之前，我们需得对堆栈、基本数据类型、引用数据类型有基本的了解</p>
<p>基本数据类型：number、string、boolean、null、undefined<br>引用数据类型：object、function、array</p>
<p>栈内存是保存大小固定的数据，即保存基本数据类型。堆保存的大小不固定，可保存引用数据</p>
<h3 id="二、深浅拷贝理解"><a href="#二、深浅拷贝理解" class="headerlink" title="二、深浅拷贝理解"></a>二、深浅拷贝理解</h3><p>浅拷贝：拷贝基本数据类型时，不受任何影响，当拷贝引用类型时，源对象也会被修改。</p>
<p>深拷贝：深拷贝就是完完全全拷贝一份新的对象，它会在内存的堆区域重新开辟空间，修改拷贝对象就不会影响到源对象</p>
<p>即深浅拷贝是针对于<code>引用数据类型</code></p>
<p>比如下面我们常见的浅拷贝代码，源对象被修改往往不是我们需要的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">   name : <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//&#123;</span></span><br><span class="line">   name : <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//&#123;</span></span><br><span class="line">   name : <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果可见源数据发生了改变</p>
<h3 id="三、实现深拷贝的四种方式"><a href="#三、实现深拷贝的四种方式" class="headerlink" title="三、实现深拷贝的四种方式"></a>三、实现深拷贝的四种方式</h3><h4 id="1、es6的展开语法"><a href="#1、es6的展开语法" class="headerlink" title="1、es6的展开语法"></a>1、es6的展开语法</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">   name : <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="params">...</span>a&#125;;</span><br><span class="line">b.name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">console.<span class="keyword">log</span>(<span class="string">&#x27;a：&#x27;</span>,a);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="string">&#x27;b：&#x27;</span>,b);</span><br></pre></td></tr></table></figure>

<p>代码运行：<code>源数据不会发生改变</code></p>
<p><img src="/../../images/5ab65018a40342f69fac68e378fb2325.png" alt="在这里插入图片描述"><br>注意：es6的展开语法只针对第一层，对多层还是浅拷贝方式</p>
<h4 id="2、JSON-parse-JSON-stringify-待拷贝对象"><a href="#2、JSON-parse-JSON-stringify-待拷贝对象" class="headerlink" title="2、JSON.parse(JSON.stringify(待拷贝对象))"></a>2、JSON.parse(JSON.stringify(待拷贝对象))</h4><p>但此拷贝的<code>缺点</code>,即<strong>没法拷贝内部函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name : <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">    <span class="title function_">like</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喜欢唱歌、滑冰&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b =<span class="title class_">JSON</span>.<span class="title function_">parse</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a) );</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a：&#x27;</span>,a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b：&#x27;</span>,b);</span><br></pre></td></tr></table></figure>

<p>结果：在b对象中<strong>未出现like函数</strong><br><img src="/../../images/f289c823610746efb2a159c3afb4efed.png" alt="在这里插入图片描述"></p>
<h4 id="3、jQuery-中的-extend-添加true就是深拷贝-不添加就是浅拷贝"><a href="#3、jQuery-中的-extend-添加true就是深拷贝-不添加就是浅拷贝" class="headerlink" title="3、jQuery 中的 $.extend (添加true就是深拷贝,不添加就是浅拷贝)"></a>3、jQuery 中的 $.extend (添加true就是深拷贝,不添加就是浅拷贝)</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let origin = [[<span class="number">1</span>,<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">let <span class="keyword">new</span><span class="type">_data</span> = []</span><br><span class="line"></span><br><span class="line">$.extend(<span class="literal">true</span>,<span class="keyword">new</span><span class="type">_data</span>,origin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span><span class="type">_data</span>[<span class="number">0</span>].push(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">&#x27;origin：&#x27;</span>,origin);</span><br><span class="line">console.log(<span class="string">&#x27;new_data：&#x27;</span>,<span class="keyword">new</span><span class="type">_data</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6ZKxOTk5,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p>
<h4 id="4、手写递归的方式来实现深拷贝"><a href="#4、手写递归的方式来实现深拷贝" class="headerlink" title="4、手写递归的方式来实现深拷贝"></a>4、手写递归的方式来实现深拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = &#123;</span><br><span class="line">   name : <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age : <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">    <span class="title function_">like</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喜欢唱歌、滑冰&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    a : [[<span class="number">1</span>,<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">origin, deep</span>)&#123;</span><br><span class="line">    <span class="comment">// deep true  启动深拷贝</span></span><br><span class="line">    <span class="comment">// false  浅拷贝</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 数组对象</span></span><br><span class="line">    <span class="keyword">if</span>(origin <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        <span class="comment">// true 数组  obj 就得是数组</span></span><br><span class="line">        obj = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">let</span> value = origin[key]</span><br><span class="line">        <span class="comment">// 确定value是不是引用型，前提是deep 是true</span></span><br><span class="line">        obj[key] = (!!deep &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> &amp;&amp; value !== <span class="literal">null</span>) ? <span class="title function_">extend</span>(value, deep) : value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new_data = <span class="title function_">extend</span>(origin, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">new_data.<span class="property">a</span>[<span class="number">0</span>].<span class="title function_">push</span>(<span class="number">6666</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_data)</span><br></pre></td></tr></table></figure>

<h2 id="四、实现浅拷贝的常见"><a href="#四、实现浅拷贝的常见" class="headerlink" title="四、实现浅拷贝的常见"></a>四、实现浅拷贝的常见</h2><p>slice  数组复制</p>
<p>object.assign 合并对象</p>
<p>Array.from(将任何可迭代的结构 转换为数组实例) p139</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[slice]]></title>
      <url>/2023/01/23/es6/slice/</url>
      <content type="html"><![CDATA[<p>一、语法以及描述<br>说明：通过start 和 end对原数组进行<strong>浅拷贝</strong>（提取 start 至 end 索引的数组元素）<br>语法：Array.slice([start[, end])<br>参数：</p>
<p>start : 开始索引<br>end : 结束索引<br>返回值：返回一个新的数组<br>是否改变原数组：否</p>
<p>二、参数</p>
<ol>
<li>无参数<br>说明：从起始处索引（0）开始提取数组元素，直至结束<br>返回值：从起始处索引到结束索引的所有数组元素<br>原数组：不发生任何变化<br>示例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.<span class="title function_">slice</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr&#x27;</span>, arr);</span><br><span class="line"><span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res&#x27;</span>, res);</span><br><span class="line"><span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>只有一个参数start<br>说明：从 start 索引开始提取数组元素，直至结束<br>  负数 : 表示从倒数 start 索引开始提取数组元素<br>  正数 : 从 start 索引开始提取数组元素，直至结束<br>返回值：从 start 索引到结束索引的所有数组元素，如果 start 大于原数组长度，则返回空数组<br>原数组：不发生任何变化<br>示例</li>
</ol>
<p>&#x2F;&#x2F; 1. 正数<br>var arr &#x3D; [‘A’, ‘B’, ‘C’, ‘D’];<br>var res &#x3D; arr.slice(1)</p>
<p>console.log(‘arr’, arr);<br>&#x2F;&#x2F; [‘A’, ‘B’, ‘C’, ‘D’]<br>console.log(‘res’, res);<br>&#x2F;&#x2F; [“B”, “C”, “D”]</p>
<p>&#x2F;&#x2F; 2. 负数<br>var arr &#x3D; [‘A’, ‘B’, ‘C’, ‘D’];<br>var res &#x3D; arr.slice(-1)</p>
<p>console.log(‘arr’, arr);<br>&#x2F;&#x2F; [‘A’, ‘B’, ‘C’, ‘D’]<br>console.log(‘res’, res);<br>&#x2F;&#x2F; [“D”]</p>
<p>&#x2F;&#x2F; 3. 大于数组长度的值<br>var arr &#x3D; [‘A’, ‘B’, ‘C’, ‘D’];<br>var res &#x3D; arr.slice(6)</p>
<p>console.log(‘arr’, arr);<br>&#x2F;&#x2F; [‘A’, ‘B’, ‘C’, ‘D’]<br>console.log(‘res’, res);<br>&#x2F;&#x2F; []</p>
<ol start="2">
<li>有两个参数start、end<br>说明：从 start 索引开始提取数组元素，直至 end 索引（包括 start，但不包括 end）<br>返回值：从 start 索引到 end 索引的所有数组元素<br>原数组：不发生任何变化<br>示例</li>
</ol>
<p>var arr &#x3D; [‘A’, ‘B’, ‘C’, ‘D’];<br>var res &#x3D; arr.slice(1, 3)</p>
<p>console.log(‘arr’, arr);<br>&#x2F;&#x2F; [“A”, “B”, “C”, “D”]<br>console.log(‘res’, res);<br>&#x2F;&#x2F; [“B”, “C”]</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[let const]]></title>
      <url>/2023/01/23/es6/let%20const/</url>
      <content type="html"><![CDATA[<h3 id="二、let、const、var的区别？"><a href="#二、let、const、var的区别？" class="headerlink" title="二、let、const、var的区别？"></a>二、let、const、var的区别？</h3><p>let、const和var都可以定义变量，那么let、const和var的区别是什么？这也是我们前端在面试时可能会遇到的面试题。</p>
<p> Var：没有块级作用域，创建和初始化的时候有变量提升，可以重复声明，有全局污染</p>
<p> Let：有块级作用域，不允许重复声明，暂时性死区 </p>
<p> Const：有块级作用域，不允许重复声明，暂时性死区，<strong>const声明的变量不能直接修改值，但是const定义是指向这个对象的地址，地址不变，引用的数据可以改变。</strong>  即可以修改一个对象里的属性</p>
<p>三、什么是暂时性死区？<br>刚刚我们在解释let、const和var的区别时，说到了暂时性死区，那么什么是暂时性死区呢？</p>
<p>暂时性死区：创建了变量但是没有初始化，没法使用变量，****，形成了暂时性死区<br>let声明之前的执行瞬间 被称为暂时性死区</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p><strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p>
<h2 id="let有无变量提升"><a href="#let有无变量提升" class="headerlink" title="let有无变量提升"></a><strong>let有无变量提升</strong></h2><p>①let有无变量提升取决于你如何定义变量提升。</p>
<p><strong>②若[变量提升」是指变量可在声明语句之前被调用，则let没有变量提升</strong>（一般的）;若[变量提升」是指变量在声明语句之前就被执行上下文记住，则let有变量提升。</p>
<p>③JS代码是即时编译与执行的，一个函数作用域会拥有一个执行上下文，执行上下文是一块存储空间。执行上下文内又有一个名为[变量环境」和「词法环境」的东西。</p>
<p>④由var和function声明的变量，在代码编译完成后，执行之前，其变量名和值就被存储在变量环境中了，所以在代码执行阶段的任何时刻，都可以调用它们，自然也能在声明语句之前调用了。</p>
<p>⑤由const和let声明的变量，在代码编译完成后、执行之前，其变量名被存储在词法环境中，代码执行过程中会从依据[词法环境→变量环境→闭包&#x2F;上一个作用域」的顺序来查找变量，而词法环境所存储的值被要求只有在声明语句之后才能调用。所以会存在暂时性死区，但变量又确确实实被执行上下文提前记住了，所以可以把暂时性死区理解为「变量暂时不能使用的阶段」。所以得出结论①</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[for 循环的let]]></title>
      <url>/2023/01/23/js%E9%AB%98%E7%BA%A7/for%20%E5%BE%AA%E7%8E%AF%E7%9A%84let/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> buo=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">             buo[i].<span class="property">num</span>=i；</span><br><span class="line">                buo[i].<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                   <span class="title function_">alert</span>(i); </span><br><span class="line">                &#125;</span><br><span class="line">       &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码会发现无论第几次点击按钮。i都等于5，因为点击事件需要鼠标触发才能发生</p>
<p>，循环中只是给按钮绑定了函数，并没有触发。当点击时，已经结束循环</p>
<p><strong><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</strong></p>
<p><strong>结合事件循环  先会 i 一直加加到5  再来执行回调函数 因为var没有块级作用域 所以最后的值为5</strong>  </p>
<p><strong>但let不一样 他有独立的块级作用域 每一次虽然在递增 但每一个变量都是独立存在的五个新变量 所以点击事件中的i是五个不同的i</strong> </p>
<p><strong>js引擎回味for循环中的let声明分别创造独立的变量实例</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node 后台大事件]]></title>
      <url>/2023/01/21/nodejs/ev_api_server/</url>
      <content type="html"><![CDATA[<h2 id="Headline"><a href="#Headline" class="headerlink" title="Headline"></a>Headline</h2><blockquote>
<p>大事件后台 API 项目，API 接口文档请参考 <a href="https://www.showdoc.cc/escook?page_id=3707158761215217">https://www.showdoc.cc/escook?page_id=3707158761215217</a></p>
</blockquote>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><h3 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h3><ol>
<li>新建 <code>api_server</code> 文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行如下的命令，安装特定版本的 <code>express</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express@4.17.1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在项目根目录中新建 <code>app.js</code> 作为整个项目的入口文件，并初始化如下的代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建 express 的服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// write your code here...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3007</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;api server running at http://127.0.0.1:3007&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-配置-cors-跨域"><a href="#1-2-配置-cors-跨域" class="headerlink" title="1.2 配置 cors 跨域"></a>1.2 配置 cors 跨域</h3><ol>
<li>运行如下的命令，安装 <code>cors</code> 中间件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cors@2.8.5</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中导入并配置 <code>cors</code> 中间件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 cors 中间件</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"><span class="comment">// 将 cors 注册为全局中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure>

<h3 id="1-3-配置解析表单数据的中间件"><a href="#1-3-配置解析表单数据的中间件" class="headerlink" title="1.3 配置解析表单数据的中间件"></a>1.3 配置解析表单数据的中间件</h3><ol>
<li>通过如下的代码，配置解析 <code>application/x-www-form-urlencoded</code> 格式的表单数据的中间件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure>

<h3 id="1-4-初始化路由相关的文件夹"><a href="#1-4-初始化路由相关的文件夹" class="headerlink" title="1.4 初始化路由相关的文件夹"></a>1.4 初始化路由相关的文件夹</h3><ol>
<li><p>在项目根目录中，新建 <code>router</code> 文件夹，用来存放所有的<code>路由</code>模块</p>
<blockquote>
<p>路由模块中，只存放客户端的请求与处理函数之间的映射关系</p>
</blockquote>
</li>
<li><p>在项目根目录中，新建 <code>router_handler</code> 文件夹，用来存放所有的 <code>路由处理函数模块</code></p>
<blockquote>
<p>路由处理函数模块中，专门负责存放每个路由对应的处理函数</p>
</blockquote>
</li>
</ol>
<h3 id="1-5-初始化用户路由模块"><a href="#1-5-初始化用户路由模块" class="headerlink" title="1.5 初始化用户路由模块"></a>1.5 初始化用户路由模块</h3><ol>
<li>在 <code>router</code> 文件夹中，新建 <code>user.js</code> 文件，作为用户的路由模块，并初始化代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/reguser&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;reguser OK&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;login OK&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由对象共享出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中，导入并使用 <code>用户路由模块</code> ：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并注册用户路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure>

<h3 id="1-6-抽离用户路由模块中的处理函数"><a href="#1-6-抽离用户路由模块中的处理函数" class="headerlink" title="1.6 抽离用户路由模块中的处理函数"></a>1.6 抽离用户路由模块中的处理函数</h3><blockquote>
<p>目的：为了保证 <code>路由模块</code> 的纯粹性，所有的 <code>路由处理函数</code>，必须抽离到对应的 <code>路由处理函数模块</code> 中</p>
</blockquote>
<ol>
<li>在 <code>/router_handler/user.js</code> 中，使用 <code>exports</code> 对象，分别向外共享如下两个 <code>路由处理函数</code> ：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册用户的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">regUser</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;reguser OK&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">login</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;login OK&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 <code>/router/user.js</code> 中的代码修改为如下结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userHandler = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/reguser&#x27;</span>, userHandler.<span class="property">regUser</span>)</span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, userHandler.<span class="property">login</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<h2 id="2-登录注册"><a href="#2-登录注册" class="headerlink" title="2. 登录注册"></a>2. 登录注册</h2><h3 id="2-1-新建-ev-users-表"><a href="#2-1-新建-ev-users-表" class="headerlink" title="2.1 新建 ev_users 表"></a>2.1 新建 ev_users 表</h3><ol>
<li>在 <code>my_db_01</code> 数据库中，新建 <code>ev_users</code> 表如下：<br><img src="/./images/1.jpg" alt="ev_users表结构"></li>
</ol>
<h3 id="2-2-安装并配置-mysql-模块"><a href="#2-2-安装并配置-mysql-模块" class="headerlink" title="2.2 安装并配置 mysql 模块"></a>2.2 安装并配置 mysql 模块</h3><blockquote>
<p>在 API 接口项目中，需要安装并配置 <code>mysql</code> 这个第三方模块，来连接和操作 MySQL 数据库</p>
</blockquote>
<ol>
<li>运行如下命令，安装 <code>mysql</code> 模块：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mysql@2.18.1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在项目根目录中新建 <code>/db/index.js</code> 文件，在此自定义模块中创建数据库的连接对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 mysql 模块</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库连接对象</span></span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;admin123&#x27;</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;my_db_01&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享 db 数据库连接对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = db</span><br></pre></td></tr></table></figure>

<h3 id="2-3-注册"><a href="#2-3-注册" class="headerlink" title="2.3 注册"></a>2.3 注册</h3><h4 id="2-3-0-实现步骤"><a href="#2-3-0-实现步骤" class="headerlink" title="2.3.0 实现步骤"></a>2.3.0 实现步骤</h4><ol>
<li>检测表单数据是否合法</li>
<li>检测用户名是否被占用</li>
<li>对密码进行加密处理</li>
<li>插入新用户</li>
</ol>
<h4 id="2-3-1-检测表单数据是否合法"><a href="#2-3-1-检测表单数据是否合法" class="headerlink" title="2.3.1 检测表单数据是否合法"></a>2.3.1 检测表单数据是否合法</h4><ol>
<li>判断用户名和密码是否为空</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收表单数据</span></span><br><span class="line"><span class="keyword">const</span> userinfo = req.<span class="property">body</span></span><br><span class="line"><span class="comment">// 判断数据是否合法</span></span><br><span class="line"><span class="keyword">if</span> (!userinfo.<span class="property">username</span> || !userinfo.<span class="property">password</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;用户名或密码不能为空！&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-检测用户名是否被占用"><a href="#2-3-2-检测用户名是否被占用" class="headerlink" title="2.3.2 检测用户名是否被占用"></a>2.3.2 检测用户名是否被占用</h4><ol>
<li>导入数据库操作模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db/index&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where username=?`</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 SQL 语句并根据结果判断用户名是否被占用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, [userinfo.<span class="property">username</span>], <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: err.<span class="property">message</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用户名被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;用户名被占用，请更换其他用户名！&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 用户名可用，继续后续流程...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-对密码进行加密处理"><a href="#2-3-3-对密码进行加密处理" class="headerlink" title="2.3.3 对密码进行加密处理"></a>2.3.3 对密码进行加密处理</h4><blockquote>
<p>为了保证密码的安全性，不建议在数据库以 <code>明文</code> 的形式保存用户密码，推荐对密码进行 <code>加密存储</code></p>
</blockquote>
<hr>
<p>在当前项目中，使用 <code>bcryptjs</code> 对用户密码进行加密，优点：</p>
<ul>
<li>加密之后的密码，<strong>无法被逆向破解</strong></li>
<li>同一明文密码多次加密，得到的<strong>加密结果各不相同</strong>，保证了安全性</li>
</ul>
<hr>
<ol>
<li>运行如下命令，安装指定版本的 <code>bcryptjs</code> ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i bcryptjs@2.4.3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/user.js</code> 中，导入 <code>bcryptjs</code> ：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在注册用户的处理函数中，确认用户名可用之后，调用 <code>bcrypt.hashSync(明文密码, 随机盐的长度)</code> 方法，对用户的密码进行加密处理：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串</span></span><br><span class="line">userinfo.<span class="property">password</span> = bcrypt.<span class="title function_">hashSync</span>(userinfo.<span class="property">password</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-插入新用户"><a href="#2-3-4-插入新用户" class="headerlink" title="2.3.4 插入新用户"></a>2.3.4 插入新用户</h4><ol>
<li>定义插入用户的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;insert into ev_users set ?&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句，插入新用户：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, &#123; <span class="attr">username</span>: userinfo.<span class="property">username</span>, <span class="attr">password</span>: userinfo.<span class="property">password</span> &#125;, <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: err.<span class="property">message</span> &#125;)</span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但影响行数不为 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;注册用户失败，请稍后再试！&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册成功</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="string">&#x27;注册成功！&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-优化-res-send-代码"><a href="#2-4-优化-res-send-代码" class="headerlink" title="2.4 优化 res.send() 代码"></a>2.4 优化 res.send() 代码</h3><blockquote>
<p>在处理函数中，需要多次调用 <code>res.send()</code> 向客户端响应 <code>处理失败</code> 的结果，为了简化代码，可以手动封装一个 res.cc() 函数</p>
</blockquote>
<ol>
<li>在 <code>app.js</code> 中，所有路由之前，声明一个全局中间件，为 res 对象挂载一个 <code>res.cc()</code> 函数 ：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应数据的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况</span></span><br><span class="line">  res.<span class="property">cc</span> = <span class="keyword">function</span> (<span class="params">err, status = <span class="number">1</span></span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">      status,</span><br><span class="line">      <span class="comment">// 状态描述，判断 err 是 错误对象 还是 字符串</span></span><br><span class="line">      <span class="attr">message</span>: err <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? err.<span class="property">message</span> : err,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-优化表单数据验证"><a href="#2-5-优化表单数据验证" class="headerlink" title="2.5 优化表单数据验证"></a>2.5 优化表单数据验证</h3><blockquote>
<p>表单验证的原则：前端验证为辅，后端验证为主，后端<strong>永远不要相信</strong>前端提交过来的<strong>任何内容</strong></p>
</blockquote>
<p>在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，<strong>后端做为数据合法性验证的最后一个关口</strong>，在拦截非法数据方面，起到了至关重要的作用。</p>
<p>单纯的使用 <code>if...else...</code> 的形式对数据合法性进行验证，效率低下、出错率高、维护性差。因此，推荐使用<strong>第三方数据验证模块</strong>，来降低出错率、提高验证的效率与可维护性，<strong>让后端程序员把更多的精力放在核心业务逻辑的处理上</strong>。</p>
<ol>
<li>安装 <code>@hapi/joi</code> 包，为表单中携带的每个数据项，定义验证规则：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @hapi/joi@17.1.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 <code>@escook/express-joi</code> 中间件，来实现自动对表单数据进行验证的功能：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @escook/express-joi</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>新建 <code>/schema/user.js</code> 用户信息验证规则模块，并初始化代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;@hapi/joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * string() 值必须是字符串</span></span><br><span class="line"><span class="comment"> * alphanum() 值只能是包含 a-zA-Z0-9 的字符串</span></span><br><span class="line"><span class="comment"> * min(length) 最小长度</span></span><br><span class="line"><span class="comment"> * max(length) 最大长度</span></span><br><span class="line"><span class="comment"> * required() 值是必填项，不能为 undefined</span></span><br><span class="line"><span class="comment"> * pattern(正则表达式) 值必须符合正则表达式的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户名的验证规则</span></span><br><span class="line"><span class="keyword">const</span> username = joi.<span class="title function_">string</span>().<span class="title function_">alphanum</span>().<span class="title function_">min</span>(<span class="number">1</span>).<span class="title function_">max</span>(<span class="number">10</span>).required()</span><br><span class="line"><span class="comment">// 密码的验证规则</span></span><br><span class="line"><span class="keyword">const</span> password = joi</span><br><span class="line">  .<span class="title function_">string</span>()</span><br><span class="line">  .<span class="title function_">pattern</span>(<span class="regexp">/^[\S]&#123;6,12&#125;$/</span>)</span><br><span class="line">  .required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册和登录表单的验证规则对象</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">reg_login_schema</span> = &#123;</span><br><span class="line">  <span class="comment">// 表示需要对 req.body 中的数据进行验证</span></span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    username,</span><br><span class="line">    password,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改 <code>/router/user.js</code> 中的代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userHandler = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; reg_login_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line"><span class="comment">// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证</span></span><br><span class="line"><span class="comment">// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数</span></span><br><span class="line"><span class="comment">// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/reguser&#x27;</span>, <span class="title function_">expressJoi</span>(reg_login_schema), userHandler.<span class="property">regUser</span>)</span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, userHandler.<span class="property">login</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>app.js</code> 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;@hapi/joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 数据验证失败</span></span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> joi.<span class="property">ValidationError</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line">  <span class="comment">// 未知错误</span></span><br><span class="line">  res.<span class="title function_">cc</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-登录"><a href="#2-6-登录" class="headerlink" title="2.6 登录"></a>2.6 登录</h3><h4 id="2-6-0-实现步骤"><a href="#2-6-0-实现步骤" class="headerlink" title="2.6.0 实现步骤"></a>2.6.0 实现步骤</h4><ol>
<li>检测表单数据是否合法</li>
<li>根据用户名查询用户的数据</li>
<li>判断用户输入的密码是否正确</li>
<li>生成 JWT 的 Token 字符串</li>
</ol>
<h4 id="2-6-1-检测登录表单的数据是否合法"><a href="#2-6-1-检测登录表单的数据是否合法" class="headerlink" title="2.6.1 检测登录表单的数据是否合法"></a>2.6.1 检测登录表单的数据是否合法</h4><ol>
<li>将 <code>/router/user.js</code> 中 <code>登录</code> 的路由代码修改如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="title function_">expressJoi</span>(reg_login_schema), userHandler.<span class="property">login</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-根据用户名查询用户的数据"><a href="#2-6-2-根据用户名查询用户的数据" class="headerlink" title="2.6.2 根据用户名查询用户的数据"></a>2.6.2 根据用户名查询用户的数据</h4><ol>
<li>接收表单数据：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userinfo = req.<span class="property">body</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where username=?`</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 SQL 语句，查询用户的数据：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, userinfo.<span class="property">username</span>, <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是查询到数据条数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;登录失败！&#x27;</span>)</span><br><span class="line">  <span class="comment">// TODO：判断用户输入的登录密码是否和数据库中的密码一致</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-判断用户输入的密码是否正确"><a href="#2-6-3-判断用户输入的密码是否正确" class="headerlink" title="2.6.3 判断用户输入的密码是否正确"></a>2.6.3 判断用户输入的密码是否正确</h4><blockquote>
<p>核心实现思路：调用 <code>bcrypt.compareSync(用户提交的密码, 数据库中的密码)</code> 方法比较密码是否一致</p>
</blockquote>
<blockquote>
<p>返回值是布尔值（true 一致、false 不一致）</p>
</blockquote>
<p>具体的实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿着用户输入的密码,和数据库中存储的密码进行对比</span></span><br><span class="line"><span class="keyword">const</span> compareResult = bcrypt.<span class="title function_">compareSync</span>(userinfo.<span class="property">password</span>, results[<span class="number">0</span>].<span class="property">password</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对比的结果等于 false, 则证明用户输入的密码错误</span></span><br><span class="line"><span class="keyword">if</span> (!compareResult) &#123;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;登录失败！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO：登录成功，生成 Token 字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-生成-JWT-的-Token-字符串"><a href="#2-6-4-生成-JWT-的-Token-字符串" class="headerlink" title="2.6.4 生成 JWT 的 Token 字符串"></a>2.6.4 生成 JWT 的 Token 字符串</h4><blockquote>
<p>核心注意点：在生成 Token 字符串的时候，一定要剔除 <strong>密码</strong> 和 <strong>头像</strong> 的值</p>
</blockquote>
<ol>
<li>通过 ES6 的高级语法，快速剔除 <code>密码</code> 和 <code>头像</code> 的值：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值</span></span><br><span class="line"><span class="keyword">const</span> user = &#123; ...results[<span class="number">0</span>], <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">user_pic</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行如下的命令，安装生成 Token 字符串的包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jsonwebtoken@8.5.1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>/router_handler/user.js</code> 模块的头部区域，导入 <code>jsonwebtoken</code> 包：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用这个包来生成 Token 字符串</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建 <code>config.js</code> 文件，并向外共享 <strong>加密</strong> 和 <strong>还原</strong> Token 的 <code>jwtSecretKey</code> 字符串：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">jwtSecretKey</span>: <span class="string">&#x27;itheima No1. ^_^&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将用户信息对象加密成 Token 字符串：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 Token 字符串</span></span><br><span class="line"><span class="keyword">const</span> tokenStr = jwt.<span class="title function_">sign</span>(user, config.<span class="property">jwtSecretKey</span>, &#123;</span><br><span class="line">  <span class="attr">expiresIn</span>: <span class="string">&#x27;10h&#x27;</span>, <span class="comment">// token 有效期为 10 个小时</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将生成的 Token 字符串响应给客户端：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">send</span>(&#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;登录成功！&#x27;</span>,</span><br><span class="line">  <span class="comment">// 为了方便客户端使用 Token，在服务器端直接拼接上 Bearer 的前缀</span></span><br><span class="line">  <span class="attr">token</span>: <span class="string">&#x27;Bearer &#x27;</span> + tokenStr,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-7-配置解析-Token-的中间件"><a href="#2-7-配置解析-Token-的中间件" class="headerlink" title="2.7 配置解析 Token 的中间件"></a>2.7 配置解析 Token 的中间件</h3><ol>
<li>运行如下的命令，安装解析 Token 的中间件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express-jwt@<span class="number">5.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中注册路由之前，配置解析 Token 的中间件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 token 的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 .unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口不需要进行 Token 的身份认证</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: config.<span class="property">jwtSecretKey</span> &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>app.js</code> 中的 <code>错误级别中间件</code> 里面，捕获并处理 Token 认证失败后的错误：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 捕获身份认证失败的错误</span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> === <span class="string">&#x27;UnauthorizedError&#x27;</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;身份认证失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未知错误...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-个人中心"><a href="#3-个人中心" class="headerlink" title="3. 个人中心"></a>3. 个人中心</h2><h3 id="3-1-获取用户的基本信息"><a href="#3-1-获取用户的基本信息" class="headerlink" title="3.1 获取用户的基本信息"></a>3.1 获取用户的基本信息</h3><h4 id="3-1-0-实现步骤"><a href="#3-1-0-实现步骤" class="headerlink" title="3.1.0 实现步骤"></a>3.1.0 实现步骤</h4><ol>
<li>初始化 <strong>路由</strong> 模块</li>
<li>初始化 <strong>路由处理函数</strong> 模块</li>
<li>获取用户的基本信息</li>
</ol>
<h4 id="3-1-1-初始化路由模块"><a href="#3-1-1-初始化路由模块" class="headerlink" title="3.1.1 初始化路由模块"></a>3.1.1 初始化路由模块</h4><ol>
<li>创建 <code>/router/userinfo.js</code> 路由模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户的基本信息</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/userinfo&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中导入并使用个人中心的路由模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户信息路由模块</span></span><br><span class="line"><span class="keyword">const</span> userinfoRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/userinfo&#x27;</span>)</span><br><span class="line"><span class="comment">// 注意：以 /my 开头的接口，都是有权限的接口，需要进行 Token 身份认证</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/my&#x27;</span>, userinfoRouter)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-初始化路由处理函数模块"><a href="#3-1-2-初始化路由处理函数模块" class="headerlink" title="3.1.2 初始化路由处理函数模块"></a>3.1.2 初始化路由处理函数模块</h4><ol>
<li>创建 <code>/router_handler/userinfo.js</code> 路由处理函数模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户基本信息的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">getUserInfo</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 <code>/router/userinfo.js</code> 中的代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户信息的处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userinfo_handler = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/userinfo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户的基本信息</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/userinfo&#x27;</span>, userinfo_handler.<span class="property">getUserInfo</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-获取用户的基本信息"><a href="#3-1-3-获取用户的基本信息" class="headerlink" title="3.1.3 获取用户的基本信息"></a>3.1.3 获取用户的基本信息</h4><ol>
<li>在 <code>/router_handler/userinfo.js</code> 头部导入数据库操作模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db/index&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据用户的 id，查询用户的基本信息</span></span><br><span class="line"><span class="comment">// 注意：为了防止用户的密码泄露，需要排除 password 字段</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select id, username, nickname, email, user_pic from ev_users where id=?`</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 <code>db.query()</code> 执行 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：req 对象上的 user 属性，是 Token 解析成功，express-jwt 中间件帮我们挂载上去的</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, req.<span class="property">user</span>.<span class="property">id</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行 SQL 语句成功，但是查询到的数据条数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;获取用户信息失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将用户信息响应给客户端</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;获取用户基本信息成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: results[<span class="number">0</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-更新用户的基本信息"><a href="#3-2-更新用户的基本信息" class="headerlink" title="3.2 更新用户的基本信息"></a>3.2 更新用户的基本信息</h3><h4 id="3-2-0-实现步骤"><a href="#3-2-0-实现步骤" class="headerlink" title="3.2.0 实现步骤"></a>3.2.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现更新用户基本信息的功能</li>
</ol>
<h4 id="3-2-1-定义路由和处理函数"><a href="#3-2-1-定义路由和处理函数" class="headerlink" title="3.2.1 定义路由和处理函数"></a>3.2.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/userinfo.js</code> 模块中，新增 <code>更新用户基本信息</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新用户的基本信息</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/userinfo&#x27;</span>, userinfo_handler.<span class="property">updateUserInfo</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>更新用户基本信息</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新用户基本信息的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">updateUserInfo</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-验证表单数据"><a href="#3-2-2-验证表单数据" class="headerlink" title="3.2.2 验证表单数据"></a>3.2.2 验证表单数据</h4><ol>
<li>在 <code>/schema/user.js</code> 验证规则模块中，定义 <code>id</code>，<code>nickname</code>，<code>email</code> 的验证规则如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 id, nickname, emial 的验证规则</span></span><br><span class="line"><span class="keyword">const</span> id = joi.<span class="title function_">number</span>().<span class="title function_">integer</span>().<span class="title function_">min</span>(<span class="number">1</span>).required()</span><br><span class="line"><span class="keyword">const</span> nickname = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> email = joi.<span class="title function_">string</span>().<span class="title function_">email</span>().required()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 更新用户基本信息</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">update_userinfo_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    id,</span><br><span class="line">    nickname,</span><br><span class="line">    email,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>/router/userinfo.js</code> 模块中，导入验证数据合法性的中间件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据合法性的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_userinfo_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>/router/userinfo.js</code> 模块中，修改 <code>更新用户的基本信息</code> 的路由如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新用户的基本信息</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/userinfo&#x27;</span>, <span class="title function_">expressJoi</span>(update_userinfo_schema), userinfo_handler.<span class="property">updateUserInfo</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-实现更新用户基本信息的功能"><a href="#3-2-3-实现更新用户基本信息的功能" class="headerlink" title="3.2.3 实现更新用户基本信息的功能"></a>3.2.3 实现更新用户基本信息的功能</h4><ol>
<li>定义待执行的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_users set ? where id=?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句并传参：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, [req.<span class="property">body</span>, req.<span class="property">body</span>.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但影响行数不为 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;修改用户基本信息失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改用户信息成功</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;修改用户基本信息成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-重置密码"><a href="#3-3-重置密码" class="headerlink" title="3.3 重置密码"></a>3.3 重置密码</h3><h4 id="3-3-0-实现步骤"><a href="#3-3-0-实现步骤" class="headerlink" title="3.3.0 实现步骤"></a>3.3.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现重置密码的功能</li>
</ol>
<h4 id="3-3-1-定义路由和处理函数"><a href="#3-3-1-定义路由和处理函数" class="headerlink" title="3.3.1 定义路由和处理函数"></a>3.3.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/userinfo.js</code> 模块中，新增 <code>重置密码</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置密码的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/updatepwd&#x27;</span>, userinfo_handler.<span class="property">updatePassword</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>重置密码</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置密码的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">updatePassword</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-验证表单数据"><a href="#3-3-2-验证表单数据" class="headerlink" title="3.3.2 验证表单数据"></a>3.3.2 验证表单数据</h4><blockquote>
<p>核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！</p>
</blockquote>
<ol>
<li>在 <code>/schema/user.js</code> 模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 重置密码</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">update_password_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用 password 这个规则，验证 req.body.oldPwd 的值</span></span><br><span class="line">    <span class="attr">oldPwd</span>: password,</span><br><span class="line">    <span class="comment">// 使用 joi.not(joi.ref(&#x27;oldPwd&#x27;)).concat(password) 规则，验证 req.body.newPwd 的值</span></span><br><span class="line">    <span class="comment">// 解读：</span></span><br><span class="line">    <span class="comment">// 1. joi.ref(&#x27;oldPwd&#x27;) 表示 newPwd 的值必须和 oldPwd 的值保持一致</span></span><br><span class="line">    <span class="comment">// 2. joi.not(joi.ref(&#x27;oldPwd&#x27;)) 表示 newPwd 的值不能等于 oldPwd 的值</span></span><br><span class="line">    <span class="comment">// 3. .concat() 用于合并 joi.not(joi.ref(&#x27;oldPwd&#x27;)) 和 password 这两条验证规则</span></span><br><span class="line">    <span class="attr">newPwd</span>: joi.<span class="title function_">not</span>(joi.<span class="title function_">ref</span>(<span class="string">&#x27;oldPwd&#x27;</span>)).<span class="title function_">concat</span>(password),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_userinfo_schema, update_password_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>并在 <code>重置密码的路由</code> 中，使用 <code>update_password_schema</code> 规则验证表单的数据，示例代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/updatepwd&#x27;</span>, <span class="title function_">expressJoi</span>(update_password_schema), userinfo_handler.<span class="property">updatePassword</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-实现重置密码的功能"><a href="#3-3-3-实现重置密码的功能" class="headerlink" title="3.3.3 实现重置密码的功能"></a>3.3.3 实现重置密码的功能</h4><ol>
<li>根据 <code>id</code> 查询用户是否存在：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义根据 id 查询用户数据的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where id=?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句查询用户是否存在</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, req.<span class="property">user</span>.<span class="property">id</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查指定 id 的用户是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;用户不存在！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：判断提交的旧密码是否正确</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断提交的 <strong>旧密码</strong> 是否正确：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头部区域导入 bcryptjs 后，</span></span><br><span class="line"><span class="comment">// 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确</span></span><br><span class="line"><span class="comment">// compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断提交的旧密码是否正确</span></span><br><span class="line"><span class="keyword">const</span> compareResult = bcrypt.<span class="title function_">compareSync</span>(req.<span class="property">body</span>.<span class="property">oldPwd</span>, results[<span class="number">0</span>].<span class="property">password</span>)</span><br><span class="line"><span class="keyword">if</span> (!compareResult) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;原密码错误！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对新密码进行 <code>bcrypt</code> 加密之后，更新到数据库中：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义更新用户密码的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_users set password=? where id=?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对新密码进行 bcrypt 加密处理</span></span><br><span class="line"><span class="keyword">const</span> newPwd = bcrypt.<span class="title function_">hashSync</span>(req.<span class="property">body</span>.<span class="property">newPwd</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句，根据 id 更新用户的密码</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [newPwd, req.<span class="property">user</span>.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// SQL 语句执行失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;更新密码失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新密码成功</span></span><br><span class="line">  res.<span class="title function_">cc</span>(<span class="string">&#x27;更新密码成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-更新用户头像"><a href="#3-4-更新用户头像" class="headerlink" title="3.4 更新用户头像"></a>3.4 更新用户头像</h3><h4 id="3-4-0-实现步骤"><a href="#3-4-0-实现步骤" class="headerlink" title="3.4.0 实现步骤"></a>3.4.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现更新用户头像的功能</li>
</ol>
<h4 id="3-4-1-定义路由和处理函数"><a href="#3-4-1-定义路由和处理函数" class="headerlink" title="3.4.1 定义路由和处理函数"></a>3.4.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/userinfo.js</code> 模块中，新增 <code>更新用户头像</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新用户头像的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/update/avatar&#x27;</span>, userinfo_handler.<span class="property">updateAvatar</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>更新用户头像</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新用户头像的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">updateAvatar</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-验证表单数据"><a href="#3-4-2-验证表单数据" class="headerlink" title="3.4.2 验证表单数据"></a>3.4.2 验证表单数据</h4><ol>
<li>在 <code>/schema/user.js</code> 验证规则模块中，定义 <code>avatar</code> 的验证规则如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataUri() 指的是如下格式的字符串数据：</span></span><br><span class="line"><span class="comment">// data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=</span></span><br><span class="line"><span class="keyword">const</span> avatar = joi.<span class="title function_">string</span>().<span class="title function_">dataUri</span>().required()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 更新头像</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">update_avatar_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    avatar,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; update_avatar_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>/router/userinfo.js</code> 模块中，修改 <code>更新用户头像</code> 的路由如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/update/avatar&#x27;</span>, <span class="title function_">expressJoi</span>(update_avatar_schema), userinfo_handler.<span class="property">updateAvatar</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-3-实现更新用户头像的功能"><a href="#3-4-3-实现更新用户头像的功能" class="headerlink" title="3.4.3 实现更新用户头像的功能"></a>3.4.3 实现更新用户头像的功能</h4><ol>
<li>定义更新用户头像的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;update ev_users set user_pic=? where id=?&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句，更新对应用户的头像：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, [req.<span class="property">body</span>.<span class="property">avatar</span>, req.<span class="property">user</span>.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;更新头像失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新用户头像成功</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;更新头像成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-文章分类管理"><a href="#4-文章分类管理" class="headerlink" title="4. 文章分类管理"></a>4. 文章分类管理</h2><h3 id="4-1-新建-ev-article-cate-表"><a href="#4-1-新建-ev-article-cate-表" class="headerlink" title="4.1 新建 ev_article_cate 表"></a>4.1 新建 ev_article_cate 表</h3><h4 id="4-1-1-创建表结构"><a href="#4-1-1-创建表结构" class="headerlink" title="4.1.1 创建表结构"></a>4.1.1 创建表结构</h4><p><img src="/./images/2.jpg" alt="文章分类表结构"></p>
<h4 id="4-1-2-新增两条初始数据"><a href="#4-1-2-新增两条初始数据" class="headerlink" title="4.1.2 新增两条初始数据"></a>4.1.2 新增两条初始数据</h4><p><img src="/./images/3.jpg" alt="文章分类表结构"></p>
<h3 id="4-2-获取文章分类列表"><a href="#4-2-获取文章分类列表" class="headerlink" title="4.2 获取文章分类列表"></a>4.2 获取文章分类列表</h3><h4 id="4-2-0-实现步骤"><a href="#4-2-0-实现步骤" class="headerlink" title="4.2.0 实现步骤"></a>4.2.0 实现步骤</h4><ol>
<li>初始化路由模块</li>
<li>初始化路由处理函数模块</li>
<li>获取文章分类列表数据</li>
</ol>
<h4 id="4-2-1-初始化路由模块"><a href="#4-2-1-初始化路由模块" class="headerlink" title="4.2.1 初始化路由模块"></a>4.2.1 初始化路由模块</h4><ol>
<li>创建 <code>/router/artcate.js</code> 路由模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文章分类的列表数据</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/cates&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中导入并使用文章分类的路由模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并使用文章分类路由模块</span></span><br><span class="line"><span class="keyword">const</span> artCateRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/artcate&#x27;</span>)</span><br><span class="line"><span class="comment">// 为文章分类的路由挂载统一的访问前缀 /my/article</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/my/article&#x27;</span>, artCateRouter)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-初始化路由处理函数模块"><a href="#4-2-2-初始化路由处理函数模块" class="headerlink" title="4.2.2 初始化路由处理函数模块"></a>4.2.2 初始化路由处理函数模块</h4><ol>
<li>创建 <code>/router_handler/artcate.js</code> 路由处理函数模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文章分类列表数据的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">getArticleCates</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 <code>/router/artcate.js</code> 中的代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入文章分类的路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> artcate_handler = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/artcate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文章分类的列表数据</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/cates&#x27;</span>, artcate_handler.<span class="property">getArticleCates</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-获取文章分类列表数据"><a href="#4-2-3-获取文章分类列表数据" class="headerlink" title="4.2.3 获取文章分类列表数据"></a>4.2.3 获取文章分类列表数据</h4><ol>
<li>在 <code>/router_handler/artcate.js</code> 头部导入数据库操作模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db/index&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据分类的状态，获取所有未被删除的分类列表数据</span></span><br><span class="line"><span class="comment">// is_delete 为 0 表示没有被 标记为删除 的数据</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;select * from ev_article_cate where is_delete=0 order by id asc&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 <code>db.query()</code> 执行 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行 SQL 语句成功</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;获取文章分类列表成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: results,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-新增文章分类"><a href="#4-3-新增文章分类" class="headerlink" title="4.3 新增文章分类"></a>4.3 新增文章分类</h3><h4 id="4-3-0-实现步骤"><a href="#4-3-0-实现步骤" class="headerlink" title="4.3.0 实现步骤"></a>4.3.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>查询 <code>分类名称</code> 与 <code>分类别名</code> 是否被占用</li>
<li>实现新增文章分类的功能</li>
</ol>
<h4 id="4-3-1-定义路由和处理函数"><a href="#4-3-1-定义路由和处理函数" class="headerlink" title="4.3.1 定义路由和处理函数"></a>4.3.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/artcate.js</code> 模块中，添加 <code>新增文章分类</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增文章分类的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/addcates&#x27;</span>, artcate_handler.<span class="property">addArticleCates</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>新增文章分类</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增文章分类的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">addArticleCates</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-验证表单数据"><a href="#4-3-2-验证表单数据" class="headerlink" title="4.3.2 验证表单数据"></a>4.3.2 验证表单数据</h4><ol>
<li>创建 <code>/schema/artcate.js</code> 文章分类数据验证模块，并定义如下的验证规则：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入定义验证规则的模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;@hapi/joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 分类名称 和 分类别名 的校验规则</span></span><br><span class="line"><span class="keyword">const</span> name = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> alias = joi.<span class="title function_">string</span>().<span class="title function_">alphanum</span>().required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验规则对象 - 添加分类</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add_cate_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    name,</span><br><span class="line">    alias,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router/artcate.js</code> 模块中，使用 <code>add_cate_schema</code> 对数据进行验证：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入文章分类的验证模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; add_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/artcate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增文章分类的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/addcates&#x27;</span>, <span class="title function_">expressJoi</span>(add_cate_schema), artcate_handler.<span class="property">addArticleCates</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-查询分类名称与别名是否被占用"><a href="#4-3-3-查询分类名称与别名是否被占用" class="headerlink" title="4.3.3 查询分类名称与别名是否被占用"></a>4.3.3 查询分类名称与别名是否被占用</h4><ol>
<li>定义查重的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where name=? or alias=?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行查重的操作：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行查重操作</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [req.<span class="property">body</span>.<span class="property">name</span>, req.<span class="property">body</span>.<span class="property">alias</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类名称与别名被占用，请更换后重试！&#x27;</span>)</span><br><span class="line">  <span class="comment">// 分别判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].<span class="property">name</span> === req.<span class="property">body</span>.<span class="property">name</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类名称被占用，请更换后重试！&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].<span class="property">alias</span> === req.<span class="property">body</span>.<span class="property">alias</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类别名被占用，请更换后重试！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：新增文章分类</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-实现新增文章分类的功能"><a href="#4-3-4-实现新增文章分类的功能" class="headerlink" title="4.3.4 实现新增文章分类的功能"></a>4.3.4 实现新增文章分类的功能</h4><ol>
<li>定义新增文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`insert into ev_article_cate set ?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行新增文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, req.<span class="property">body</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// SQL 语句执行失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;新增文章分类失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增文章分类成功</span></span><br><span class="line">  res.<span class="title function_">cc</span>(<span class="string">&#x27;新增文章分类成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-根据-Id-删除文章分类"><a href="#4-4-根据-Id-删除文章分类" class="headerlink" title="4.4 根据 Id 删除文章分类"></a>4.4 根据 Id 删除文章分类</h3><h4 id="4-4-0-实现步骤"><a href="#4-4-0-实现步骤" class="headerlink" title="4.4.0 实现步骤"></a>4.4.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现删除文章分类的功能</li>
</ol>
<h4 id="4-4-1-定义路由和处理函数"><a href="#4-4-1-定义路由和处理函数" class="headerlink" title="4.4.1 定义路由和处理函数"></a>4.4.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/artcate.js</code> 模块中，添加 <code>删除文章分类</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除文章分类的路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/deletecate/:id&#x27;</span>, artcate_handler.<span class="property">deleteCateById</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>删除文章分类</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除文章分类的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">deleteCateById</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-验证表单数据"><a href="#4-4-2-验证表单数据" class="headerlink" title="4.4.2 验证表单数据"></a>4.4.2 验证表单数据</h4><ol>
<li>在 <code>/schema/artcate.js</code> 验证规则模块中，定义 id 的验证规则如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 分类Id 的校验规则</span></span><br><span class="line"><span class="keyword">const</span> id = joi.<span class="title function_">number</span>().<span class="title function_">integer</span>().<span class="title function_">min</span>(<span class="number">1</span>).required()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 删除分类</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">delete_cate_schema</span> = &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    id,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入删除分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; delete_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/artcate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文章分类的路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/deletecate/:id&#x27;</span>, <span class="title function_">expressJoi</span>(delete_cate_schema), artcate_handler.<span class="property">deleteCateById</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-实现删除文章分类的功能"><a href="#4-4-3-实现删除文章分类的功能" class="headerlink" title="4.4.3 实现删除文章分类的功能"></a>4.4.3 实现删除文章分类的功能</h4><ol>
<li>定义删除文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_article_cate set is_delete=1 where id=?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行删除文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, req.<span class="property">params</span>.<span class="property">id</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;删除文章分类失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除文章分类成功</span></span><br><span class="line">  res.<span class="title function_">cc</span>(<span class="string">&#x27;删除文章分类成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-5-根据-Id-获取文章分类数据"><a href="#4-5-根据-Id-获取文章分类数据" class="headerlink" title="4.5 根据 Id 获取文章分类数据"></a>4.5 根据 Id 获取文章分类数据</h3><h4 id="4-5-0-实现步骤"><a href="#4-5-0-实现步骤" class="headerlink" title="4.5.0 实现步骤"></a>4.5.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现获取文章分类的功能</li>
</ol>
<h4 id="4-5-1-定义路由和处理函数"><a href="#4-5-1-定义路由和处理函数" class="headerlink" title="4.5.1 定义路由和处理函数"></a>4.5.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/artcate.js</code> 模块中，添加 <code>根据 Id 获取文章分类</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/cates/:id&#x27;</span>, artcate_handler.<span class="property">getArticleById</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>根据 Id 获取文章分类</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 Id 获取文章分类的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">getArticleById</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2-验证表单数据"><a href="#4-5-2-验证表单数据" class="headerlink" title="4.5.2 验证表单数据"></a>4.5.2 验证表单数据</h4><ol>
<li>在 <code>/schema/artcate.js</code> 验证规则模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 根据 Id 获取分类</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">get_cate_schema</span> = &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    id,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入根据 Id 获取分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; get_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/artcate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Id 获取文章分类的路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/cates/:id&#x27;</span>, <span class="title function_">expressJoi</span>(get_cate_schema), artcate_handler.<span class="property">getArticleById</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3-实现获取文章分类的功能"><a href="#4-5-3-实现获取文章分类的功能" class="headerlink" title="4.5.3 实现获取文章分类的功能"></a>4.5.3 实现获取文章分类的功能</h4><ol>
<li>定义根据 Id 获取文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where id=?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, req.<span class="property">params</span>.<span class="property">id</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是没有查询到任何数据</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;获取文章分类数据失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数据响应给客户端</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;获取文章分类数据成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: results[<span class="number">0</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-6-根据-Id-更新文章分类数据"><a href="#4-6-根据-Id-更新文章分类数据" class="headerlink" title="4.6 根据 Id 更新文章分类数据"></a>4.6 根据 Id 更新文章分类数据</h3><h4 id="4-6-0-实现步骤"><a href="#4-6-0-实现步骤" class="headerlink" title="4.6.0 实现步骤"></a>4.6.0 实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>查询 <code>分类名称</code> 与 <code>分类别名</code> 是否被占用</li>
<li>实现更新文章分类的功能</li>
</ol>
<h4 id="4-6-1-定义路由和处理函数"><a href="#4-6-1-定义路由和处理函数" class="headerlink" title="4.6.1 定义路由和处理函数"></a>4.6.1 定义路由和处理函数</h4><ol>
<li>在 <code>/router/artcate.js</code> 模块中，添加 <code>更新文章分类</code> 的路由：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新文章分类的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/updatecate&#x27;</span>, artcate_handler.<span class="property">updateCateById</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>更新文章分类</code> 的路由处理函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新文章分类的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">updateCateById</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-2-验证表单数据"><a href="#4-6-2-验证表单数据" class="headerlink" title="4.6.2 验证表单数据"></a>4.6.2 验证表单数据</h4><ol>
<li>在 <code>/schema/artcate.js</code> 验证规则模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 更新分类</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">update_cate_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    <span class="title class_">Id</span>: id,</span><br><span class="line">    name,</span><br><span class="line">    alias,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入更新文章分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/artcate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新文章分类的路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/updatecate&#x27;</span>, <span class="title function_">expressJoi</span>(update_cate_schema), artcate_handler.<span class="property">updateCateById</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-5-4-查询分类名称与别名是否被占用"><a href="#4-5-4-查询分类名称与别名是否被占用" class="headerlink" title="4.5.4 查询分类名称与别名是否被占用"></a>4.5.4 查询分类名称与别名是否被占用</h4><ol>
<li>定义查重的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where Id&lt;&gt;? and (name=? or alias=?)`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行查重的操作：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行查重操作</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [req.<span class="property">body</span>.<span class="property">Id</span>, req.<span class="property">body</span>.<span class="property">name</span>, req.<span class="property">body</span>.<span class="property">alias</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类名称与别名被占用，请更换后重试！&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].<span class="property">name</span> === req.<span class="property">body</span>.<span class="property">name</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类名称被占用，请更换后重试！&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].<span class="property">alias</span> === req.<span class="property">body</span>.<span class="property">alias</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;分类别名被占用，请更换后重试！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：更新文章分类</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-实现更新文章分类的功能"><a href="#4-5-5-实现更新文章分类的功能" class="headerlink" title="4.5.5 实现更新文章分类的功能"></a>4.5.5 实现更新文章分类的功能</h4><ol>
<li>定义更新文章分类的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_article_cate set ? where Id=?`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 <code>db.query()</code> 执行 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(sql, [req.<span class="property">body</span>, req.<span class="property">body</span>.<span class="property">Id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;更新文章分类失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新文章分类成功</span></span><br><span class="line">  res.<span class="title function_">cc</span>(<span class="string">&#x27;更新文章分类成功！&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-文章管理"><a href="#5-文章管理" class="headerlink" title="5. 文章管理"></a>5. 文章管理</h2><h3 id="5-1-新建-ev-articles-表"><a href="#5-1-新建-ev-articles-表" class="headerlink" title="5.1 新建 ev_articles 表"></a>5.1 新建 ev_articles 表</h3><p><img src="/./images/4.jpg" alt="ev_articles表结构"></p>
<h3 id="5-2-发布新文章"><a href="#5-2-发布新文章" class="headerlink" title="5.2 发布新文章"></a>5.2 发布新文章</h3><h4 id="5-2-0-实现步骤"><a href="#5-2-0-实现步骤" class="headerlink" title="5.2.0 实现步骤"></a>5.2.0 实现步骤</h4><ol>
<li>初始化路由模块</li>
<li>初始化路由处理函数模块</li>
<li>使用 multer 解析表单数据</li>
<li>验证表单数据</li>
<li>实现发布文章的功能</li>
</ol>
<h4 id="5-2-1-初始化路由模块"><a href="#5-2-1-初始化路由模块" class="headerlink" title="5.2.1 初始化路由模块"></a>5.2.1 初始化路由模块</h4><ol>
<li>创建 <code>/router/article.js</code> 路由模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/add&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>app.js</code> 中导入并使用文章的路由模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并使用文章路由模块</span></span><br><span class="line"><span class="keyword">const</span> articleRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/article&#x27;</span>)</span><br><span class="line"><span class="comment">// 为文章的路由挂载统一的访问前缀 /my/article</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/my/article&#x27;</span>, articleRouter)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-初始化路由处理函数模块"><a href="#5-2-2-初始化路由处理函数模块" class="headerlink" title="5.2.2 初始化路由处理函数模块"></a>5.2.2 初始化路由处理函数模块</h4><ol>
<li>创建 <code>/router_handler/article.js</code> 路由处理函数模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">addArticle</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 <code>/router/article.js</code> 中的代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入文章的路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> article_handler = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/article&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/add&#x27;</span>, article_handler.<span class="property">addArticle</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-使用-multer-解析表单数据"><a href="#5-2-3-使用-multer-解析表单数据" class="headerlink" title="5.2.3 使用 multer 解析表单数据"></a>5.2.3 使用 multer 解析表单数据</h4><blockquote>
<p>注意：使用 <code>express.urlencoded()</code> 中间件无法解析 <code>multipart/form-data</code> 格式的请求体数据。</p>
</blockquote>
<blockquote>
<p>当前项目，推荐使用 multer 来解析 <code>multipart/form-data</code> 格式的表单数据。<a href="https://www.npmjs.com/package/multer">https://www.npmjs.com/package/multer</a></p>
</blockquote>
<ol>
<li>运行如下的终端命令，在项目中安装 <code>multer</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i multer@1.4.2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router_handler/article.js</code> 模块中导入并配置 <code>multer</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入解析 formdata 格式表单数据的包</span></span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入处理路径的核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 multer 的实例对象，通过 dest 属性指定文件的存放路径</span></span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">dest</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../uploads&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <code>发布新文章</code> 的路由如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的路由</span></span><br><span class="line"><span class="comment">// upload.single() 是一个局部生效的中间件，用来解析 FormData 格式的表单数据</span></span><br><span class="line"><span class="comment">// 将文件类型的数据，解析并挂载到 req.file 属性中</span></span><br><span class="line"><span class="comment">// 将文本类型的数据，解析并挂载到 req.body 属性中</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/add&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;cover_img&#x27;</span>), article_handler.<span class="property">addArticle</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>/router_handler/article.js</code> 模块中的 <code>addArticle</code> 处理函数中，将 <code>multer</code> 解析出来的数据进行打印：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">addArticle</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>) <span class="comment">// 文本类型的数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------分割线----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">file</span>) <span class="comment">// 文件类型的数据</span></span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-验证表单数据"><a href="#5-2-4-验证表单数据" class="headerlink" title="5.2.4 验证表单数据"></a>5.2.4 验证表单数据</h4><blockquote>
<p>实现思路：通过 express-joi <strong>自动验证</strong> req.body 中的文本数据；通过 if 判断<strong>手动验证</strong> req.file 中的文件数据；</p>
</blockquote>
<ol>
<li>创建 <code>/schema/article.js</code> 验证规则模块，并初始化如下的代码结构：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入定义验证规则的模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;@hapi/joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 标题、分类Id、内容、发布状态 的验证规则</span></span><br><span class="line"><span class="keyword">const</span> title = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> cate_id = joi.<span class="title function_">number</span>().<span class="title function_">integer</span>().<span class="title function_">min</span>(<span class="number">1</span>).required()</span><br><span class="line"><span class="keyword">const</span> content = joi.<span class="title function_">string</span>().required().<span class="title function_">allow</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> state = joi.<span class="title function_">string</span>().<span class="title function_">valid</span>(<span class="string">&#x27;已发布&#x27;</span>, <span class="string">&#x27;草稿&#x27;</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证规则对象 - 发布文章</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add_article_schema</span> = &#123;</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    title,</span><br><span class="line">    cate_id,</span><br><span class="line">    content,</span><br><span class="line">    state,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>/router/article.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入文章的验证模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; add_article_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/article&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章的路由</span></span><br><span class="line"><span class="comment">// 注意：在当前的路由中，先后使用了两个中间件：</span></span><br><span class="line"><span class="comment">//       先使用 multer 解析表单数据</span></span><br><span class="line"><span class="comment">//       再使用 expressJoi 对解析的表单数据进行验证</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/add&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;cover_img&#x27;</span>), <span class="title function_">expressJoi</span>(add_article_schema), article_handler.<span class="property">addArticle</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>/router_handler/article.js</code> 模块中的 <code>addArticle</code> 处理函数中，通过 <code>if</code> 判断客户端是否提交了 <code>封面图片</code>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">addArticle</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 手动判断是否上传了文章封面</span></span><br><span class="line">  <span class="keyword">if</span> (!req.<span class="property">file</span> || req.<span class="property">file</span>.<span class="property">fieldname</span> !== <span class="string">&#x27;cover_img&#x27;</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;文章封面是必选参数！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：表单数据合法，继续后面的处理流程...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-5-实现发布文章的功能"><a href="#5-2-5-实现发布文章的功能" class="headerlink" title="5.2.5 实现发布文章的功能"></a>5.2.5 实现发布文章的功能</h4><ol>
<li>整理要插入数据库的文章信息对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的 path 核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> articleInfo = &#123;</span><br><span class="line">  <span class="comment">// 标题、内容、状态、所属的分类Id</span></span><br><span class="line">  ...req.<span class="property">body</span>,</span><br><span class="line">  <span class="comment">// 文章封面在服务器端的存放路径</span></span><br><span class="line">  <span class="attr">cover_img</span>: path.<span class="title function_">join</span>(<span class="string">&#x27;/uploads&#x27;</span>, req.<span class="property">file</span>.<span class="property">filename</span>),</span><br><span class="line">  <span class="comment">// 文章发布时间</span></span><br><span class="line">  <span class="attr">pub_date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">  <span class="comment">// 文章作者的Id</span></span><br><span class="line">  <span class="attr">author_id</span>: req.<span class="property">user</span>.<span class="property">id</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义发布文章的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`insert into ev_articles set ?`</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 <code>db.query()</code> 执行发布文章的 SQL 语句：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db/index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, articleInfo, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">cc</span>(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> !== <span class="number">1</span>) <span class="keyword">return</span> res.<span class="title function_">cc</span>(<span class="string">&#x27;发布文章失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布文章成功</span></span><br><span class="line">  res.<span class="title function_">cc</span>(<span class="string">&#x27;发布文章成功&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>app.js</code> 中，使用 <code>express.static()</code> 中间件，将 <code>uploads</code> 目录中的图片托管为静态资源：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 托管静态资源文件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/uploads&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;./uploads&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库的基本使用]]></title>
      <url>/2023/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>– 通过 * 把 users 表中所有的数据查询出来<br>– select * from users</p>
<p>– 从 users 表中把 username 和 password 对应的数据查询出来<br>– select username, password from users</p>
<p>– 向 users 表中，插入新数据，username 的值为 tony stark  password 的值为 098123<br>– insert into users (username, password) values (‘tony stark’, ‘098123’)<br>– select * from users</p>
<p>– 将 id 为 4 的用户密码，更新成 888888<br>– update users set password&#x3D;’888888’ where id&#x3D;4<br>– select * from users</p>
<p>– 更新 id 为 2 的用户，把用户密码更新为 admin123  同时，把用户的状态更新为 1<br>– update users set password&#x3D;’admin123’, status&#x3D;1 where id&#x3D;2<br>– select * from users</p>
<p>– 删除 users 表中， id 为 4 的用户<br>– delete from users where id&#x3D;4<br>– select * from users</p>
<p>– 演示 where 子句的使用<br>– select * from users where status&#x3D;1<br>– select * from users where id&gt;&#x3D;2<br>– select * from users where username&lt;&gt;’ls’<br>– select * from users where username!&#x3D;’ls’</p>
<p>– 使用 AND 来显示所有状态为0且id小于3的用户<br>– select * from users where status&#x3D;0 and id&lt;3</p>
<p>– 使用 or 来显示所有状态为1 或 username 为 zs 的用户<br>– select * from users where status&#x3D;1 or username&#x3D;’zs’</p>
<p>– 对users表中的数据，按照 status 字段进行升序排序<br>– select * from users order by status</p>
<p>– 按照 id 对结果进行降序的排序  desc 表示降序排序   asc 表示升序排序（默认情况下，就是升序排序的）<br>– select * from users order by id desc</p>
<p>– 对 users 表中的数据，先按照 status 进行降序排序，再按照 username 字母的顺序，进行升序的排序<br>– select * from users order by status desc, username asc</p>
<p>– 使用 count(<em>) 来统计 users 表中，状态为 0 用户的总数量<br>– select count(</em>) from users where status&#x3D;0</p>
<p>– 使用 AS 关键字给列起别名<br>– select count(*) as total from users where status&#x3D;0<br>– select username as uname, password as upwd from users</p>
<p><img src="/../images/image-20231007190846451.png" alt="image-20231007190846451"></p>
<h4 id="mysql-中修改字段数据类型"><a href="#mysql-中修改字段数据类型" class="headerlink" title="mysql 中修改字段数据类型"></a>mysql 中修改字段数据类型</h4><p>修改字段的数据类型就是把字段的数据类型转换成另一种数据类型。在 MySQL 中修改字段数据类型的语法规则如下：</p>
<p><strong>ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;</strong><br>其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。</p>
<p>不支持这种<img src="/../images/image-20231008131831837.png" alt="image-20231008131831837"></p>
<p>当需要修改MySQL数据库中的表时，常用的一些操作包括：</p>
<ol>
<li><p>添加列（ADD COLUMN）：使用ALTER TABLE语句可以添加新的列到现有的表中。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD COLUMN 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列（DROP COLUMN）：使用ALTER TABLE语句可以删除表中的列。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP COLUMN 列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列的数据类型（MODIFY COLUMN）：使用ALTER TABLE语句可以修改表中列的数据类型。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 列名 新数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列名（RENAME COLUMN）：使用ALTER TABLE语句可以修改表中列的名称。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME COLUMN 原列名 TO 新列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名（RENAME TABLE）：使用ALTER TABLE语句可以修改表的名称。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 原表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加主键（ADD PRIMARY KEY）：使用ALTER TABLE语句可以为表添加主键约束。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY (列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键（DROP PRIMARY KEY）：使用ALTER TABLE语句可以删除表的主键约束。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加外键（ADD FOREIGN KEY）：使用ALTER TABLE语句可以为表添加外键约束。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD FOREIGN KEY (列名) REFERENCES 关联表名(关联列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键（DROP FOREIGN KEY）：使用ALTER TABLE语句可以删除表的外键约束。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node处理跨域]]></title>
      <url>/2023/01/13/nodejs/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20230113001316400.png" alt="image-20230113001316400"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2023/01/13/nodejs/jsonp%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：jsonp实现跨域"><a href="#title：jsonp实现跨域" class="headerlink" title="title：jsonp实现跨域"></a>title：jsonp实现跨域</h2><p><img src="/../../images/image-20230113001209546.png" alt="image-20230113001209546"></p>
<p><img src="/../../images/image-20230113001225312.png" alt="image-20230113001225312"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[axios一些注意事项]]></title>
      <url>/2023/01/11/axios/</url>
      <content type="html"><![CDATA[<ol>
<li>axios 中获得一个promise对象 里面有六个对象    data才是服务器传过来的数据 3个 包括 state:状态码   msg:信息  data:数据</li>
</ol>
<p>​      </p>
<ol>
<li>axios post(上传数据)方法 需要将请求体放到body(请求体)里面       get(查询数据)查询方法需要将参数放到params</li>
<li>若某个方法的返回值是promise实例 则可以在前面添加await</li>
<li><img src="/../images/image-20230111165207504.png" alt="image-20230111165207504"></li>
</ol>
<p>​    </p>
<p>解构赋值先后面六个属性中解构出需要的data(里面是服务器传的三个属性),里面有个data  为防止data.data  可以把data重命名为res 这样就可以得到数据</p>
<h3 id="XHR和Fetch的-区别"><a href="#XHR和Fetch的-区别" class="headerlink" title="XHR和Fetch的 区别"></a>XHR和Fetch的 区别</h3><p><img src="/../images/image-20240203152427348.png" alt="image-20240203152427348"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[splice方法的使用]]></title>
      <url>/2023/01/11/es6/splice/</url>
      <content type="html"><![CDATA[<h3 id="splice-方法向-x2F-从数组添加-x2F-删除-x2F-替换项目，并返回删除的项目"><a href="#splice-方法向-x2F-从数组添加-x2F-删除-x2F-替换项目，并返回删除的项目" class="headerlink" title="splice() 方法向&#x2F;从数组添加&#x2F;删除&#x2F;替换项目，并返回删除的项目"></a>splice() 方法向&#x2F;从数组添加&#x2F;删除&#x2F;替换项目，并返回删除的项目</h3><p>注释：splice() 方法会改变原始数组。</p>
<p>语法：array.splice(index, howmany, item1, ….., itemX)</p>
<p>index	必需。整数，指定在什么位置添加&#x2F;删除项目，使用负值指定从数组末尾开始的位置。<br>howmany	可选。要删除的项目数。如果设置为 0，则不会删除任何项目。<br>item1, …, itemX	可选。要添加到数组中的新项目。</p>
<ol>
<li>删除项目，第一个参数为索引位置（从第几个索引开始），第二个参数为要删除几个。</li>
</ol>
<p>用法：array.splice(index,num)，返回值为删除内容，array为结果值。</p>
<ol start="2">
<li>添加项目（插入项目），第一个参数（插入位置），第二个参数（0） ，第三个参数（插入的项）。</li>
</ol>
<p>用法：array.splice(index,0,insertValue)，返回值为空数组，array值为最终结果值。</p>
<ol start="3">
<li>替换项目，第一个参数（起始位置），第二个参数（删除的项数），第三个参数（插入任意数量的项）。</li>
</ol>
<p>用法：array.splice(index,num,insertValue)，返回值为删除内容，array为结果值。</p>
<p> 数组置空   arr.length &#x3D; 0;    arr &#x3D; [ ];    arr.splice(0,arr.length);</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[map（parsenlt）]]></title>
      <url>/2023/01/07/es6/%E9%9D%A2%E8%AF%95%20map(parselnt)/</url>
      <content type="html"><![CDATA[<p><code> [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code> 的结果和原因？</p>
<p>在控制台中输入此表达式：</p>
<p>var arr &#x3D; [‘1’, ‘2’, ‘3’];<br>arr.map(parseInt)<br>&#x2F;&#x2F; [1, NaN, NaN]<br>结果是[1, NaN, NaN]，而不是[1, 2, 3]。原因是：两个函数的定义有冲突。下面详解：</p>
<p>map的定义<br>如下：</p>
<p>var new_array &#x3D; arr.map(function callback(currentValue[, index[, array]]) {<br>    &#x2F;&#x2F; Return element for new_array<br>}[, thisArg])<br>其中参数有一个函数callback，这个函数需要三个参数：</p>
<p>currentValue（必须）:处理的数组中的当前元素；<br>index（可选）：当前处理的元素在数组中的索引值；<br>array（可选）：调用map的数组。<br>thisArg（可选）：对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”。<br>所以，map函数接收的是两个参数，一个函数，另一个是thisArg。这里我们主要关注的是其中的函数接收三个参数，一个必须，两个可选。问题就是出现在这里，函数接收三个参数。</p>
<p>parseInt的定义<br> 这个函数用于解析一个字符串，并返回一个整数。定义如下：</p>
<p>parseInt(string, radix)<br>参数string（必须）：表示的是要被解析的字符串。<br>radix（可选）：表示表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。第二个可选参数，就是问题的另一来源了。<br>问题详解<br> 了解完两个函数的定义后，我们就知道[‘1’,’2’,’3’].map(parseInt)代码的问题了：</p>
<p>var arr &#x3D; [‘1’, ‘2’, ‘3’];<br>arr.map(parseInt);<br>我们通常以为上述代码中 arr.map(parseInt);表示的是</p>
<p>parseInt(“1”)<br>parseInt(“2”)<br>parseInt(“3”)<br>实际上应该是：</p>
<p>&#x2F;&#x2F;parseInt(当前值，当前元素在数组中的index，当前数组）<br>parseInt(“1”, 0, arr)&#x2F;&#x2F;arr：[‘1’,’2’,’3’]<br>parseInt(“2”, 1, arr)<br>parseInt(“3”, 2, arr)</p>
<p>我们知道，JavaScript函数通常会忽略额外的参数，并且parseInt只需要两个参数，因此我们不必担心arr这个参数的影响。</p>
<p>但是，第二个参数对parseInt影响很大。parseInt(“1”, 0)没有问题，0表示的是以二进制为基数解析‘1’。但是后面的parseInt(“2”, 1)以及parseInt(“3”, 2)就有问题了。1在parseInt中是无效的基数，返回‘NaN’值；2虽然是有意义的基数，但是因为‘3’不是合法的二进制数，所以也返回的是NaN。至此，问题错误已经明了。下面是解决方案。</p>
<p>解决方案<br> 解决的方法很简单，就是修饰一些parseInt函数。代码如下：</p>
<p>var arr &#x3D; [‘1’, ‘2’, ‘3’];<br>arr.map(function parseInt2(x) {<br>    return parseInt(x);<br>});<br>或者我们使用Number()方法，这样也会把字符串参数解析成十进制数，并且只需要一个参数。代码如下：</p>
<p>var arr &#x3D; [‘1’, ‘2’, ‘3’];<br>arr.map(Number);</p>
<h3 id="map和weakmap"><a href="#map和weakmap" class="headerlink" title="map和weakmap"></a>map和weakmap</h3><p>weak 描述的是js垃圾回收机制对待弱集合中值的方式  弱弱的拿着 这些值不属于正式的引用 不会阻止垃圾回收</p>
<p>WeakMap与Map类似，但有几点区别：</p>
<p>1、WeakMap只接受对象作为key，如果设置其他类型的数据作为key，会报错。</p>
<p>2、WeakMap的key所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。</p>
<p>3、由于WeakMap的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有size属性。</p>
<p>4、没有clear()方法</p>
<p>5、不能遍历</p>
<h3 id="使用扩展运算符-可以将-Map-映射对象转换为以下两种形式之一："><a href="#使用扩展运算符-可以将-Map-映射对象转换为以下两种形式之一：" class="headerlink" title="使用扩展运算符 ... 可以将 Map 映射对象转换为以下两种形式之一："></a>使用扩展运算符 <code>...</code> 可以将 Map 映射对象转换为以下两种形式之一：</h3><ol>
<li>数组：当使用扩展运算符 <code>...</code> 将 Map 映射对象应用于数组时，将返回一个包含键值对数组的新数组。每个键值对都表示为一个包含两个元素的数组，第一个元素是键，第二个元素是对应的值。</li>
</ol>
<p>下面是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy Codeconst map = new Map();</span><br><span class="line">map.set(&#x27;key1&#x27;, &#x27;value1&#x27;);</span><br><span class="line">map.set(&#x27;key2&#x27;, &#x27;value2&#x27;);</span><br><span class="line"></span><br><span class="line">const arr = [...map];</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Copy</span> <span class="title class_">Code</span>[ [ <span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span> ], [ <span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span> ] ]</span><br></pre></td></tr></table></figure>

<ol>
<li>对象：可以使用扩展运算符 <code>...</code> 结合对象字面量语法创建一个新的对象，其中键是原 Map 中的键，值是原 Map 中的值。</li>
</ol>
<p>下面是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy Codeconst map = new Map();</span><br><span class="line">map.set(&#x27;key1&#x27;, &#x27;value1&#x27;);</span><br><span class="line">map.set(&#x27;key2&#x27;, &#x27;value2&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123; ...map &#125;;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy Code&#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，使用扩展运算符 <code>...</code> 将 Map 映射对象转换为数组时，每个键值对被表示为一个包含两个元素的数组。而将其转换为对象时，键值对会变成对象中的属性和值。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[事件循环]]></title>
      <url>/2023/01/02/js%E9%AB%98%E7%BA%A7/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/164081cfd8400f92tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务:"></a>宏任务与微任务:</h3><p>异步任务分为 宏任务（macrotask） 与 微任务 (microtask)，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。</p>
<p><strong>宏任务(macrotask)：</strong>：</p>
<p>script(整体代码)、setTimeout、setInterval、UI 渲染、 I&#x2F;O、postMessage、 MessageChannel、setImmediate(Node.js 环境)</p>
<p><strong>微任务(microtask)：</strong></p>
<p>Promise、 MutaionObserver、process.nextTick(Node.js环境）</p>
<h2 id="Event-Loop-事件循环-："><a href="#Event-Loop-事件循环-：" class="headerlink" title="Event Loop(事件循环)："></a>Event Loop(事件循环)：</h2><p>Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：</p>
<ul>
<li><p>执行栈选择最先进入队列的宏任务(通常是<code>script</code>整体代码)，如果有则执行</p>
</li>
<li><p>检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列</p>
</li>
<li><p>更新render(每一次事件循环，浏览器都可能会去更新渲染)</p>
</li>
<li><p>重复以上步骤</p>
<p><img src="/../../images/170847d202084604tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="GitHub"></p>
</li>
</ul>
<p><strong>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环</strong></p>
<p>下面这个题，很多人都应该看过&#x2F;遇到过，重新来看会不会觉得清晰很多：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行顺序问题，考察频率挺高的，先自己想答案**</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>根据本文的解析，我们可以得到:</p>
<ol>
<li><p>先执行<code>script</code>同步代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 先执行<span class="keyword">new</span> <span class="title class_">Promise</span>中的<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>),then后面的不执行属于微任务</span><br><span class="line"> 然后执行<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完<code>script</code>宏任务后，执行微任务，console.log(3)，没有其他微任务了。</p>
</li>
<li><p>执行另一个宏任务，定时器，console.log(1)。</p>
</li>
</ol>
<p>根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2,4,3,1.</p>
<p>注意：new promise中的内容属于同步 但promise.then后面的内容会被放到微任务队列中 </p>
<h3 id="promise、async-x2F-await"><a href="#promise、async-x2F-await" class="headerlink" title="promise、async&#x2F;await"></a><strong>promise、async&#x2F;await</strong></h3><p>首先，<code>new Promise</code>是同步的任务，会被放到主进程中去立即执行。而<code>.then()</code>函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的<code>promise</code>状态结束的时候，就会立即放进异步队列中去了。</p>
<p><strong>带<code>async</code>关键字的函数会返回一个<code>promise</code>对象</strong>，如果里面没有<code>await</code>，执行起来等同于普通函数；如果没有<code>await</code>，<code>async</code>函数并没有很厉害是不是。</p>
<p><code>await</code> 关键字要在 <code>async</code> 关键字函数的内部，<code>await</code> 写在外面会报错；<code>await</code>如同他的语意，就是在等待，等待右侧的表达式完成。此时的<code>await</code>会让出线程，阻塞<code>async</code>内后续的代码，先去执行<code>async</code>外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算<code>await</code>的不是<code>promise</code>对象，是一个同步函数，也会等这样操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">	console.log(&#x27;async1 start&#x27;);</span><br><span class="line">	await async2();</span><br><span class="line">	console.log(&#x27;asnyc1 end&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">	console.log(&#x27;async2&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">	console.log(&#x27;setTimeOut&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">async1();</span><br><span class="line">new Promise(function (reslove) &#123;</span><br><span class="line">	console.log(&#x27;promise1&#x27;);</span><br><span class="line">	reslove();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">	console.log(&#x27;promise2&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;);</span><br></pre></td></tr></table></figure>

<p>正确的答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script <span class="keyword">start</span></span><br><span class="line">async1 <span class="keyword">start</span></span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script <span class="keyword">end</span></span><br><span class="line">asnyc1 <span class="keyword">end</span></span><br><span class="line">promise2</span><br><span class="line">setTimeOut</span><br></pre></td></tr></table></figure>

<p>整个代码片段（script）作为一个宏任务执行<code>console.log(&#39;script start&#39;)</code>，输出<code>script start</code>；</p>
<p>执行<code>setTimeout</code>，是一个异步动作，放入宏任务异步队列中；</p>
<p>执行<code>async1()</code>，输出<code>async1 start</code>，继续向下执行；</p>
<p><strong>执行<code>async2()</code>，输出<code>async2</code>，并返回了一个<code>promise</code>对象，<code>await</code>让出了线程，把返回的<code>promise</code>加入了微任务异步队列，所以<code>async1()</code>下面的代码也要等待上面完成后继续执行;</strong></p>
<p>执行 <code>new Promise</code>，输出<code>promise1</code>，然后将<code>resolve()</code>放入微任务异步队列；</p>
<p>执行<code>console.log(&#39;script end&#39;)</code>，输出<code>script end</code>；</p>
<p>到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务</p>
<p><strong>接下来执行<code>resolve</code>（<code>async2</code>返回的<code>promise</code>返回的），输出了<code>async1 end</code>；</strong></p>
<p>然后执行<code>resolve（new Promise的）</code>，输出了<code>promise2</code>；</p>
<p>最后执行<code>setTimeout</code>，输出了<code>settimeout</code>。</p>
<h5 id="第二个例子console-log-‘script-start’"><a href="#第二个例子console-log-‘script-start’" class="headerlink" title="第二个例子console.log(‘script start’)"></a>第二个例子console.log(‘script start’)</h5><p>&#96;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="keyword">await</span> <span class="title function_">async2</span>()<span class="string">`// 此处会跳出函数 并将后面的代码添加到微任务队列之中  </span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;<span class="string">`no</span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end&#x27;</span>)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="title function_">async1</span>()<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;, <span class="number">0</span>)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)<span class="string">`//同步代码</span></span><br><span class="line"><span class="string">`</span><span class="title function_">resolve</span>()<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="string">` //异步</span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)<span class="string">`</span></span><br><span class="line"><span class="string">`</span>&#125;)<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>&#96;<br> &#x2F;&#x2F; 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动<br>&#x2F;&#x2F; script start &#x3D;&gt; async2 end &#x3D;&gt; Promise &#x3D;&gt; script end &#x3D;&gt; promise1 &#x3D;&gt; promise2 &#x3D;&gt; <strong>async1 end</strong> &#x3D;&gt; setTimeout </p>
<p>一般不这样理解了</p>
<p>新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,输出为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>就是说将await后面的函数添加到微任务队列中</p>
<p><strong>分析这段代码：</strong></p>
<ul>
<li><strong>执行代码，输出<code>script start</code>。</strong></li>
<li><strong>执行async1(),会调用async2(),然后输出<code>async2 end</code>,此时将会保留async1函数的上下文，然后跳出async1函数。</strong></li>
<li><strong>遇到setTimeout，产生一个宏任务</strong></li>
<li><strong>执行Promise，输出<code>Promise</code>。遇到then，产生第一个微任务</strong></li>
<li><strong>继续执行代码，输出<code>script end</code></strong></li>
<li><strong>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出<code>promise1</code>，该微任务遇到then，产生一个新的微任务</strong></li>
<li><strong>执行产生的微任务，输出<code>promise2</code>,当前微任务队列执行完毕。执行权回到async1</strong></li>
<li><strong>执行await,实际上会产生一个promise返回，即</strong></li>
</ul>
<h3 id="为什么js为单线程"><a href="#为什么js为单线程" class="headerlink" title="为什么js为单线程"></a>为什么js为单线程</h3><p>js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。</p>
<p><strong>在js高程中举过一个栗子，如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器应该听哪个线程的，如何判断优先级？</strong></p>
<p>为了避免这种问题，js必须是一门单线程语言，并且在未来这个特点也不会改变。</p>
<p>作者：OBKoro1<br>链接：<a href="https://juejin.cn/post/6844903621872582669">https://juejin.cn/post/6844903621872582669</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p><img src="/../../images/8ca5f703852e431ba4c8353eef399fa9tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.png" alt="img"></p>
<p>那么执行栈就是把图中的内容块变成代码任务</p>
<p><strong>js中所有的任务都会在主线程上执行然后形成一个执行栈</strong></p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h3><p>任务队列那么队列和栈则是相反的，队列是先进先出的。其实很好理解，和我们平时排队是一个道理，先进入队伍的人肯定先出来。<strong>那么任务队列通俗理解就是用来放置异步任务的回调函数的。</strong>(也请记住这一点！！！)</p>
<h2 id="js的执行机制"><a href="#js的执行机制" class="headerlink" title="js的执行机制"></a>js的执行机制</h2><p>先上比较晦涩难懂的概念：</p>
<ul>
<li><strong>1.</strong> 同步任务由JavaScript 主线程按顺序执行。</li>
<li><strong>2.</strong> 异步任务委托给宿主环境<strong>执行</strong>。</li>
<li><strong>3.</strong> 异步任务完成后，对应的回调函数会被加入到<strong>任务队列</strong>中等待执行，任务队列又被分为宏任务队列和微任务队列，优先执行微任务队列，常见的微任务有new Promise().then,常见的宏任务有定时器</li>
<li><strong>4.</strong> JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行。</li>
<li><strong>5.</strong> JavaScript 主线程不断重复上面的第4 步，在执行回调函数时又会按照上面的四步去执行。</li>
<li></li>
</ul>
<p><img src="/../../images/image-20230112105650020.png" alt="image-20230112105650020"></p>
<p><img src="/../../images/image-20230112104147686.png" alt="image-20230112104147686"> </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[es6扩展运算符的三个点]]></title>
      <url>/2022/12/28/es6/es6%E4%B9%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%20%E4%B8%89%E4%B8%AA%E7%82%B9%EF%BC%88...%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>浅拷贝 </p>
<p>基础数据引用：复制的改变不会引起原来的改变</p>
<p>let obj1 &#x3D; { a: 1, b: 2};<br>let obj2 &#x3D; { …obj1, b: ‘2-edited’};<br>console.log(obj1); &#x2F;&#x2F; {a: 1, b: 2}<br>console.log(obj2); &#x2F;&#x2F;  {a: 1, b: “2-edited”}</p>
<p>引用数据类型:会影响原来对象的东西  </p>
<p>let obj1 &#x3D; { a: 1, b: 2, c: {nickName: ‘d’}};<br>let obj2 &#x3D; { …obj1};<br>obj2.c.nickName &#x3D; ‘d-edited’;<br>console.log(obj1); &#x2F;&#x2F; {a: 1, b: 2, c: {nickName: ‘d-edited’}}<br>console.log(obj2); &#x2F;&#x2F; {a: 1, b: 2, c: {nickName: ‘d-edited’}}</p>
<p><strong>合并多个对象或数组，后面的同名属性会覆盖前面的属性</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[虚拟dom]]></title>
      <url>/2022/12/28/js%E9%AB%98%E7%BA%A7/%E8%99%9A%E6%8B%9Fdom/</url>
      <content type="html"><![CDATA[<h3 id="一：什么是DOM？"><a href="#一：什么是DOM？" class="headerlink" title="一：什么是DOM？"></a>一：什么是DOM？</h3><p>​        DOM就是文档对象模型，HTML的文档document页面时一切的基础，没有它dom就无从谈起。</p>
<p>当我们创建好一个页面并加载到浏览器的时候，DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能就是处理网页内容。在这个文档给对象里，所有元素呈现出一种层次，就是除了顶级元素html外，其他元素都被包含在另外的元素中。</p>
<p>文档对象模型就是一个节点树。</p>
<h3 id="二：什么是虚拟DOM"><a href="#二：什么是虚拟DOM" class="headerlink" title="二：什么是虚拟DOM?"></a>二：什么是虚拟DOM?</h3><p>虚拟DOM是一个轻量级的JavaScript对象，它原本是真实dom的副本，是一个节点树，它将元素，它们的属性和内容作为对象及属性。渲染页面时会创建一个节点树，然后响应数据模型中的变化来更新该树，该变化是用户或系统完成的各种动作引起的。</p>
<h3 id="三：虚拟DOM-的工作过程？"><a href="#三：虚拟DOM-的工作过程？" class="headerlink" title="三：虚拟DOM 的工作过程？"></a>三：虚拟DOM 的工作过程？</h3><p>​        1：首先根据数据创建虚拟dom,它反映真实DOM的结构，然后由虚拟dom创建真实的dom树，真实dom树生成之后，在渲染到页面上。</p>
<pre><code>    2：如果数据发生改变，创建新的虚拟dom树，比较两个树的区别，调整虚拟dom的内部状态

    3：在虚拟dom收集到足够的改变时，再一次性应用到真实dom上，渲染到页面。
</code></pre>
<h3 id="四：虚拟DOM的优点？缺点？"><a href="#四：虚拟DOM的优点？缺点？" class="headerlink" title="四：虚拟DOM的优点？缺点？"></a>四：虚拟DOM的优点？缺点？</h3><p>​        优点：</p>
<pre><code>            ①：保证性能下限

            ②：无须手动操作dom

            ③：跨平台

    缺点：

            ①：无进行极致优化

            ②：首次渲染大量DOM时，由于多了一层dom计算会比innerHTMl插入慢
</code></pre>
<h3 id="五：真实dom和虚拟dom的区别？"><a href="#五：真实dom和虚拟dom的区别？" class="headerlink" title="五：真实dom和虚拟dom的区别？"></a>五：真实dom和虚拟dom的区别？</h3><p>​         1：虚拟dom不会进行排版与重绘操作，虚拟dom就是把真实DOM转换为javaScript代码</p>
<pre><code>    2：虚拟dom进行频繁修改，然后一次性比较并修改真实DOM中需要修改的部分，最后真实DOM进行排版重绘，减少节点排版与重绘损耗
</code></pre>
<p><strong>vue中通过render函数来创建虚拟dom书，减少对真实dom的插入删除等，</strong></p>
<p>为什么需要 1框架需要    vue等  不能将数据的依赖的真实dom一一对应找到，数据一改动，他只能全量渲染（组件所有dom元素）， 所以就不去渲染生成真实dom，而去渲染生成虚拟dom      render（）函数内</p>
<p>​                      2跨平台</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/12/24/leetcode/lianbiao/%E5%B0%86%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%9C%89%E6%9C%89%E5%BA%8F%E7%9A%84/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b; <span class="comment">//tail代表的是即将插入合并链表的前一位</span></span><br><span class="line">    <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">            tail.next = aPtr;</span><br><span class="line">            aPtr = aPtr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = bPtr;</span><br><span class="line">            bPtr = bPtr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 合并k个链表  、</span><br><span class="line">    </span><br><span class="line">  <span class="number">1</span> 通过定义一个ans来储存  依次储存k个链表</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 分治法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../../../images/image-20221227135325631.png" alt="image-20221227135325631"></p>
<p>分治法的图</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue脚手架的使用和一些基本语法]]></title>
      <url>/2022/12/21/vue/vue%20%E8%84%9A%E6%89%8B%E6%9E%B6/README/</url>
      <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第二步使用混入：</p>
<p> ​	全局混入：<code>Vue.mixin(xxx)</code><br> ​	局部混入：<code>mixins:[&#39;xxx&#39;]	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​			1).一个组件在用：放在组件自身即可。</p>
<p> ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​	(3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​	(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p>
<p> ​	(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>		</p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​	在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​	编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>

<p>slot-scope后续用 v-slot:{games（即插槽组件传过来的数据名）}</p>
<p>解构赋值： let {games}&#x3D;{games:[games]}   上方就直接用{games}就可以直接获取数据</p>
</li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
<p>开启命名空间后 map后面要加一些地址</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在子级路由需要加&#x2F;</p>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;hello&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;xiangqing&#x27;,</span><br><span class="line">		params:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;//News为 </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>独享守卫:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reduce的使用]]></title>
      <url>/2022/12/12/es6/reduce/</url>
      <content type="html"><![CDATA[<p>可以用来求数组引用数据的累加值</p>
<p>1.2 引用数据类型求和</p>
<p>let arr &#x3D; [{value: 45,},{value: 88,},{value: 101,},<br>];<br>let newArr &#x3D; arr.reduce((acc, cur) &#x3D;&gt; {return acc+ cur.value;<br>}, 0);<br>console.log(newArr); &#x2F;&#x2F;234</p>
<p>第一个参数： callback函数</p>
<p>执行数组中每个值 (如果没有提供第二个参数 initialValue ，则第一个值除外)的函数，包含四个参数：</p>
<p>accumulator： 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。<br>currentValue：数组中正在处理的元素。<br>currentIndex可选 ：数组中正在处理的当前元素的索引。 <strong>如果提供了initialValue，则起始索引号为0，否则从索引1起始。</strong><br>array可选：调用reduce()的原数组<br>第二个参数： initialValue可选</p>
<p>作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 注意： 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>这样看起来会有点蒙，其实就是两种情况：一种情况是给了第二个参数initialValue初始值；一种是没提供初始值。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>1将数组转变成各类对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> list =[</span><br><span class="line"></span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="attr">area</span>:<span class="string">&#x27;zg&#x27;</span>,<span class="attr">age</span>:<span class="string">&quot;11&quot;</span>,<span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&quot;lisi&quot;</span>,<span class="attr">area</span>:<span class="string">&#x27;mg&#x27;</span>,<span class="attr">age</span>:<span class="string">&quot;14&quot;</span>,<span class="attr">sex</span>:<span class="string">&#x27;wman&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> map=list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">*t*,*v*,*index*</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;name,...rest&#125;=*v*</span><br><span class="line"></span><br><span class="line">  *t*[name]=rest</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> *t*  </span><br><span class="line"></span><br><span class="line"> &#125;,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br></pre></td></tr></table></figure>

<p><strong>4.按属性对Object分类</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaohong&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line"></span><br><span class="line">  &#125;, &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaogang&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span> (objectArray, property) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = obj[property];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acc[key])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      acc[key] = [];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line"></span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> groupedPerson = <span class="title function_">groupBy</span>(person, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(groupedPerson);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../../images/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZmlnaHRpbmcgfg==,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="img"></p>
<h3 id="const-n1-x3D-…fieldMap-reduce-s-v-x3D-gt-console-log-v-1-和-const-n1-x3D-…fieldMap-reduce-s-v-x3D-gt-console-log-v-1-区别在哪"><a href="#const-n1-x3D-…fieldMap-reduce-s-v-x3D-gt-console-log-v-1-和-const-n1-x3D-…fieldMap-reduce-s-v-x3D-gt-console-log-v-1-区别在哪" class="headerlink" title="const n1&#x3D;[…fieldMap].reduce((s,[v])&#x3D;&gt;{console.log(v);},1) 和 const n1&#x3D;[…fieldMap].reduce((s,[,v])&#x3D;&gt;{console.log(v);},1) 区别在哪"></a>const n1&#x3D;[…fieldMap].reduce((s,[v])&#x3D;&gt;{console.log(v);},1) 和 const n1&#x3D;[…fieldMap].reduce((s,[,v])&#x3D;&gt;{console.log(v);},1) 区别在哪</h3><p>这种解构模式被称为数组解构模式或数组模式。在 JavaScript 中，使用数组解构模式可以从数组中提取元素，并将它们赋值给变量。数组解构模式使用方括号 <code>[]</code> 表示，并且可以指定所需的元素位置。</p>
<p>在你提供的代码中，解构模式 <code>[v]</code> 和 <code>[, v]</code> 都是数组解构模式的一种形式。</p>
<ul>
<li><code>[v]</code> 解构模式表示只需要数组中的第一个元素，并将其赋值给变量 <code>v</code>。逗号前面的部分为空，表示忽略数组中的其他元素。</li>
<li><code>[, v]</code> 解构模式表示只需要数组中的第二个元素，并将其赋值给变量 <code>v</code>。逗号前面的部分表示忽略数组中的第一个元素。</li>
</ul>
<p>通过使用数组解构模式，你可以从数组中选择性地提取所需的元素，并将其赋值给变量，以便在代码中进一步使用。这在处理复杂的数据结构时很有用，可以提高代码的可读性和简洁性。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/12/07/leetcode/lianbiao/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221207220355642.png" alt="image-20221207220355642"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//新链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先保存访问的节点的下一个节点，保存起来</span></span><br><span class="line">        <span class="comment">//留着下一步访问的</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//每次访问的原链表节点都会成为新链表的头结点，</span></span><br><span class="line">        <span class="comment">//其实就是把新链表挂到访问的原链表节点的</span></span><br><span class="line">        <span class="comment">//后面就行了</span></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        <span class="comment">//更新新链表</span></span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="comment">//重新赋值，继续访问</span></span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新链表</span></span><br><span class="line">    <span class="keyword">return</span> newHead;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/12/02/vue/%E7%BB%84%E4%BB%B6/%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="title：单文件组件"><a href="#title：单文件组件" class="headerlink" title="title：单文件组件"></a>title：单文件组件</h2><p>先创建小组件</p>
<p><img src="/../../../images/image-20221202201420200.png" alt="image-20221202201420200"></p>
<p>并将其暴露出去，接着创捷一个APP.vue,负责将所有的小组件打包，暴露给main.js.</p>
<p><img src="/../../../images/image-20221202205509841.png" alt="image-20221202205509841"></p>
<p>main.js中要new一个Vue实例 把该写的东西写上</p>
<p><strong><img src="/../../../images/image-20221202205759811.png" alt="image-20221202205759811"></strong></p>
<p>接着通过在html文件中去引用main.js</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue和vuecomponent的关系]]></title>
      <url>/2022/11/29/vue/%E7%BB%84%E4%BB%B6/%E5%88%86%E6%9E%90Vue%E5%92%8Cvuecomponent%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221129203202548.png" alt="image-20221129203202548"></p>
]]></content>
      
        <categories>
            
            <category> web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[组件]]></title>
      <url>/2022/11/27/vue/%E7%BB%84%E4%BB%B6/1/</url>
      <content type="html"><![CDATA[<h3 id="组件的定义：实现应用中局部功能代码和资源的集合"><a href="#组件的定义：实现应用中局部功能代码和资源的集合" class="headerlink" title="组件的定义：实现应用中局部功能代码和资源的集合"></a>组件的定义：实现应用中局部功能代码和资源的集合</h3><p><img src="/../../../images/image-20221127125635532.png" alt="image-20221127125635532"></p>
<p><img src="/../../../images/image-20221127125718681.png" alt="image-20221127125718681"></p>
<h3 id="非单文件组件："><a href="#非单文件组件：" class="headerlink" title="非单文件组件："></a>非单文件组件：</h3><p>一个文件中包含n个组件</p>
<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><em>单文件组件</em></h3><p>一个只包含一个组件</p>
]]></content>
      
        <categories>
            
            <category> web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/11/21/vue/%E9%9A%8F%E7%AC%94/vue%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<p><strong>Vue监视数据的原理：</strong></p>
<p>​    <strong>\1. vue会监视data中所有层次的数据。</strong></p>
<p>​    <strong>\2. 如何监测对象中的数据？</strong></p>
<p>​        <strong>通过setter实现监视，且要在new Vue时就传入要监测的数据。</strong></p>
<p>​         <strong>(1).对象中后追加的属性，Vue默认不做响应式处理</strong></p>
<p>​         <strong>(2).如需给后添加的属性做响应式，请使用如下API：</strong></p>
<p>​             <strong>Vue.set(target，propertyName&#x2F;index，value) 或</strong> </p>
<p>​             <strong>vm.$set(target，propertyName&#x2F;index，value)</strong></p>
<p>​    <strong>\3. 如何监测数组中的数据？</strong></p>
<p>​         <strong>通过包裹数组更新元素的方法实现，本质就是做了两件事：</strong></p>
<p>​          <strong>(1).调用原生对应的方法对数组进行更新。</strong></p>
<p>​          <strong>(2).重新解析模板，进而更新页面。</strong></p>
<p>​    <strong>4.在Vue修改数组中的某个元素一定要用如下方法：</strong></p>
<p>​       <strong>1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</strong></p>
<p>​       <strong>2.Vue.set() 或 vm.$set()</strong></p>
<hr>
<p>​    <strong>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</strong></p>
<p>  –&gt;</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[将有序数组转换为二叉搜索树]]></title>
      <url>/2022/11/21/leetcode/tree/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221121161645655.png" alt="image-20221121161645655"></p>
<ul>
<li><code>Definition for a binary tree node.</code></li>
<li><pre><code class="java">  * public class TreeNode &#123;`
  * `int val;`
  * `TreeNode left;`
  * `TreeNode right;`
  * `TreeNode() &#123;&#125;`
  * `TreeNode(int val) &#123; this.val = val; &#125;`
  * `TreeNode(int val, TreeNode left, TreeNode right) &#123;`
  * `this.val = val;`
  * `this.left = left;`
  * `this.right = right;`
  * `&#125;`
  * `&#125;`
    `*/`
    `class Solution &#123;`
    `public TreeNode  sortedArrayToBST(int[] nums) &#123;`
       `return he(nums,0,nums.length-1);`
    `&#125;`
     
 ​    `private TreeNode he(int[] nums, int start ,int end)&#123;`
 ​        `if(start&gt;end)&#123;`
 ​            `return null;`
 ​        `&#125;`
 ​        `int n=(start+end)/2;`
 ​        `TreeNode node=new TreeNode(nums[n]);`
 ​        `node.left=he(nums,start,n-1);`
 ​        `node.right=he(nums,n+1,end);`
 ​        `return node;`
 ​    `&#125;
</code></pre>
</li>
</ul>
<p>先要明白什么是二叉搜索树，左边的一坨永远比右边的小，使用递归的方式，每次取数组中间的值比如m作为当前节点，m前面的值作为他左子树的结点值，m后面的值作为他右子树的节点值。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/11/18/vue/%E9%9A%8F%E7%AC%94/%E7%9B%91%E5%90%AC/</url>
      <content type="html"><![CDATA[<p>watch中的isHot:{</p>
<p>​      immediate:true,         &#x2F;初始化时让handler调用一下      </p>
<p>​     deep:true,                      &#x2F;&#x2F;深度监视</p>
<p>​     handler(newValue,oldValue){</p>
<p>​      console.log(‘isHot被修改了’,newValue,oldValue)</p>
<p>​     }</p>
<p>vue中可以检测到data数据的改变，但提供的watch方法不会检测到多层级的数据变化，如对象里的数据。所以根据数据类型要开启deep：true</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/11/18/vue/%E9%9A%8F%E7%AC%94/watch%E5%92%8Ccomputed%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p> computed和watch之间的区别：</p>
<p>​      1.computed能完成的功能，watch都可以完成。</p>
<p>​      2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p>​    两个重要的小原则：</p>
<p>​       1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​       2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</p>
<p>​        这样this的指向才是vm 或 组件实例对象。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/11/18/vue/%E9%9A%8F%E7%AC%94/key%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<!-- 
        面试题：react、vue中的key有什么作用？（key的内部原理）
            
            1. 虚拟DOM中key的作用：
                    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 
                    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：
                    

​            2.对比规则：
​                  (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：
​                        ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！
​                        ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。

​                  (2).旧虚拟DOM中未找到与新虚拟DOM相同的key
​                        创建新的真实DOM，随后渲染到到页面。
​                        
            3. 用index作为key可能会引发的问题：
                      1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
                              会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

                      2. 如果结构中还包含输入类的DOM：
                              会产生错误DOM更新 ==> 界面有问题。

                        4. 开发中如何选择key?:
                          1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
                          2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
                            使用index作为key是没有问题的。
        -->
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2022/11/18/vue/%E9%9A%8F%E7%AC%94/%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%E6%97%B6key%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221118124622219.png" alt="image-20221118124622219"></p>
<p>用index作为key可能会引发的问题：<br>行：逆序添加、逆序删除等破坏顺序操作:<br>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<ol start="2">
<li>如果结构中还包含输入类的DOM：<br>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题</li>
</ol>
<p><img src="/../../../images/image-20221118124806387.png" alt="image-20221118124806387">![image-20221118124806731](..&#x2F;..&#x2F;..&#x2F;images&#x2F;image-20221118124806731.png  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[层序遍历]]></title>
      <url>/2022/11/15/leetcode/tree/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//根节点入队</span></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//如果队列不为空就继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//BFS打印，levelNum表示的是每层的结点数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">levelNum</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">//subList存储的是每层的结点值</span></span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelNum; i++) &#123;</span><br><span class="line">            <span class="comment">//出队</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            subList.add(node.val);</span><br><span class="line">            <span class="comment">//左右子节点如果不为空就加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把每层的结点值存储在res中，</span></span><br><span class="line">        res.add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：数据结构和算法</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/leetbook/read/top-interview-questions-easy/xnldjj/?discussion=UHhgqh</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。           <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> len=queue.size();</span><br><span class="line">        List&lt;TreeNode&gt; sub=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            TreeNode root1=queue.poll();</span><br><span class="line">            sub.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         res.add(sub);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList和LinkedList]]></title>
      <url>/2022/11/15/leetcode/Arraylist%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="一、ArrayList和LinkedList查询之间的区别"><a href="#一、ArrayList和LinkedList查询之间的区别" class="headerlink" title="一、ArrayList和LinkedList查询之间的区别"></a>一、ArrayList和LinkedList查询之间的区别</h3><p>首先，从名字就可以看出，ArrayList和LinkedList的区别，ArrayList是基于数组的，LinkedList是基于链表的。</p>
<p>从这一点，我们可以推理出来，ArrayList适合查询，LinkedList适合插入，但是这只是一个广泛的结论，我们应该了解的更细致一点。</p>
<p>比如，对于ArrayList，它真正的优点是按下标查询元素，相比于LinkedList，LinkedList也可以按下标查询元素，但是LinkedList需要对底层链表进行遍历，才能找到指定下标的元素，而ArrayList不用，所以这是ArrayList的优点。</p>
<p>但是，如果我们讨论的是获取第一个元素，或最后一个元素，ArrayList和LinkedList在性能上是没有区别的，因为LinkedList中有两个属性分别记录了当前链表中的头结点和尾结点，并不需要遍历链表。</p>
<p>以上，是对于ArrayList和LinkedList在查询方面的区别。</p>
<h3 id="二、ArrayList和LinkedList插入之间的区别"><a href="#二、ArrayList和LinkedList插入之间的区别" class="headerlink" title="二、ArrayList和LinkedList插入之间的区别"></a>二、ArrayList和LinkedList插入之间的区别</h3><p>我们再来研究一下在插入方面的区别：</p>
<p>ArrayList可以插入到指定下标位置，或者数组末尾，这种插入普通情况下是很快的，但是如果某次插入操作触发了扩容，那么本次插入就增加了额外的扩容成本。</p>
<p>对于LinkedList，如果是插在链表的头部或者是尾部都是很快的，因为LinkedList中有单独的属性记录的链表的头结点和尾结点，不过，如果是插在指定下标位置，那么就需要遍历链表找到指定位置，从而降低了效率。</p>
<p>但是，使用LinkedList是不用担心扩容问题的，链表是不需要扩容的。</p>
<p>综上：<br>1.默认情况下，比如调用ArrayList和LinkedList的add(e)方法，都是插入在最后，如果这种操作比较多，那么就用LinkedList，因为不涉及到扩容。</p>
<p>2.如果调用ArrayList和LinkedList的add(index, e)方法比较多，就要具体考虑了，因为ArrayList可能会扩容，LinkedList需要遍历链表，这两种到底哪种更快，是没有结论的，得具体情况具体分析。</p>
<p>3.还有，如果是插入场景比较少，但经常需要查询的话，查询分两种，第一种就是普通遍历，也就是经常需要对List中的元素进行遍历，那么这两种是区别不大的，遍历链表和遍历数组的区别，第二种就是经常需要按指定下标获取List中的元素，如果这种情况如果比较多，那么就用ArrayList</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Object.values的使用]]></title>
      <url>/2022/11/14/es6/es8/Object.values/</url>
      <content type="html"><![CDATA[<p>二、Object.values 和 Object.entries</p>
<ol>
<li>Object.values() 方法返回一个给定对象的所有可枚举属性值的数组</li>
<li>Object.entries() 方法返回一个给定对象自身可遍历属性 [key,value] 的数组</li>
<li>Object.getOwnPropertyDescriptors 该方法返回指定对象所有自身属性的描述对象 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">hobby</span>:[<span class="string">&#x27;basketball&#x27;</span>,<span class="string">&#x27;dance&#x27;</span>,<span class="string">&#x27;rap&#x27;</span>],</span><br><span class="line">    <span class="attr">subject</span>:[<span class="string">&#x27;Math&#x27;</span>,<span class="string">&#x27;English&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取对象所有的键</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person));</span><br><span class="line"><span class="comment">//获取对象所有的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(person));</span><br><span class="line"><span class="comment">//entries</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(person));</span><br><span class="line"><span class="comment">//创建Map</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(person))<span class="comment">//**</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;hobby&#x27;</span>));</span><br><span class="line"><span class="comment">//对象属性的描述对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(person));</span><br></pre></td></tr></table></figure>
 <img src="/../../../images/image-20221114141247723.png" alt="image-20221114141247723"></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[express的使用]]></title>
      <url>/2022/11/13/nodejs/Express/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20230923230341673.png" alt="image-20230923230341673"></p>
<p><img src="/../../images/image-20221114131156455.png" alt="image-20221114131156455"></p>
<h4 id="express的use-可以是一个文件夹的对外提供静态资源，在网站中直接http：-x2F-x2F-127-0-0-1-x2F-index-html"><a href="#express的use-可以是一个文件夹的对外提供静态资源，在网站中直接http：-x2F-x2F-127-0-0-1-x2F-index-html" class="headerlink" title="express的use 可以是一个文件夹的对外提供静态资源，在网站中直接http：&#x2F;&#x2F;127.0.0.1&#x2F;index.html"></a>express的use 可以是一个文件夹的对外提供静态资源，在网站中直接http：&#x2F;&#x2F;127.0.0.1&#x2F;index.html</h4><p>便可以访问到资源  默认文件根目录名不出现在网站中，可以手动添加在use中 作为第一个参数</p>
<p><img src="/../../images/image-20221114131309406.png" alt="image-20221114131309406"></p>
<p><img src="/../../images/image-20221114185619164.png" alt="image-20221114185619164"></p>
<h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><p><img src="/../../images/image-20221114193552898.png" alt="image-20221114193552898"></p>
<p>简化代码，不用在下游重复获取req的一些属性</p>
<p>多个全局中间件时，依次定义即可，顺序即你定义 的顺序。</p>
<h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><p><img src="/../../images/image-20221114193935121.png" alt="image-20221114193935121"></p>
<h5 id="定义多个局部"><a href="#定义多个局部" class="headerlink" title="定义多个局部"></a>定义多个局部</h5><p><img src="/../../images/image-20221114194723979.png" alt="image-20221114194723979"></p>
<p>小结：</p>
<ol>
<li><ol>
<li>创建路由时，用use是全部中间件。get为局部中间件</li>
<li>一定要在路由之前注册中间件；（错误中间件之前）</li>
<li>客户端发送过来的请求，可以连续调用多个中间件进行处理，</li>
<li>执行完中间件的业务代码之后，不要忘记调用next（）函数</li>
<li>为了防止代码混乱，不要再netx（）后面再写额外的代码</li>
</ol>
</li>
</ol>
<p>​      </p>
<h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><ol>
<li>应用级别中间件，把中间件绑定到实例如app.use(全局中间件 )或 app.get(局部中间件)  \</li>
<li>路由级中间件，把中间件绑定到 router（路由模块）上。</li>
<li>错误级别中间件，四个参数<img src="/../../images/image-20221114200353034.png" alt="image-20221114200353034"></li>
<li>EXpress内置的中间件</li>
</ol>
<p><img src="/../../images/image-20221114200550333.png" alt="image-20221114200550333"></p>
<h5 id="第二个可以用于获取-Ajax中的axios发送请求的body里的数据"><a href="#第二个可以用于获取-Ajax中的axios发送请求的body里的数据" class="headerlink" title="第二个可以用于获取 Ajax中的axios发送请求的body里的数据"></a>第二个可以用于获取 Ajax中的axios发送请求的body里的数据</h5>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[对象的扩展]]></title>
      <url>/2022/11/13/es6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h5 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h5><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>

<p>除了属性简写，方法也可以简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p><a href="https://blog.csdn.net/weixin_41642136/article/details/111666448?ops_request_misc=%7B%22request_id%22:%22166832329416782391837188%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166832329416782391837188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-111666448-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_control1&utm_term=...%E5%AF%B9%E8%B1%A1&spm=1018.2226.3001.4187">(260条消息) JS中的对象展开运算符“…”（（ES6、ES7新提出））及应用_代码DJ的博客-CSDN博客_js对象展开运算符</a></p>
<h5 id="1、函数调用中使用展开运算符"><a href="#1、函数调用中使用展开运算符" class="headerlink" title="1、函数调用中使用展开运算符"></a>1、函数调用中使用展开运算符</h5><p>在以前我们会使用apply方法来将一个数组展开成多个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">test.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure>

<p>如上，我们把args数组当作实参传递给了a,b,c，这边正是利用了Function.prototype.apply的特性。</p>
<p>不过有了ES6，我们就可以更加简洁地来传递数组参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test(a,b,c) &#123; &#125;</span><br><span class="line">var args = [0,1,2];</span><br><span class="line">test(...args);</span><br></pre></td></tr></table></figure>

<p>我们使用…展开运算符就可以把args直接传递给test()函数。</p>
<p><strong>2、数组字面量中使用展开运算符</strong><br>在ES6的世界中，我们可以直接加一个数组直接合并到另外一个数组当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr1,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]; <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2); <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>3、用于解构赋值</strong><br>解构赋值也是ES6中的一个特性，而这个展开运算符可以用于部分情景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [arg1,arg2,...arg3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arg1 <span class="comment">//1</span></span><br><span class="line">arg2 <span class="comment">//2</span></span><br><span class="line">arg3 <span class="comment">//[&#x27;3&#x27;,&#x27;4&#x27;</span></span><br></pre></td></tr></table></figure>

<p>]<br>展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。</p>
<p>不过要注意，解构赋值中展开运算符只能用在最后：</p>
<p>let [arg1,…arg2,arg3] &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F;报错<br> <strong>4、类数组对象变成数组</strong><br>展开运算符可以将一个类数组对象变成一个真正的数组对象：</p>
<p>var list&#x3D;document.getElementsByTagName(‘div’);<br>var arr&#x3D;[..list];<br>list是类数组对象，而我们通过使用展开运算符使之变成了数组。</p>
<p><strong>5、ES7草案中的对象展开运算符</strong><br>ES7中的对象展开运算符符可以让我们更快捷地操作对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x,y,...z&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line">x; <span class="comment">//1</span></span><br><span class="line">y; <span class="comment">//2</span></span><br><span class="line">z; <span class="comment">//&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure>

<p>如上，我们可以将一个对象当中的对象的一部分取出来成为一个新对象赋值给展开运算符的参数</p>
<p>同时，我们也可以像数组插入那样将一个对象插入另外一个对象当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z=&#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> n=&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,...z&#125;;</span><br><span class="line">n; <span class="comment">//&#123;x:1,y:2,a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外还要很多用处，比如可以合并两个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b=&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> ab=&#123;...a,...b&#125;;</span><br><span class="line">ab <span class="comment">//&#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[广度优先探索]]></title>
      <url>/2022/11/12/leetcode/tree/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221112144352629.png" alt="image-20221112144352629"></p>
<p><img src="/../../../images/image-20221112144407226.png" alt="image-20221112144407226"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[验证二叉搜索树]]></title>
      <url>/2022/11/12/leetcode/tree/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><img src="/../../../images/image-20221112143329506-16685866685445.png" alt="image-20221112143329506"></p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>运用递归 因为中序遍历的顺序就是二叉搜索树的值从小到大的顺序，利用这一点就可以判断 需要指定一个pre来存上一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeNode prev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode prev=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//访问左子树</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//访问当前节点：如果当前节点小于等于中序遍历的前一个节点直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.val &gt;= root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    prev = root;</span><br><span class="line">    <span class="comment">//访问右子树</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> if (prev !&#x3D; null &amp;&amp; prev.val &gt;&#x3D; root.val)<br>        return false;<br>    prev &#x3D; root;</p>
<p>每一次递归都在执行这两步 这两步不能调换位置</p>
<p>###解法二</p>
<p>运用栈 一次性存两个数据进入栈中，利用先进后出的特点，可以先得到最左边的子节点，与上一个中间的结点比较，再把pre赋于左节点，然后这一个中间的节点在于pre比较，依次类推（较难理解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left; </span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//保存前一个访问的结点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        root = root.right; ※</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[模板化]]></title>
      <url>/2022/11/10/nodejs/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20221110212246799.png" alt="image-20221110212246799"></p>
<p><img src="/../../images/image-20221110212322232.png" alt="image-20221110212322232"></p>
<h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p><strong>含义</strong>：和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。</p>
<p>好处 防止了全局变量污染问题</p>
<h4 id="如何向外共享作用域的成员"><a href="#如何向外共享作用域的成员" class="headerlink" title="如何向外共享作用域的成员"></a>如何向外共享作用域的成员</h4><p>通过module对象中的export对象<br>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。</p>
<p><strong>使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。</strong>  会覆盖  得到的是export指向的新对象</p>
<p><img src="/../../images/image-20221110213305363.png" alt="image-20221110213305363"></p>
<p><strong>export&#x3D;&#x3D;module.export 两者不要在同一个模块中混用（同时使用时，得到的是module.export的对象,属性值可以共存（3））</strong> </p>
<p><strong>给module.export指向新对象时 他会指向一个新地址</strong> ,从而使最后得到的值也为新地址的值</p>
<p><img src="/../../images/image-20221110214021822.png" alt="image-20221110214021822"></p>
<h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p><img src="/../../images/image-20221111130748283.png" alt="image-20221111130748283"></p>
<h3 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h3><p>NodejS中的第三方模块又叫做包，包的作用 <strong>包是基于内置模块封装出来的，提供了更高级的API，极大的提高了效率</strong></p>
<p><strong>包与内置模块之间的关系，类似于jQuery和浏览器内置api之间的关系</strong></p>
<h4 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h4><p><strong>require(xxx) 自定义模块 要以.&#x2F; ..&#x2F;开头 如果不写后缀名，会依次补全.js .node .json 来寻找</strong></p>
<p><img src="/../../images/image-20221113155233336.png" alt="image-20221113155233336"></p>
<p><strong>优先级 packjson.main&gt;index.ht</strong></p>
<p><img src="/../../images/image-20221113155257715.png" alt="image-20221113155257715"></p>
<p><img src="/../../images/image-20221114170523719.png" alt="image-20221114170523719"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node中的web服务器]]></title>
      <url>/2022/11/10/nodejs/%E5%88%9B%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h2><p><img src="D:\软件文件\Roaming\Typora\typora-user-images\image-20221110173525568.png" alt="image-20221110173525568"></p>
<p><img src="/../../images/image-20221110173548478.png" alt="image-20221110173548478"></p>
<h2 id="根据不同的url响应不同的html内容"><a href="#根据不同的url响应不同的html内容" class="headerlink" title="根据不同的url响应不同的html内容"></a>根据不同的url响应不同的html内容</h2><p><img src="/../../images/image-20221110173639175.png" alt="image-20221110173639175"></p>
<p><img src="/../../images/image-20221110173657485.png" alt="image-20221110173657485"></p>
<p><img src="/../../images/image-20221110173742743.png" alt="image-20221110173742743"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[http]]></title>
      <url>/2022/11/10/nodejs/http/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20221110173317561.png" alt="image-20221110173317561"></p>
<p><img src="/../../images/image-20221110173345133.png" alt="image-20221110173345133"></p>
<p><img src="/../../images/image-20221110173406411.png" alt="image-20221110173406411"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Symbol的使用]]></title>
      <url>/2022/11/10/js%E9%AB%98%E7%BA%A7/Symbol/</url>
      <content type="html"><![CDATA[<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p>1 由于每一个 Symbol 值都是不相等的，这意味着只要 Symbol 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖</p>
<p>2注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[node的基本使用]]></title>
      <url>/2022/11/09/nodejs/node.js/</url>
      <content type="html"><![CDATA[<h2 id="回顾-浏览器中Javascript的组成部分"><a href="#回顾-浏览器中Javascript的组成部分" class="headerlink" title="回顾 浏览器中Javascript的组成部分"></a>回顾 浏览器中Javascript的组成部分</h2><p><img src="/../../images/image-20221109120615938.png" alt="image-20221109120615938"></p>
<h3 id="浏览器的运行环境"><a href="#浏览器的运行环境" class="headerlink" title="浏览器的运行环境"></a>浏览器的运行环境</h3><p><img src="/../../images/image-20221109121205265.png" alt="image-20221109121205265"></p>
<h3 id="Node-js中的javascript运行环境"><a href="#Node-js中的javascript运行环境" class="headerlink" title="Node.js中的javascript运行环境"></a>Node.js中的javascript运行环境</h3><p><img src="/../../images/image-20221109121714868.png" alt="image-20221109121714868"></p>
<h2 id="文件读入写"><a href="#文件读入写" class="headerlink" title="文件读入写"></a>文件读入写</h2><h4 id="读取文本内容"><a href="#读取文本内容" class="headerlink" title="读取文本内容"></a>读取文本内容</h4><p><img src="/../../images/image-20221109124501609.png" alt="image-20221109124501609"></p>
<h4 id="向文本写入内容"><a href="#向文本写入内容" class="headerlink" title="向文本写入内容"></a>向文本写入内容</h4><p><img src="/../../images/image-20221109134041100.png" alt="image-20221109134041100"></p>
<h4 id="读取文件大小-fs-stat"><a href="#读取文件大小-fs-stat" class="headerlink" title="读取文件大小  fs.stat"></a>读取文件大小  fs.stat</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取文件的大小</span><br><span class="line">    fs.stat(`./uploads/$&#123;filename&#125;`, function (err, stats) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(stats);</span><br><span class="line">        //读取文件内容</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Layui的介绍]]></title>
      <url>/2022/11/05/%E5%BA%93/Layui/</url>
      <content type="html"><![CDATA[<h1 id="layui"><a href="#layui" class="headerlink" title="layui"></a>layui</h1><p><img src="/../../images/image-20221105151858761.png" alt="image-20221105151858761"></p>
<h3 id="数据表格"><a href="#数据表格" class="headerlink" title="数据表格"></a>数据表格</h3><p>头部事件 table.on(‘toolbar(test)’,function(obj){</p>
<p>})<br>工具事件 table.on(‘tool(test)’,function(obj){</p>
<p>})****</p>
<p>基础api</p>
<p><img src="/../../images/image-20221108202441592.png" alt="image-20221108202441592"></p>
<h3 id="弹出层-layer（包括询问-提示-输入等等-包含回调函数）"><a href="#弹出层-layer（包括询问-提示-输入等等-包含回调函数）" class="headerlink" title="弹出层 layer（包括询问 提示 输入等等 包含回调函数）"></a>弹出层 layer（包括询问 提示 输入等等 包含回调函数）</h3><p><img src="/../../images/image-20221108204030968.png" alt="image-20221108204030968"></p>
<h3 id="数据重载"><a href="#数据重载" class="headerlink" title="数据重载"></a>数据重载</h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[bootstrap]]></title>
      <url>/2022/11/01/%E5%BA%93/bootstrap/</url>
      <content type="html"><![CDATA[<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h1><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul>
<li>流体容器</li>
<li>固体容器 </li>
<li>栅格化容器：一行12分 类似于flex:<br>栅格系统</li>
</ul>
<p><img src="/../../images/image-20221102151025771-166858764863038.png" alt="image-20221102151025771"></p>
<h4 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h4><p>我们列嵌套最好加一个行row 可以取消父元素的padding值 而且高度自动和父级一样</p>
<h4 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h4><p> col-md-offset-6  该元素向右边偏离多少份</p>
<h4 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h4><p>col-md-push&#x2F;pull</p>
<h4 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h4><p><img src="/../../images/image-20221102152735237-166858765044640.png" alt="image-20221102152735237"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我的随笔]]></title>
      <url>/2022/10/27/%E6%9D%82/%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<ol>
<li>项目中 let用来定义变量，const用来定义常量</li>
<li>js中repacle(xx,xx1)，用于更换字符串。xx1也可以是一个回调函数，xx一般为正则表达式</li>
<li>数组的unshift方法，在数组前面增添元素一个或多个，并返回长度</li>
<li>数组的视频sort方法是 sort（a，b），return a-b就是升序，b-a就是降序   会改变原数组 </li>
<li>filter是过滤方法，不会改变原数组  </li>
<li>axios 中获得的res.data才是服务器传过来的数据 3个 包括 state:状态码   msg:信息  data:数据  </li>
<li>axios post(上传数据)方法 需要将请求体放到data里面  get(查询数据)查询方法需要将参数放到params</li>
<li>若某个方法的返回值是promise实例 则可以在前面添加await</li>
<li><img src="/Yuanmingjian/../images/image-20230111165207504.png" alt="image-20230111165207504"></li>
</ol>
<p>​    </p>
<p>解构赋值先后面六个属性中解构出需要的data(里面是服务器传的三个属性),里面有个data  为防止data.data  可以把data重命名为res 这样就可以得到数据</p>
<p><strong>10 回调地狱的缺点</strong><br>●代码耦合性太强，牵一发而动全身,难以维护<br>●大量冗余的代码相互嵌套，代码的可读性变 差</p>
<p>11  async 和 await 的使用可以直接获得promise的值而不是一个对象  可以不用.then 造成代码冗余</p>
<p><img src="/Yuanmingjian/../images/image-20230112104122709.png" alt="image-20230112104122709"></p>
<p>await 等待后面的一个promise  等待完成后 将之后的代码推入的微队列 若没有则将该函数完成推入微队列</p>
<p>12 从node里获取 请求头的数据 req.headers      参数的 req.query</p>
<p>13 this对象是在运行时基于函数执行环境绑定的，在全局函数中，this&#x3D;window，在函数被作为某个对象的方法调用时，this等于这个对象。</p>
<p>但是匿名函数的执行环境是全局性的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name :<span class="string">&#x27;Alan&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayName</span>()()  <span class="comment">// window </span></span><br></pre></td></tr></table></figure>

<p>这里sayName方法return了一个匿名函数，这个匿名函数中this指向window</p>
<p>解决方法还是有的，我们可以把外部作用域的this传递给匿名函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name :&#x27;Alan&#x27;,</span><br><span class="line">    sayName:function () &#123;</span><br><span class="line">        var that = this</span><br><span class="line">        return function () &#123;</span><br><span class="line">            console.log(that.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName()()  // Alan</span><br></pre></td></tr></table></figure>



<p>14 函数的参数传递 是按值传递 不是按引用地址传递   p86</p>
<p>15静态作用域也叫词法作用域 是代码一生成就已经确定好的作用域 不需要执行运行                       </p>
<p>作用域链  多个上下级关系的作用域形成的链  从内到外</p>
<p> 而作用域链是执行上下文（执行函数 ）创建变量对象的一个作用域链  <strong>这个东西决定了各级上下文中的代码在访问变量和函数时的顺序</strong>       <strong>用于标识符解析便用延作用域链逐级搜索标识符名称</strong>               一个上下文栈</p>
<p>16 vuex模块化开发需要 给小仓库开启命名空间！！！！！！！！！！</p>
<p>17 js中的 Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 简单说就是 Object.entries() 可以把一个对象的键值以数组的形式遍历出来，结果和 for…in 一致，但不会遍历原型属性。</p>
<p>18 sort()对于大多数情况是不适用的 因为他默认会按照数值的字符串重新排序 比如 即使5小于10 但字符串“10”在字符串“5”的前面 所以10还是会排到5的前面  因此我们一般要在sort里面写一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> b-a </span><br><span class="line">    a-b为升序 b-a为降序</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>19 数组五个迭代方法 some every fliter  map forEach</p>
<p> 归并方法 reduce （适用于对数组累加）</p>
<p>20 js的递归中给结果数组加入 要用current .slice() 而不能用current  </p>
<p><img src="/Yuanmingjian/../images/image-20230324185522807.png" alt="image-20230324185522807"></p>
<p>在使用回溯算法进行组合或排列时，我们通常需要创建和操作当前组合或排列的数组。由于 JavaScript 中数组是引用类型，这意味着在进行组合或排列过程中，如果直接对当前组合或排列的数组进行操作，可能会引起其他已经存储的组合或排列的数组的变化，导致结果不正确。</p>
<p>因此，为了避免这种问题，我们需要创建当前组合或排列的数组的副本，以便对副本进行操作，而不会影响到原始数组。而 <code>arr.slice()</code> 可以返回原数组的一个副本，因此常常被用来创建一个新的数组，以便进行回溯过程中的操作，而不影响之前存储的，已经完成的组合或排列的结果。</p>
<p>例如，在找到一个由输入数组 <code>arr</code> 中所有顺序相关元素的组合时，我们通常会定义一个回溯函数，将当前组合作为参数传入函数，并在函数中进行组合或排列。在这种情况下，我们需要在回溯函数中使用的新组合数组，由于需要作为参数传入函数，因此不能直接拷贝当前组合数组（<strong>因为这将使当前组合的任何变化都反映在已经存储的组合数组上</strong>），而是应该使用 <code>arr.slice()</code> 创建一个新数组，并对新数组进行操作。这样，对新数组的所有更改都不会反映在已经存储的组合数组中，保证了最终的结果的正确性。</p>
<p>举例：</p>
<p>`&#96;&#96;javascript<br>function findAllCombinations(arr, start, end, current, result) {<br>  if (current.length &gt; 0) {<br>    <strong>result.push(current.slice());</strong> &#x2F;&#x2F; 将当前组合加入结果<br>  }</p>
<p>  for (let i &#x3D; start; i &lt;&#x3D; end; i++) {<br>    current.push(arr[i]);<br>    findAllCombinations(arr, i + 1, end, current.slice(), result); &#x2F;&#x2F; 递归到下一个元素，并使用当前组合的副本<br>    current.pop();<br>  }<br>}</p>
<p>const arr &#x3D; [1, 2, 3];<br>const result &#x3D; [];</p>
<p>findAllCombinations(arr, 0, arr.length - 1, [], result);</p>
<p>console.log(result); &#x2F;&#x2F; 输出 [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]<br>`&#96;&#96;</p>
<p>在上面的代码中，我们定义了一个查找 <code>arr</code> 数组中所有组合的函数 <code>findAllCombinations</code>。函数定义了5个参数，其中两个是结果变量，其他三个是对组合进行操作的参数。</p>
<p>在函数的核心循环中，我们将 <code>current</code> 数组的拷贝传递给函数，以避免在使用 <code>current</code> 进行操作时更改原始组合数组。比如，我们递归调用 <code>findAllCombinations</code> 函数时传递的组合数组就要使用 <code>current.slice()</code> 而不是 <code>current</code>。 最后，函数将所有组合存储在 <code>result</code> 数组中，并在函数结束后返回该数组。</p>
<p>这样，就可以确保不会因为直接更改已经存储的组合数据而导致寻找不完整或重复的组合。</p>
<h4 id="不拷贝arr的副本-直接将数组加入结果中发生的影响"><a href="#不拷贝arr的副本-直接将数组加入结果中发生的影响" class="headerlink" title="不拷贝arr的副本  直接将数组加入结果中发生的影响"></a>不拷贝arr的副本  直接将数组加入结果中发生的影响</h4><p> 如果您不使用 <code>arr.slice()</code>，而是直接将 <code>arr</code> 作为当前组合进行操作并将其添加到结果数组中，可能会对结果产生意外的影响。我们可以看一下下面的示例代码：</p>
<p>`&#96;&#96;javascript<br>function findAllCombinations(arr, start, end, current, result) {<br> if (current.length &gt; 0) {<br>  result.push(current); &#x2F;&#x2F; <strong>将当前组合加入结果，这里不使用 arr.slice()</strong><br> }</p>
<p> for (let i &#x3D; start; i &lt;&#x3D; end; i++) {<br>  current.push(arr[i]);<br>  findAllCombinations(arr, i + 1, end, current, result);<br>  current.pop();<br> }<br>}</p>
<p>const arr &#x3D; [1, 2, 3];<br>const result &#x3D; [];</p>
<p>findAllCombinations(arr, 0, arr.length - 1, [], result);</p>
<p>console.log(result); &#x2F;&#x2F; 输出 [[], [1], [1, 2], [1, 2, 3], [1, 2], [1, 3], [1, 3], [2], [2, 3], [2], [3], [3]]<br>`&#96;&#96;</p>
<p>在上面的代码中，我们定义了一个查找 <code>arr</code> 数组中所有组合的函数 <code>findAllCombinations</code>，其中对于已经生成的组合数组没有使用 <code>arr.slice()</code>。这意味着在这里我们直接将 <code>current</code> 数组添加到结果数组中，而不是添加它的拷贝。由于数组是引用类型，这可能导致我们改变 <code>current</code> 数组进而产生一些奇怪的结果。</p>
<p>输出结果表明，在组合中添加一个元素之后，组合数组的其他部分也被莫名其妙地更改了。这是因为 <code>current</code> 数组直接被添加到了结果数组中，而不是 <code>arr.slice()</code> 的拷贝，所以添加新元素时，也添加并更改了已经存储在结果数组中的组合数组。</p>
<p>在使用回溯算法时，为了避免出现这种错误，通常会使用 <code>arr.slice()</code> 创建一个当前组合的副本，以确保在添加新元素时不会改变原始组合数据。</p>
<p>21 object.keys 返回一个对象的键值 将其弄成一个数组</p>
<p>22	@click.prevent 触发事件阻止默认行为  </p>
<p>23 find 返回遍历数组对象中符合条件的一项</p>
<p>24 QRcode插件是将url转换为二维码的东西   微信二维码 用饿了么组件库 的mesbox弹出框修改     </p>
<p>25 重定向二级路由</p>
<p><img src="/Yuanmingjian/../images/image-20230609165131931.png" alt="image-20230609165131931"></p>
<p>26 element ui 中table 中应用 作用域插槽</p>
<p><img src="/Yuanmingjian/../images/image-20230609195533515.png" alt="image-20230609195533515"></p>
<p>27 <img src="/Yuanmingjian/../images/image-20230609195806475.png" alt="image-20230609195806475"> </p>
<p>page 参数默认值 没赋值之前page默认为1</p>
<p>28 <strong>拓展运算符是深拷贝还是浅拷贝是看具体拷贝内容的，当拷贝的内容只有一层时是深拷贝，层数很多时时浅拷贝，</strong></p>
<p>29</p>
<p>Vue 中的 <strong>render</strong> 函数是一个核心函数，用于将组件的模板解析为虚拟 DOM，并渲染到页面中。与基于模板的渲染方式不同，render 函数是一种基于 JS 代码的声明式渲染方式，它将模板转换成一个由 JS 对象描述的 Virtual DOM 树，然后再通过 diff 算法对比新旧 Virtual DOM 树的差异，最终只对发生变化的节点进行重新渲染，从而提高了页面的性能。</p>
<p>在 Vue 的开发中，可以通过组件选项中的 render 属性来设置渲染函数，也可以使用 Vue.extend 或者 Vue.component API 创建组件时显式指定 render 函数。一般来说，开发者通过编写 render 函数，可以灵活地控制组件的渲染逻辑和渲染结果，同时也可以实现一些高级功能，例如动态组件、函数式组件、HOC（高阶组件）等。具体来说，render 函数有以下特点和用途：</p>
<ol>
<li>声明式渲染：render 函数可以根据传入的参数和状态，动态生成需要渲染的虚拟 DOM，这种声明式的渲染方式可以有效地简化组件的编写和维护。</li>
<li>动态渲染：由于 render 函数是基于 JS 代码的渲染方式，因此可以通过编写复杂的逻辑和条件表达式，在渲染组件时实现动态的渲染结果。</li>
<li>组件抽象：通过编写 render 函数，可以实现更加复杂和灵活的组件抽象，例如通用的高阶组件、适应不同数据结构的函数式组件等。</li>
<li>性能优化：由于 Virtual DOM 的存在，以及 diff 算法的实现，使用 render 函数可以有效地减少页面的重绘和重新排版次数，提升页面的性能和用户体验。</li>
</ol>
<p>一个基本的 render 函数通常包含一个返回值，这个返回值是一个虚拟 DOM 对象，它描述了组件需要渲染出来的 HTML 结构、属性、事件监听等。在编写 render 函数时，需要注意以下几点：</p>
<ol>
<li>render 函数必须返回一个虚拟 DOM 对象，通常使用 h 函数（也可以使用 createElement 函数）生成。</li>
<li>render 函数的参数包括两个部分：createElement 函数和上下文对象，前者可以用来创建虚拟 DOM 对象，后者包括组件选项、状态信息等。</li>
<li>在使用 render 函数时，不能在模板中使用组件选项属性，例如 props、data、methods 等，需要通过上下文对象和虚拟 DOM 的属性等方式来传递数据和方法。</li>
</ol>
<p>总之，render 函数是 Vue 中非常重要和强大的一部分，可以帮助我们更加灵活地控制组件的渲染逻辑和样式，并且可以提高页面的性能和用户体验。</p>
<p>30 vue 中双向绑定数组的更新需要用7个指定的方法 如push spilce</p>
<p>31 深拷贝 lodash里面cloneDeep</p>
<p>32 查看与编辑模式互相切换   一个输入框一个span显示款 互相切换   自动聚焦 给input添加ref       运用next tick  因为重绘和重排需要时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;template v-if=&quot;editMode&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;text&quot; ref=&quot;inputRef&quot; /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;button @click=&quot;toggleEditMode&quot;&gt;&#123;&#123; editMode ? &#x27;保存&#x27; : &#x27;编辑&#x27; &#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      editMode: false,</span><br><span class="line">      text: &#x27;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toggleEditMode() &#123;</span><br><span class="line">      this.editMode = !this.editMode;</span><br><span class="line">      if (this.editMode) &#123;</span><br><span class="line">        // 使用 nextTick 将聚焦设置在输入框上</span><br><span class="line">        this.$nextTick(() =&gt; &#123;</span><br><span class="line">          this.$refs.inputRef.focus();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>33 追加的对象无响应式 需要用this。￥se’t</p>
<p>34 <img src="/Yuanmingjian/../images/image-20230329115455068.png" alt="image-20230329115455068"></p>
<p>​                                     x坐标离这个y坐标太近了</p>
<p>35 在父组件中可以给子组件定义ref来获取子组件身上的属性和方法</p>
<p>36 new Boolean(false)&amp;&amp;true 结果为true</p>
<p>37 将图片转化为64进制的 会减少请求次数 减轻服务器压力 缺点就是体积会增大</p>
<p>38 <code>.**filter(Boolean)</code> 是一个数组的过滤操作**，它使用 <code>Boolean</code> 函数作为过滤条件。</p>
<p> 在 JavaScript 中，<code>Boolean</code> 函数用于将给定的值转换为对应的布尔值。当传递给 <code>Boolean</code> 函数的值是 falsy 值（如 <code>false</code>、<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code> 或空字符串），它会返回 <code>false</code>；否则，它会返回 <code>true</code>。</p>
<p><code>.filter(Boolean)</code> 中的 <code>Boolean</code> 函数被用作筛选条件，保留数组中的真值元素，并移除所有假值元素。在这种情况下，空数组 <code>[]</code> 中没有任何元素，因此返回的结果仍然是一个空数组 <code>[]</code>。这是因为过滤操作并没有符合筛选条件的元素，所以原始数组中的所有元素都被移除了。</p>
<p>以下是使用 <code>.filter(Boolean)</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy Codeconst arr = [0, 1, false, true, &#x27;&#x27;, &#x27;hello&#x27;, null, undefined];</span><br><span class="line">const filteredArr = arr.filter(Boolean);</span><br><span class="line"></span><br><span class="line">console.log(filteredArr); // 输出: [1, true, &#x27;hello&#x27;]</span><br></pre></td></tr></table></figure>

<p>在这个示例中，通过 <code>.filter(Boolean)</code> 过滤掉了数组中的假值元素，并返回了包含真值元素的新数组 <code>[1, true, &#39;hello&#39;]</code>。</p>
<p>39 </p>
<p><strong><img src="/Yuanmingjian/../images/image-20230731202227122.png" alt="image-20230731202227122"></strong></p>
<p>40 url有长度限制，太长的字符串会传递失败，可改用<a href="https://uniapp.dcloud.io/collocation/frame/communication">窗体通信</a>、<a href="https://ask.dcloud.net.cn/article/35021">全局变量</a>，另外参数中出现空格等特殊字符时需要对参数进行编码，如下为使用<code>encodeURIComponent</code>对参数进行编码的示例。</p>
<p>41 url为什么有长度限制 因为url会被当成一个整体  服务器需要划分一块内存来接收 不能进行分块处理</p>
<p>42 使用van-tab组件时  运用wx-for 发现刚加载进来看不到数据 只有点击标签才弹数据  active属性的原因</p>
<p>根据您提供的信息，删除了 <code>active=&#39;1&#39;</code> 后解决了问题。原因如下：</p>
<p>在 <code>&lt;van-tab&gt;</code> 组件中，通过设置 <code>active</code> 属性来指定默认选中的标签页。当设置 <code>active=&#39;1&#39;</code> 时，表示初始时选中索引为 1 的标签页。而您在数据加载完成后使用 <code>setData</code> 更新页面数据时，并没有重新设置 <code>active</code> 属性，导致默认选中的标签页仍然是索引为 1 的标签页。</p>
<p>由于初始时选中的标签页没有数据加载，所以在页面加载完成后看不到数据。只有当切换到其他标签页并再次切换回索引为 1 的标签页时，才会触发数据加载，并展示数据。</p>
<p>因此，通过删除 <code>active</code> 属性，可以让页面加载完成后默认选中索引为 0 的标签页，确保数据可以立即加载并展示。</p>
<p>如果您希望特定的标签页在页面加载完成后立即加载并展示数据，可以在 <code>onLoad</code> 生命周期钩子函数中调用数据加载的逻辑，并手动设置 <code>active</code> 属性为对应的索引值，以实现初始时选中该标签页并加载数据。</p>
<p>43 异步错误throw 1 不会影响promise的状态 只有同步可以</p>
<p>44 animation-timing-function:steps(20) 分成20段 瞬移20步完成动画</p>
<p>45 filter:drop-shadow()  整体轮廓阴影</p>
<p>46 微信小程序中，由于沙箱限制，只能读取小程序的用户文件目录及子目录下的文件。无法直接读取更外一层的文件。</p>
<p>46 uniapp中可以通过defineprors 获取页面跳转携带的参数</p>
<p>47 多维数组如何降维？</p>
<p>1 利用Array,prototype.flat()  2 递归遍历数组 元素是否为数组 是就继续调用函数  不是就添加进结果数组1</p>
<p><img src="/Yuanmingjian/../images/image-20230910171915419.png" alt="image-20230910171915419"></p>
<p>48<img src="/Yuanmingjian/../images/image-20230923225107513.png" alt="image-20230923225107513"></p>
<p>拼接字符串  比如在字符串中加入一个插值 就可以使用这个</p>
<p>49、</p>
<p>map是用于对数组进行改造  </p>
<p>foreach是单纯的遍历</p>
<p>两个都不会修改原数组 都不会给break和continte打断</p>
<p>50  箭头函数没有arguments   没有自己的this  无法通过call（）、bind（）来指定 函数this   不能作为构造函数调用</p>
<p> 51 tesseract.js文字识别</p>
<p>52 前端干货之随机图库 Lorem Picsum（只需要按规则写个网址就行，不需要集成任何插件环境）…</p>
<p>53 css 轮播图（滑动）   吸附效果    <strong>容器</strong> </p>
<p><img src="/Yuanmingjian/../images/image-20231113133603301.png" alt="image-20231113133603301"></p>
<p>   图片子元素</p>
<p><img src="/Yuanmingjian/../images/image-20231113133704923.png" alt="image-20231113133704923"> </p>
<p>54 pinia中的store是一个reactive包装的对象 所以里面的东东不需要value了在</p>
<p>55 nginx 配置 500 root 权限开启</p>
<p>56 <img src="/Yuanmingjian/../images/image-20231124225236792.png" alt="image-20231124225236792"></p>
<p>图标遍历 使用component来指定生成命名</p>
<p>57  遇到window不执行的效果</p>
<p><img src="/Yuanmingjian/../images/image-20231216215643514.png" alt="image-20231216215643514"></p>
<p>58 Intersection observer 可以实现 观察物体是否进入可视区域 并作出相应回调</p>
<p><img src="/Yuanmingjian/../images/image-20231228215446834.png" alt="image-20231228215446834"></p>
<p><img src="/Yuanmingjian/../images/image-20231228215505846.png" alt="image-20231228215505846"></p>
<p>59</p>
<p><img src="/Yuanmingjian/../images/image-20240104135722206.png" alt="image-20240104135722206"></p>
<p>60</p>
<p><img src="/Yuanmingjian/../images/image-20240121160624106.png" alt="image-20240121160624106"></p>
<p>61 </p>
<p>  子元素宽度随着文本内容变化而变化 fit-content</p>
<p>62 </p>
<p>深度遍历 observe 是在create之前完成的</p>
<p>63 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l*et* array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];  </span><br><span class="line">*<span class="keyword">let</span>* set = *<span class="keyword">new</span>* <span class="title class_">Set</span>(array);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.*<span class="keyword">from</span>*(set)); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>64 json serve 快速搭建一个 服务器接口</p>
<p>65  调整提示框的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tooltip</span>: &#123;</span><br><span class="line">        <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">        <span class="attr">position</span>: <span class="keyword">function</span>(<span class="params">point, params, dom, rect, size</span>)&#123;</span><br><span class="line">        <span class="comment">//其中point为当前鼠标的位置，size中有两个属性：viewSize和contentSize，分别为外层div和tooltip提示框的大小</span></span><br><span class="line">        <span class="keyword">var</span> x = point[<span class="number">0</span>];<span class="comment">//</span></span><br><span class="line">        <span class="keyword">var</span> y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> viewWidth = size.<span class="property">viewSize</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> viewHeight = size.<span class="property">viewSize</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> boxWidth = size.<span class="property">contentSize</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> boxHeight = size.<span class="property">contentSize</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> posX = <span class="number">0</span>;<span class="comment">//x坐标位置</span></span><br><span class="line">        <span class="keyword">var</span> posY = <span class="number">0</span>;<span class="comment">//y坐标位置</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;boxWidth)&#123;<span class="comment">//左边放不开</span></span><br><span class="line">            posX = <span class="number">5</span>;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//左边放的下</span></span><br><span class="line">            posX = x-boxWidth; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(y&lt;boxHeight)&#123;<span class="comment">//上边放不开</span></span><br><span class="line">            posY = <span class="number">5</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//上边放得下</span></span><br><span class="line">            posY = y-boxHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [posX,posY];</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>66  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-popover popper-class=&quot;routeFilePopover&quot; placement=&quot;right&quot; :width=&quot;400&quot; effect=&quot;dark&quot; trigger=&quot;hover&quot;&gt;</span><br><span class="line"></span><br><span class="line">                      &lt;template #reference&gt;</span><br><span class="line">                        &lt;el-icon class=&quot;questionFilled&quot;&gt;&lt;QuestionFilled /&gt;&lt;/el-icon&gt;</span><br><span class="line">                      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">​                      &lt;img v-if=&quot;routeImgUrl&quot; class=&quot;routeImg&quot; :src=&quot;routeImgUrl&quot; alt=&quot;routeFilePath&quot;&gt;</span><br><span class="line"></span><br><span class="line">                      &lt;p v-else class=&quot;noTextStyle&quot;&gt;暂无可选择的行驶路线！&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">​                    &lt;/el-popover&gt;</span><br></pre></td></tr></table></figure>

<p>好用的鼠标悬浮组件</p>
<p>67 好看的字体</p>
<p><img src="/Yuanmingjian/../images/image-20240307163327623.png" alt="image-20240307163327623"></p>
<p>68 图片清晰度 物理像素*dpr &#x3D; 设备像素</p>
<p><img src="/Yuanmingjian/../images/image-20240316150902200.png" alt="image-20240316150902200"></p>
<p><img src="/Yuanmingjian/../images/image-20240316150913358.png" alt="image-20240316150913358"></p>
<p>69 json-serve 快起一个微小的数据请求服务器</p>
<p> 70 echart 中提示框的信息被挡住  在tooltip中加入 上述</p>
<p>   根据位置改变提示框位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">position</span>: <span class="keyword">function</span>(<span class="params">point,params,dom,rect,size</span>)&#123;</span><br><span class="line">                            <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">let</span> y = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">let</span> pointX = point[<span class="number">0</span>]</span><br><span class="line">                            <span class="keyword">let</span> pointY = point[<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">let</span> boxWidth = size.<span class="property">contentSize</span>[<span class="number">0</span>]</span><br><span class="line">                            <span class="keyword">let</span> boxHeight = size.<span class="property">contentSize</span>[<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span>(boxWidth &gt; pointX)&#123;</span><br><span class="line">                                x = <span class="number">5</span></span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                x = pointX - boxWidth</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(boxHeight &gt; pointY)&#123;</span><br><span class="line">                                y = <span class="number">5</span></span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                y = pointY - boxHeight</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> [x,y]</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>

<p>71遇到通过按钮在同一个页面中来更新视图的echarts之类的问题，使用updated周期函数 加 v-if</p>
<p>72 mounted中异步任务还没结束 需要加一个定时器 来读异步操作获取的数据</p>
<p>73 写一个向上自动循环播放的文本框 需要理解offsetheight scollheight</p>
<p>74window.open(a,b) a:外部链接 ,b：打开方式（“_blank”新开一个窗口；“_self”覆盖当前窗口）</p>
<p>75 有可能通过vuex异步请求数据比在mounted钩子函数中加载更慢的原因是，异步请求需要一定的时间来获取数据，而在mounted钩子函数中，如果数据可以直接从本地获取，则不会存在网络请求的延迟。此外，使用vuex中actions异步请求数据，还需要建立一层通信桥梁，即action和mutation之间的通信，也可能会增加时间成本。</p>
<p>为了减少异步请求数据的时间和提高页面性能，我们可以使用loading状态来提示用户正在加载数据，并在数据加载完成后及时将其隐藏。同时，可以考虑对数据进行缓存，避免重复请求已经获取过的数据，进一步提升数据获取的效率。</p>
<p>76 最后一个字符只显示一半</p>
<p>用css属性 </p>
<p>word-break：break-all</p>
<p>与自动滑动的一个模板使用时 由于overflow：hidden的原因会发现最后一个字依旧无法显示完全 只能通过给你文字内容包裹一层div 固定他的长度</p>
<p>77 提取表单数据 发给服务器</p>
<p><img src="/Yuanmingjian/../images/image-20230422162737736.png" alt="image-20230422162737736"></p>
<p> 78  vue-router.esm.js</p>
<pre><code>   [vue-router] Maximum call stack size exceeded
</code></pre>
<p>一般vue-router报错说明是路由配置出问题了，或者跳转调用路由的时候出现死循环，RangeError: Maximum call stack size exceeded是死循环出现的语句</p>
<p>79 其他js 文件中使用pinia</p>
<p><img src="/Yuanmingjian/../../images/image-20231216204753653.png" alt="image-20231216204753653"></p>
]]></content>
      
        <categories>
            
            <category> 杂 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2022/10/24/js%E9%AB%98%E7%BA%A7/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包."></a>闭包.</h1><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>1.如何产生闭包<br>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包<br>2.闭包到底是什么? </p>
<p> 闭包是 *<em>函数和函数内部能访问到的变量（词法环境） 的组合</em>（文档的）*</p>
<p>​    它是一个函数以及其捆绑的周边环境状态的引用的组合</p>
<p>3.产生闭包的条件?<br>*函数嵌套</p>
<p>内部函数引用了外部函数的数据(变量&#x2F;函数)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　　　<span class="title function_">alert</span>(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=<span class="title function_">f1</span>();</span><br><span class="line"></span><br><span class="line">　　<span class="title function_">result</span>(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p><strong>三、闭包的概念</strong>（阮一峰的）</p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p><strong><code>闭包</code>：</strong> <strong>函数A里包含了函数B，而函数B使用了函数A的变量，那么函数B被称为闭包或者闭包就是能够读取函数A内部变量的函数。</strong></p>
<p>可以看出闭包是函数作用域下的产物，<strong>闭包会随着外层函数的执行而被同时创建，它是一个函数以及其捆绑的周边环境状态的引用的组合</strong>。换而言之，<strong>闭包是内层函数对外层函数变量的不释放</strong>。</p>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>闭包常常用来「间接访问一个变量」。或者说，「隐藏一个变量」。<br> 假设在一个支付软件中，我们需要定义用户当前的资金总量，这个数字在很多地方都需要被访问到，如果不用闭包，或许我们能用一个全局函数？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">money</span> = <span class="number">4396.00</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样看起来很不妥。万一有人不怀好意把这个数改成7或者7777777了怎么办？</p>
<p>所以我们不能让别人直接访问这个变量，我们，得用局部变量了。</p>
<p>只是用局部变量别人又难以对这个数量进行改变，怎么办呢？</p>
<p>我们可以使用闭包，暴露一个函数，实现一个共有变量</p>
<p>此处借用阮一峰老师在闭包文章中的例子    （<a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">www.ruanyifeng.com/blog/2009/0…</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> money=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　moneyAdd=<span class="keyword">function</span>(<span class="params"></span>)&#123;money+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　　　<span class="title function_">alert</span>(money);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=<span class="title function_">f1</span>();</span><br><span class="line"></span><br><span class="line">　　<span class="title function_">result</span>(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　<span class="title function_">moneyAdd</span>();</span><br><span class="line"></span><br><span class="line">　　<span class="title function_">result</span>(); <span class="comment">// 1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码中第一次引用result函数的值等于999，之后引用result函数的值等于1000。</p>
<p>此时的result函数其实就是闭包函数f2，result值的变化表示money已经成为了“全局变量”，在f1被引用后并没有消失，而是被储存在某个内存之中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<h3 id="闭包产生的原因："><a href="#闭包产生的原因：" class="headerlink" title="闭包产生的原因："></a>闭包产生的原因：</h3><h3 id="闭包怎么设计？"><a href="#闭包怎么设计？" class="headerlink" title="闭包怎么设计？"></a>闭包怎么设计？</h3><p>先不看答案，考虑一下我们解决这个静态作用域链中的父作用域先于子作用域销毁怎么解决。</p>
<p><strong>首先，父作用域要不要销毁？ 是不是父作用域不销毁就行了？</strong></p>
<p>不行的，父作用域中有很多东西与子函数无关，为啥因为子函数没结束就一直常驻内存。这样肯定有性能问题，所以还是要销毁。 但是销毁了父作用域不能影响子函数，所以要再创建个对象，要把子函数内引用（refer）的父作用域的变量打包里来，给子函数打包带走。</p>
<p><strong>怎么让子函数打包带走？</strong></p>
<p>设计个独特的属性，比如 [[Scopes]] ，用这个来放函数打包带走的用到的环境。并且这个属性得是一个栈，因为函数有子函数、子函数可能还有子函数，每次打包都要放在这里一个包，所以就要设计成一个栈结构，就像饭盒有多层一样。</p>
<p>我们所考虑的这个解决方案：销毁父作用域后，把用到的变量包起来，打包给子函数，放到一个属性上。这就是闭包的机制。</p>
<h2 id="给闭包下个定义"><a href="#给闭包下个定义" class="headerlink" title="给闭包下个定义"></a>给闭包下个定义</h2><p>用我们刚刚的试验来给闭包下个定义：</p>
<p><strong>闭包是在函数创建的时候，让函数打包带走的根据函数内的外部引用来过滤作用域链剩下的链。它是在函数创建的时候生成的作用域链的子集，是打包的外部环境。evel 因为没法分析内容，所以直接调用会把整个作用域打包（所以尽量不要用 eval，容易在闭包保存过多的无用变量），而不直接调用则没有闭包。</strong></p>
<p>过滤规则：</p>
<ol>
<li>全局作用域不会被过滤掉，一定包含。所以在何处调用函数都能访问到。</li>
<li>其余作用域会根据是否内部有变量被当前函数所引用而过滤掉一些。不是每个返回的子函数都会生成闭包。</li>
<li>被引用的作用域也会过滤掉没有被引用的 binding （变量声明）。只把用到的变量打个包。</li>
</ol>
<h2 id="闭包的缺点-内存泄漏"><a href="#闭包的缺点-内存泄漏" class="headerlink" title="闭包的缺点  内存泄漏"></a>闭包的缺点  内存泄漏</h2><p>JavaScript 是静态作用域的设计，闭包是为了解决子函数晚于父函数销毁的问题，我们会在父函数销毁时，把子函数引用到的变量打成 Closure 包放到函数的 [[Scopes]] 上，让它计算父函数销毁了也随时随地能访问外部环境。</p>
<p>这样设计确实解决了问题，但是有没有什么缺点呢？</p>
<p>其实问题就在于这个 [[Scopes]] 属性上</p>
<p>我们知道 JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。</p>
<p><img src="/../../images/41c5c82d485b469ca92a36aec5b73ac0tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="image.png"></p>
<p>每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。</p>
<p>那么如果子函数返回了会发生什么呢？</p>
<p><strong>首先父函数的栈帧会销毁，子函数这个时候其实还没有被调用，所以还是一个堆中的对象，没有对应的栈帧，这时候父函数把作用域链过滤出需要用到的，形成闭包链，设置到子函数的 [[Scopes]] 属性上。</strong></p>
<p><img src="/../../images/473fde71299f47fd81bc4d2e1cbd90bbtplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="image.png"></p>
<p>父函数销毁，栈帧对应的内存马上释放，用到的 ssh Obj 会被 gc 回收，<strong>而返回的函数会把作用域链过滤出用到的引用形成闭包链放在堆中</strong>。 这就导致了一个隐患： 如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。</p>
<p>一些小细节</p>
<p>函数内部定义变量需要用var 不然会被定义为全局变量</p>
<h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><p><img src="/../../images/image-20230910160427286.png" alt="image-20230910160427286"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>/2022/10/23/js%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><p>1.理解<br>就是一块”地盘”，一个 代码座所在的区城      里面没有变量的值<br>它足静念的(相对于上下义对象)。在编写代码时就确定?<br>2.分类<br>全同外用域<br>”函数作用城<br>没有块作用城(ES6有l)<br>3.作用<br>隔离变量 不同作用域下同名变量不会有冲突</p>
<p>作用域与执行上下文的区别</p>
<p>1.区别1<br>*全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时<br>*全局执行上下文环境是在全局作用域确定之后js代码马上执行之前创建<br><em>函数执行上下文是在调用函数时，函数体代码执行之前创建<br>2.区别2<br>,</em> 作用域是静态的， 只要函数定义好了就一一直存在， 且不会再变化<br>*执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放<br>3.联系<br>*上下文环境(对象)是从属于所在的作用域<br>*全局上下文环境&#x3D;&#x3D;&gt;全局作用域<br>*函数上下文环境&#x3D;&#x3D;&gt;对应的函数使用域</p>
<p><img src="/../../images/image-20221023131114700.png" alt="image-20221023131114700"></p>
<p>​                                         <strong>fn（10）</strong></p>
<p><img src="/../../images/image-20230127194243447.png" alt="image-20230127194243447"></p>
<p><strong>1作用域是静态的，并不会说放在其他函数里执行而改变作用域的位置。</strong></p>
<p>  该题输出10  因为fn（）的作用域里没有x 就去全局作用域找</p>
<p><img src="/../../images/image-20230127195139872.png" alt="image-20230127195139872"></p>
<p><strong>属性查找和变量查找不一样 属性查找需要通过堆空间里的对象来查找         而变量就在作用域中查找即可</strong> –js高级尚硅谷p28</p>
<p>  fn2是一个属性不是声明的变量    作用域里面存的是声明的变量  外部找也找不到 就会报错    通过对象来找   this该处为obj             作用域链里没有fn2这个变量 </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[原型对象]]></title>
      <url>/2022/10/22/js%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p><img src="/../../images/image-20221022163750213.png" alt="image-20221022163750213"></p>
<p><img src="/../../images/image-20221022163855675.png" alt="image-20221022163855675"></p>
<p><strong>xx</strong></p>
<p>实例对象的隐式原型等于构造函数的显示原型 会显示原型指向一个object空对象</p>
<h4 id="显示原型属性不会影响之前的实例对象-但会影响后面的"><a href="#显示原型属性不会影响之前的实例对象-但会影响后面的" class="headerlink" title="显示原型属性不会影响之前的实例对象  但会影响后面的"></a>显示原型属性不会影响之前的实例对象  但会影响后面的</h4><p><img src="/../../images/image-20221022165252798.png" alt="image-20221022165252798"></p>
<p> 1 undefined 2 3</p>
<p>所有函数的proto_都是-样的<br><strong>.函数显示原型对象默认值（xxx.prototype）是一 个</strong>空Object实例对象（**在这个实例对象里面添加一些共同的方法）     (Object函数除外，因为_ proto__ 属性为null)<br>.所有函数都是Function函数的实例，包括Function本身_</p>
<p><strong><em>这意味着 <code>Function</code> 不仅是一个函数（可调用），而且也是一个对象。作为对象，它继承了 <code>Object</code> 上的属性和方法。作为函数，它具有函数的特性，比如可以被调用并创建新的实例。</em></strong></p>
<p><em>●Object的原型对象 是原型链的尽头0bject . prototype .</em>_ proto_</p>
<p>** 为null</p>
<p>constructor是存在于原型中的一个属性，用来指向构造函数， 作用是实例对象可以通过此属性来找到构造函数。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h5 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h5><p>3.87 UlC:&#x2F; 06&#x2F;28 <a href="mailto:&#x4b;&#64;&#74;&#46;&#x49;&#x69;">&#x4b;&#64;&#74;&#46;&#x49;&#x69;</a> 原型链的全貌图 # JavaScript # 前端开发工程师 # 编程 # 程序员 # web前端  <a href="https://v.douyin.com/iYBgvqAV/">https://v.douyin.com/iYBgvqAV/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p>
<p>有对象的地方就有 **<code>原型</code>**，每个对象都会在其内部初始化一个属性，就是prototype(原型)，原型中存储共享的属性和方法。当我们访问一个对象的属性时，js引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。这么一个寻找的过程就形成了 <strong><code>原型链</code></strong> 的概念。</p>
<p>一个原型对象也相当于是另一个构造函数的实例（父子）333</p>
<p>理解原型最关键的是理清楚__proto__、prototype、constructor三者的关系，我们先看看几个概念：</p>
<ul>
<li><p><strong>__proto__属性</strong>在所有对象中都存在，指向其构造函数的prototype对象；<strong>prototype对象</strong>只存在（构造）函数中，用于存储共享属性和方法；<strong>constructor属性</strong>只存在于（构造）函数的prototype中，指向（构造）函数本身。</p>
</li>
<li><p>一个对象或者构造函数中的<strong>隐式原型__proto__<strong>的属性值指向其构造函数的</strong>显式原型 prototype</strong> 属性值，关系表示为：<code>instance.__proto__ === instance.constructor.prototype</code></p>
</li>
<li><p>除了 Object，<strong>所有对象或构造函数的 prototype 均继承自 Object.prototype</strong>，原型链的顶层指向 null：<code>Object.prototype.__proto__ === null</code></p>
<p>包括Function.prototype也是指向Object.prototype</p>
</li>
<li><p>Object.prototype 中也有 constructor：<code>Object.prototype.constructor === Object</code></p>
</li>
<li><p><strong>构造函数</strong>创建的对象（Object、Function、Array、普通对象等）都是 Function 的实例，它们的 <strong>proto</strong> 均指向 Function.prototype。</p>
</li>
<li><p>Function即是构造函数同时也是自己的实例 它的prototype和__proto_都是指向Function.prototype</p>
</li>
<li><p>在 JavaScript 中，函数也是一种对象。因此，任何一个函数都可以被视为是一个对象。由于构造函数本质上也是函数，它也被视为是对象。</p>
</li>
<li><p>如Array就是一个构造函数 它是Function的实例对象 它既是对象也是函数    同时因为构造函数的prototype也是继承于Object的prototype</p>
</li>
</ul>
<p>看起来是不是有点乱？？别慌！！一张图帮你整理它们之间的关系</p>
<p><img src="/../../images/c53c982b06274603a7d99d2b9f49a4e5tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="原型关系图"></p>
<p>相同的配方再来一刀</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">arr.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true   Array的显示原型也是object的一个实例</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链是用来查找对象的属性的"><a href="#原型链是用来查找对象的属性的" class="headerlink" title="原型链是用来查找对象的属性的"></a>原型链是用来查找对象的属性的</h3><p><img src="/../../images/image-20230127150749559.png" alt="image-20230127150749559"></p>
<p><img src="/../../images/image-20230127150812590.png" alt="image-20230127150812590"></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>通过原型链继承创建的对象会继承父类的原型对象，并且继承了父类原型对象的属性和方法,这时实例也会有原型的constructor属性，如果不改变，子类也会出问题。当通过原型链继承时，子类的原型对象的 <code>constructor</code> 属性会默认指向父类构造函数。    </p>
<p><strong>为了修正这个行为，我们通常会手动将子类的原型对象的 <code>constructor</code> 属性指向子类的构造函数，以确保该属性正确地指向子类本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// Student.prototypep._proto_=Person.prototype</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;  <span class="comment">//重新修正constructor指向构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">constructor</span>); <span class="comment">// 输出：[Function: Student]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();  <span class="comment">//重点</span></span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解决原型链共享同一个原型-导致更改一个-其他的也会出现问题"><a href="#解决原型链共享同一个原型-导致更改一个-其他的也会出现问题" class="headerlink" title="解决原型链共享同一个原型 导致更改一个  其他的也会出现问题"></a>解决原型链共享同一个原型 导致更改一个  其他的也会出现问题</h3><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承也被称为伪经典继承，它综合了我们昨天说的原型链和盗用构造函数，将俩者的有点结合在了一起。它的基本思想是使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性，这样的好处就是可以把方法定义在原型上复用，每个实例又有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span> (name) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;bule&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">      <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> instancel = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;jackson&quot;</span>,<span class="number">22</span>);</span><br><span class="line">  instancel.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;pink&quot;</span>);</span><br><span class="line">  instancel.<span class="title function_">sayName</span>(); <span class="comment">// &quot;jackson&quot;</span></span><br><span class="line">  instancel.<span class="title function_">sayAge</span>();<span class="comment">//22</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(instancel.<span class="property">colors</span>);<span class="comment">// [&quot;red&quot;, &quot;yellow&quot;, &quot;bule&quot;, &quot;pink&quot;]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;bear&quot;</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;yellow&quot;, &quot;bule&quot;]</span></span><br><span class="line">  instance2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;bear&quot;;</span></span><br><span class="line">  instance2.<span class="title function_">sayAge</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>上面的代码大家有没有一种豁然开朗的感觉，SubType调用SuperType，并且传入name，然后定义自己的属性age，此外SubType.prototype也被赋值位SuperType实例。原型赋值后又在这个原型上添加sayage方法，这样创建俩个subType实例，这俩个实例都有自己属性，还可以共享相同的方法。</p>
<blockquote>
<p>组合继承弥补了原型链和盗用构造函数的不足，是js中使用最多的继承模式。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。</li>
<li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。</li>
</ul>
<p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性&#x2F;方法。</p>
<h3 id="寄生组合继承（解决组合继承调用两次父类构造函数的缺点）"><a href="#寄生组合继承（解决组合继承调用两次父类构造函数的缺点）" class="headerlink" title="寄生组合继承（解决组合继承调用两次父类构造函数的缺点）"></a>寄生组合继承（解决组合继承调用两次父类构造函数的缺点）</h3><p>组合继承存在这一定的效率问题，它的父类构造函数始终会被调用俩次，一次在创建字类原型时调用，另一次在子类构造函数中调用。本质上子类只需要在执行时重写自己的原型就行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> prototype = <span class="title class_">Object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">     prototype.<span class="property">constructor</span> = subType; <span class="comment">// </span></span><br><span class="line">     subType.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这<strong>个 inheritPrototype()函数实现了寄生式组合继承的核心逻辑</strong>。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的 prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例子中的子类型原型赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line">    <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性， 因此可以说这个例子的效率更高。而且原型链仍然保持不变。</p>
<blockquote>
<p>寄生式组合继承可以算是引用类型继承的最佳模式。</p>
</blockquote>
<ol>
<li>寄生组合继承：寄生组合继承是对组合继承的改进，它通过使用 <code>Object.create()</code> 方法来优化原型的继承。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br></pre></td></tr></table></figure>

<p>寄生组合继承被认为是解决原型链继承缺点的最佳方式，因为它避免了调用两次超类构造函数，同时保持了原型链的正确性和效率。</p>
<p>这些方法可以解决原型链继承的缺点，并提供更灵活和可控的继承方式。根据具体情况选择适合的继承方式是很重要的。</p>
<h4 id="—proto—不足"><a href="#—proto—不足" class="headerlink" title="—proto—不足"></a>—proto—不足</h4><p><code>__proto__</code> 属性在 <code>ES6</code> 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 <code>Object.getPrototypeOf()</code>。</p>
<blockquote>
<p>通过改变一个对象的 <code>[[Prototype]]</code> 属性来改变和继承属性会对性能造成非常严重的影响，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承自该 <code>[[Prototype]]</code> 的对象，如果你关心性能，你就不应该修改一个对象的 <code>[[Prototype]]</code>。</p>
</blockquote>
<p>如果要读取或修改对象的 <code>[[Prototype]]</code> 属性，建议使用如下方案，但是此时设置对象的 <code>[[Prototype]]</code> 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>()</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>()</span><br></pre></td></tr></table></figure>

<p>如果要创建一个新对象，同时继承另一个对象的 <code>[[Prototype]]</code> ，推荐使用 <code>Object.create()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">50</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(p);</span><br></pre></td></tr></table></figure>

<p>这里 <code>child</code> 是一个新的空对象，有一个指向对象 p 的指针 <code>__proto__</code>。</p>
<h4 id="object-getPrototypeof"><a href="#object-getPrototypeof" class="headerlink" title="object.getPrototypeof()"></a>object.getPrototypeof()</h4><p><code>Object.getPrototypeOf()</code> 是一个用于获取对象原型的方法。它接受一个参数，即要获取原型的对象，然后返回该对象的原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">let a = new A()</span><br><span class="line">object.getPrototypeOf(a)=A.prototype</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo 部署到GitHub的坑]]></title>
      <url>/2022/10/17/blogTips/</url>
      <content type="html"><![CDATA[<h1 id="hexo与Typora完美结合：插入图片方便"><a href="#hexo与Typora完美结合：插入图片方便" class="headerlink" title="hexo与Typora完美结合：插入图片方便"></a>hexo与Typora完美结合：插入图片方便</h1><h4 id="解决问题：直接复制粘贴到md的图片会自动打包到img文件夹-gitbub访问时才会找到显示"><a href="#解决问题：直接复制粘贴到md的图片会自动打包到img文件夹-gitbub访问时才会找到显示" class="headerlink" title="解决问题：直接复制粘贴到md的图片会自动打包到img文件夹 gitbub访问时才会找到显示"></a>解决问题：直接复制粘贴到md的图片会自动打包到img文件夹 gitbub访问时才会找到显示</h4><h3 id="1-用-npm-install-hexo-renderer-marked-命令安装插件"><a href="#1-用-npm-install-hexo-renderer-marked-命令安装插件" class="headerlink" title="1.用 npm install hexo-renderer-marked 命令安装插件"></a>1.用 <code>npm install hexo-renderer-marked</code> 命令安装插件</h3><h3 id="2-在config-yml中修改配置如下"><a href="#2-在config-yml中修改配置如下" class="headerlink" title="2.在config.yml中修改配置如下"></a>2.在config.yml中修改配置如下</h3><p><img src="/Yuanmingjian/../images/image-20220704161719373.png" alt="image-20220704161719373"></p>
<h3 id="3-在config-yml中添加配置如下："><a href="#3-在config-yml中添加配置如下：" class="headerlink" title="3.在config.yml中添加配置如下："></a>3.在config.yml中添加配置如下：</h3><p><img src="/Yuanmingjian/../images/image-20220704161814801.png" alt="image-20220704161814801"></p>
<h3 id="4-在source文件中创建任意一个文件来存储图片，我这里创建的文件名为images，如下："><a href="#4-在source文件中创建任意一个文件来存储图片，我这里创建的文件名为images，如下：" class="headerlink" title="4.在source文件中创建任意一个文件来存储图片，我这里创建的文件名为images，如下："></a>4.在source文件中创建任意一个文件来存储图片，我这里创建的文件名为images，如下：</h3><p><img src="/Yuanmingjian/../images/image-20220704161950079.png" alt="image-20220704161950079"></p>
<h3 id="5-打开typora-文件-gt-偏好设置-gt-图像，选择复制到指定路径-gt-点开文件图标，选择刚刚创建的“images”（自己创建的存储图片的文件）文件-gt-勾选如图下的三个勾选-如图下："><a href="#5-打开typora-文件-gt-偏好设置-gt-图像，选择复制到指定路径-gt-点开文件图标，选择刚刚创建的“images”（自己创建的存储图片的文件）文件-gt-勾选如图下的三个勾选-如图下：" class="headerlink" title="5.打开typora:文件-&gt;偏好设置-&gt;图像，选择复制到指定路径-&gt;点开文件图标，选择刚刚创建的“images”（自己创建的存储图片的文件）文件-&gt;勾选如图下的三个勾选,如图下："></a>5.打开typora:文件-&gt;偏好设置-&gt;图像，选择复制到指定路径-&gt;点开文件图标，选择刚刚创建的“images”（自己创建的存储图片的文件）文件-&gt;勾选如图下的三个勾选,如图下：</h3><p><img src="/Yuanmingjian/../images/image-20220704162152739.png" alt="image-20220704162152739"></p>
<h3 id="6-大功告成！接下来在用typora时，直接复制图片进来进好啦，结果就是下面效果了，会进行自动配置了"><a href="#6-大功告成！接下来在用typora时，直接复制图片进来进好啦，结果就是下面效果了，会进行自动配置了" class="headerlink" title="6.大功告成！接下来在用typora时，直接复制图片进来进好啦，结果就是下面效果了，会进行自动配置了"></a>6.大功告成！接下来在用typora时，直接复制图片进来进好啦，结果就是下面效果了，会进行自动配置了</h3><p><img src="/Yuanmingjian/../images/image-20220704162859328.png" alt="image-20220704162859328"></p>
<h4 id="参考文章：hexo博客如何插入图片-知乎-zhihu-com"><a href="#参考文章：hexo博客如何插入图片-知乎-zhihu-com" class="headerlink" title="参考文章：hexo博客如何插入图片 - 知乎 (zhihu.com)"></a>参考文章：<a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></h4><h2 id="hexo部署到gitbub"><a href="#hexo部署到gitbub" class="headerlink" title="hexo部署到gitbub"></a>hexo部署到gitbub</h2><p>csdn文章很多 搜一篇自己看</p>
<h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><p>1 部署的网站静态资源加载不出来 这是因为路径问题</p>
<p> 只需要改config.yml文件</p>
<p><img src="/Yuanmingjian/../images/image-20241108180321276.png" alt="image-20241108180321276"></p>
<p>这两个补充完整即可</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[js执行上下文]]></title>
      <url>/2022/10/17/js%E9%AB%98%E7%BA%A7/js%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<h4 id="1-代码分类-位置"><a href="#1-代码分类-位置" class="headerlink" title="1.代码分类(位置)"></a>1.代码分类(位置)</h4><p>*全局代码<br>*函数(局部)代码</p>
<h3 id="2-全局执行上下文"><a href="#2-全局执行上下文" class="headerlink" title="2.全局执行上下文"></a>2.全局执行上下文</h3><p>*<strong>在执行全局代码前将window确定为全局执行上下文</strong><br>*对全局数据进行预处理</p>
<ul>
<li><p>var<strong>定义的全局变量</strong>&#x3D;&#x3D;&gt;undefined,添加为window的属性</p>
</li>
<li><p><strong>function声明的全局函数</strong>&#x3D;&#x3D;&gt;赋值(fun)。 添加为window的方法</p>
</li>
<li><p>this&#x3D;&#x3D;&gt;赋值(window)<br>。*开始执行全局代码</p>
<h2 id="3-函数执行上下文"><a href="#3-函数执行上下文" class="headerlink" title="3.函数执行上下文"></a>3.函数执行上下文</h2><p>中在调用函数)准备执行函数体之前， 创建对应的函数执行上下文对象(虚拟的。存在于栈中<br>*<strong>对局部数据进行预处理</strong><br>*<strong>形参变量&#x3D;&#x3D;&gt;赋值(实参)&#x3D;&#x3D;&gt;添加为执行上下文的属性</strong></p>
</li>
<li><p>arguments&#x3D;&#x3D;&gt;賦值(实参列表)， 添加为执行上下文的属性</p>
</li>
<li><p>var定义的局部变量&#x3D;&#x3D;&gt;undefined, 添加为执行.上下文的属性</p>
</li>
<li><p>function声明的函数&#x3D;&#x3D;&gt; 赋值(fun)。添加为执行上下文的方法</p>
</li>
<li><p>this&#x3D;&#x3D;&gt; 赋值(调用函数的对象)<br>*开始执行函数体代码</p>
</li>
</ul>
<p><strong>ps</strong></p>
<ol>
<li>用函数时 执行上下文 </li>
<li>函数提升优先级优于变量提升（函数提升后执行）  <strong>当函数名与变量名相同时，函数声明依旧是是函数声明，不会被变量声明覆盖，但当变量赋值后，函数声明被同名变量覆盖</strong></li>
</ol>
<p>  3 预处理相当于收集数据 将数据存到执行上下文对象（栈） 中  </p>
<p>4       **执行上下文对象是一个虚拟的对象 ** <strong>存在于栈中</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2022/09/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
